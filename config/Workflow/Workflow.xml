<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sailpoint PUBLIC "sailpoint.dtd" "sailpoint.dtd">
<sailpoint>
<Workflow libraries="Identity" name="Do Provisioning Forms" type="Subprocess">
  <Variable input="true" name="identityName" required="true">
    <Description>
      The name of the identity object being modified.
    </Description>
  </Variable>
  <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
    <Description>
      The displayName of the identity being updated.
      This may be passed in, if not the script queries for this
      using a projection query and falls back to the name.
    </Description>
  </Variable>
  <Variable input="true" name="project" output="true" required="true">
    <Description>
      A ProvisioningProject object describing the modifications to the identity.
      This may include a list of Question objects which will 
      cause the generation of a Form and a WorkItem to solicit
      additional information necessary for provisioning.
    </Description>
  </Variable>
  <Variable input="true" name="formTemplate" required="true">
    <Description>
      The name of the Form object that will be the template for
      generated forms.
    </Description>
  </Variable>
  <Variable input="true" name="preferredOwner">
    <Description>
      Optional argument to buildProvisioningForm to pass in the name of
      an identity we should try to process first when feeding
      forms back to the workflow.  If there are no questions for that
      identity and there are questions for other identities, a form for
      one of the other identities is generated at random.  When set the
      value is usually the same as "sessionOwner" a built-in system variable
      containing the name of the user currently interacting with a 
      workflow session.
    </Description>
  </Variable>
  <Variable input="true" name="workItemPriority">
    <Description>
      String version of WorkItem.level that will be used
      to set the priority of any generated workitems.
    </Description>
  </Variable>
  <Variable input="true" name="requiredOwner">
    <Description>
      Optional argument to buildProvisioningForm to pass in the name of
      an identity we should try to process first when feeding
      forms back to the workflow.  If there are no questions for that
      identity and there are questions for other identities, no form is 
      returned and the workflow may terminate without answering all of the
      questions in the project.

      This variable should only be on if you want to generate provisioning
      forms for the requester before approval. When called after approval (from Identity Request Provision),
      we don't pass in this attribute and all the rest of the provisioning forms can be generated.
    </Description>
  </Variable>
  <Variable input="true" name="fallbackOwner">
    <Description>
      Optional argument to specify a fallback identity to own Forms when nothing else is specified.
    </Description>
  </Variable>
  <Variable input="true" name="accountSelectionOwner">
    <Description>
      Optional argument to buildAccountSelectionForm to specify identity that owns the Form.
    </Description>
  </Variable>
  <Variable input="true" name="disableManualAccountSelection">
    <Description>
      When set to 'true' the system will not send out Account Selection Notification emails 
      for users with more than one account on any one application and the system 
      can't determine the provisioning account.
      This is only passed in from Identity Refresh workflow.
    </Description>
  </Variable>
  <Variable name="workItemForm">
    <Description>
      Holds the assembled provisioning form for this user. This is generated
      dynamically and passed into a work item for presentation.  
      During rendering the new field values are saved in the form fields.  
      When the work item is assimilated, we copy the form from the work
      item back to this variable for further processing.
      
      Note that this must be named workItemForm if you want to use it
      in the "send" list of an Approval.  This is the name recognized
      by WorkItemFormBean.  If you need to use a different name, or
      have multiple forms then you will need to use an Arg in the Approval
      to do the name translation.
    </Description>
  </Variable>
  <Variable name="formOwnerError">
    <Description>
      Set to true if we ever have difficulty determining a form owner.
      Used to break out of the provisioning loop.  This really shouldn't
      be necessary but be safe.
    </Description>
  </Variable>
  <Variable name="workItemComments">
    <Description>
     Global comments list which should be appended to the comments list ofr
     each approval.
    </Description>
  </Variable>
  <Variable name="accountSelectionForm">
    <Description>
      Dynamic account selection form generated when target account is ambiguous.
    </Description>
  </Variable>
  <Variable name="calculatedAccountSelectionOwner">
    <Description>
      Calculated owner value for account selection form.
    </Description>
  </Variable>
  <Step icon="Start" name="start" posX="33" posY="16">
    <Transition to="Get Account Selection Owner"/>
  </Step>
  <Step action="call:getAccountSelectionOwner" condition="script:project != null &amp;&amp; !isTrue(disableManualAccountSelection) &amp;&amp; (project.hasUnansweredProvisioningTargets() || project.hasUnansweredAccountSelections())" name="Get Account Selection Owner" posX="372" posY="12" resultVariable="calculatedAccountSelectionOwner">
    <Arg name="accountSelectionOwner" value="ref:accountSelectionOwner"/>
    <Arg name="owner" value="ref:requiredOwner"/>
    <Arg name="preferredOwner" value="ref:preferredOwner"/>
    <Arg name="fallbackOwner" value="ref:fallbackOwner"/>
    <Transition to="Build Account Selection Form"/>
  </Step>
  <Step action="call:buildAccountSelectionForm" condition="script:project != null &amp;&amp; !isTrue(disableManualAccountSelection) &amp;&amp; project.hasUnansweredProvisioningTargets()" name="Build Account Selection Form" posX="561" posY="12" resultVariable="accountSelectionForm">
    <Arg name="project" value="ref:project"/>
    <Arg name="owner" value="ref:calculatedAccountSelectionOwner"/>
    <Description>
      Call the standard handler method to build the account selection form.
    </Description>
    <Transition to="Present Account Selection Form"/>
  </Step>
  <Step condition="script:!isNull(accountSelectionForm)" name="Present Account Selection Form" posX="561" posY="12">
    <Approval owner="script:accountSelectionForm.getTargetUser()" send="identityName,identityDisplayName,launcher">
      <AfterScript>
        <Source>
          import sailpoint.object.Form;
          import sailpoint.object.ProvisioningTarget;
          import sailpoint.object.AccountSelection;
          import sailpoint.object.Field;

          Form accountSelectionForm = item.getForm();
          
          Iterator fieldIterator = accountSelectionForm.iterateFields();

          List targets = project.getProvisioningTargets();
          
          //apply selected value to matching AccountSelection
          //if accountSelectionId, then apply to the first unanswered AccountSelection
          while (fieldIterator.hasNext()) {
              Field fld = (Field)fieldIterator.next();
              if (fld == null) 
                continue;

              Integer targetIndex = (Integer)fld.getAttribute("targetIndex");
              Integer selectionIndex = (Integer)fld.getAttribute("selectionIndex");
              
              if (targetIndex == null || selectionIndex == null) continue;
                            
              ProvisioningTarget target = (ProvisioningTarget) targets.get(targetIndex.intValue());
              
              List selections = target.getAccountSelections();
              AccountSelection selection = (AccountSelection) selections.get(selectionIndex.intValue()); 
                 
              if (selection.isAnswered()) continue;
              
              if (fld.getValue().equals("doCreateOpt")) {
                selection.setDoCreate(true);
              }
              else {
                selection.setSelection(fld.getValue());
              }
          }
          
        </Source>
      </AfterScript>
      <Arg name="workItemType" value="Form"/>
      <Arg name="workItemDescription" value="Role Account Selection for $(identityDisplayName)"/>
      <Arg name="workItemForm" value="ref:accountSelectionForm"/>
      <Arg name="workItemDisableNotification">
        <Script>
          <Source>
           
            // If this is interactive then don't bother sending email notifications.
            return (null != sessionOwner) &amp;&amp; !sessionOwner.equals("System") &amp;&amp; !sessionOwner.equals("Scheduler");
            
          </Source>
        </Script>
      </Arg>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <WorkItemConfig escalationStyle="none">
        <NotificationEmailTemplateRef>
          <Reference class="sailpoint.object.EmailTemplate" name="Account Selection Notification"/>
        </NotificationEmailTemplateRef>
      </WorkItemConfig>
    </Approval>
    <Description>
      Present the account selection form and check to make sure all account selections were made.
    </Description>
    <Transition to="Handle Old Account Selections"/>
  </Step>
  <Step condition="script:project != null &amp;&amp; !isTrue(disableManualAccountSelection) &amp;&amp; project.hasUnansweredAccountSelections()" name="Handle Old Account Selections" posX="561" posY="12">
    <Approval owner="ref:calculatedAccountSelectionOwner" renderer="accountSelectionRenderer.xhtml">
      <AfterScript>
        <Source>
          import sailpoint.object.Attributes;
          import sailpoint.api.Provisioner;

          // Set the account selections back on the project.  Later these will
          // be consulted when the native identities are resolved.
          List accountSelections = approval.get("accountSelectionsFromWorkItem");
          project.setAccountSelections(accountSelections);

          // Recompile project so that selected native identities get put into
          // provisioning plans.
          Provisioner p = new Provisioner(wfcontext.getSailPointContext());
          Attributes args = wfcontext.getStepArguments();
          p.recompile(project, args);
        </Source>
      </AfterScript>
      <Arg name="workItemRequester" value="$(launcher)"/>
      <Arg name="workItemDescription" value="Account Selection for User: $(identityDisplayName)"/>
      <Arg name="workItemDisableNotification">
        <Script>
          <Source>
           
            // If this is interactive then don't bother sending email notifications.
            return (null != sessionOwner) &amp;&amp; !sessionOwner.equals("System") &amp;&amp; !sessionOwner.equals("Scheduler");
            
          </Source>
        </Script>
      </Arg>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="accounts" value="script:project.getAccountSelections()"/>
      <Arg name="expansionItems" value="script:project.getExpansionItems()"/>
      <Arg name="identityDisplayName" value="$(identityDisplayName)"/>
      <Arg name="identityName" value="$(identityName)"/>
      <Return local="true" name="accounts" to="accountSelectionsFromWorkItem"/>
      <ValidationScript>
        <Source>
          import sailpoint.object.AccountSelection;
          import sailpoint.tools.Util;

          // The return has not yet been processed since we're in the validator
          // script.  Grab the account selections from the work item.
          List accountSelections = item.getAttribute("accounts");

          // Make sure that all account selections have decisions.
          for (AccountSelection sel : accountSelections) {
              if (Util.isEmpty(sel.getSelectedNativeIdentities())) {
                  return "Please make a selection for each application.";
              }
          }
          return null;
        </Source>
      </ValidationScript>
      <WorkItemConfig escalationStyle="none">
        <NotificationEmailTemplateRef>
          <Reference class="sailpoint.object.EmailTemplate" name="Account Selection Notification"/>
        </NotificationEmailTemplateRef>
      </WorkItemConfig>
    </Approval>
    <Description>
      There are two ways to model account selections.  Pre 6.3 workflows use a 
      top-level List of AccountSelection objects on the project.  6.3 added a List
      of ProvisioningTarget objects.  We need to handle both, but there will never
      be a combination of them in the same workflow case.  This step handles
      the old model.
    </Description>
    <Transition to="Recompile Provisioning Project"/>
  </Step>
  <Step action="call:recompileProject" name="Recompile Provisioning Project" posX="99" posY="112" resultVariable="project">
    <Arg name="project" value="ref:project"/>
    <Description>
      Recompile the project.
    </Description>
    <Transition to="Build Provisioning Form"/>
  </Step>
  <Step action="call:buildProvisioningForm" name="Build Provisioning Form" posX="99" posY="112" resultVariable="workItemForm">
    <Arg name="project" value="ref:project"/>
    <Arg name="template" value="ref:formTemplate"/>
    <Arg name="owner" value="ref:requiredOwner"/>
    <Arg name="preferredOwner" value="ref:preferredOwner"/>
    <Arg name="fallbackOwner" value="ref:fallbackOwner"/>
    <Arg name="workItemComments" value="ref:workItemComments"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Description>
      Call the standard handler method to build the provisioning form
      from the specified template and question list.
    </Description>
    <Transition to="Present Provisioning Form"/>
  </Step>
  <Step condition="script:!isNull(workItemForm)" name="Present Provisioning Form" posX="99" posY="252">
    <Approval owner="script:workItemForm.getTargetUser()" return="workItemForm" send="identityName,identityDisplayName,workItemForm,launcher">
      <Arg name="workItemType" value="Form"/>
      <Arg name="workItemDescription" value="Complete provisioning form for $(identityDisplayName)"/>
      <Arg name="workItemDisableNotification">
        <Script>
          <Source>
            
            // 
            // If this is interactive then don't bother sending email
            // notifications.
            // 
            // There is some subtle logic here. Basically requiredOwner
            // is null most of the time except in the case of pre-approval
            // forms. In that case we want to return the forms for the
            // required owner so they can fill it in during the request
            // process instead of waiting on a workitem.  
            //
            boolean disableEmail = false;
            String owner = ( requiredOwner != null ) ? requiredOwner : sessionOwner;
            if ( Util.nullSafeEq(owner, workItemForm.getTargetUser()) ) { 
                disableEmail = true;
            }
            return disableEmail;
            
          </Source>
        </Script>
      </Arg>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <WorkItemConfig escalationStyle="none">
        <NotificationEmailTemplateRef>
          <Reference class="sailpoint.object.EmailTemplate" name="Provisioning Form Notification"/>
        </NotificationEmailTemplateRef>
      </WorkItemConfig>
    </Approval>
    <Description>
      Present the form we calculated in the previous step.
      TODO: Need something more formal to determine who the owner
      of this should be.
    </Description>
    <Transition to="Assimilate Provisioning Form"/>
  </Step>
  <Step action="call:assimilateProvisioningForm" condition="script:!isNull(workItemForm)" name="Assimilate Provisioning Form" posX="314" posY="252" resultVariable="project">
    <Arg name="project" value="ref:project"/>
    <Arg name="form" value="ref:workItemForm"/>
    <Description>
      Assimilate the results of the provisioning form back into the workflow.
      This may result in the generation of another set of questions for
      a different user.  Assimilation can also theoretically generate new
      questions for the same user if some of the template fields had
      conditional rendering.

      You can pass things into the Template and Field scripts by
      defining Args in this step.  You cannot change plan copmiler
      options, those were specified in the call to compileProvisioningProject
      and stored in the project for recompilation and execution.

      A new project is returned, but actually it will always be the
      same as the project passed in.
    </Description>
    <Transition to="Build Provisioning Form" when="(project != null &amp;&amp; project.hasQuestions()) &amp;&amp; !isNull(workItemForm)"/>
    <Transition to="end"/>
  </Step>
  <Step icon="Stop" name="end" posX="853" posY="12"/>
</Workflow>
<Workflow libraries="Identity" name="Do Manual Actions" type="Subprocess">
  <Variable input="true" name="identityName" required="true">
    <Description>
      The name of the identity object being modified.
    </Description>
  </Variable>
  <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
    <Description>
      The displayName of the identity being updated.
      This may be passed in, if not the script queries for this
      using a projection query and falls back to the name.
    </Description>
  </Variable>
  <Variable input="true" name="project" output="true" required="true">
    <Description>
      A ProvisioningProject object describing the modifications to the identity.
    </Description>
  </Variable>
  <Variable input="true" name="workItemPriority">
    <Description>
      String version of WorkItem.level that will be used
      to set the priority any generated workitems.
    </Description>
  </Variable>
  <Variable initializer="spadmin" input="true" name="fallbackApprover">
    <Description>
      A String that specifies the name of the Identity that will 
      be assigned any approvals where the owner of the approver 
      can't be resolved. Example if the scheme is "owner" and the 
      application doesn't specify and owner.
    </Description>
  </Variable>
  <Variable input="true" name="doAudit">
    <Description>
      When true we will audit the completion of manual action work items.
    </Description>
  </Variable>
  <Description>
     Preset the unmanaged portion of a provisioning project as work items
     to be processed manually.  This is used by the Identity Update and
     Identity Refresh workflows.  LCM has a similar step but it audits
     differently. Need to reconsider this and see if we can share the
     same subprocess.
   </Description>
  <RuleLibraries>
    <Reference class="sailpoint.object.Rule" name="Approval Library"/>
  </RuleLibraries>
  <Step icon="Approval" name="Manual Actions">
    <Approval mode="parallelPoll" owner="rule:Build Manual Action Approvals" renderer="lcmManualActionsRenderer.xhtml" send="identityDisplayName,identityName">
      <AfterScript>
        <Source>
          // Mark all items finished, LCM workflows do this for the dashboard
          // widget that tracks provisioning completion (the closed loop).
          // I'm not sure if we need that here, depends on which TaskResults
          // the scanner looks at, but be consistent.

          import sailpoint.object.ApprovalSet;
          import sailpoint.object.ApprovalItem;
          import sailpoint.object.WorkItem;

          // must be a leaf approval
          if (item != null) {
            ApprovalSet set = (ApprovalSet)item.get("approvalSet");
            if ( set != null ) {
                List approvalItems = set.getItems();
                for ( ApprovalItem approvalItem : approvalItems ) {
                    approvalItem.setState(WorkItem.State.Finished);
                }
            }

            // Audit the manual change
            // this is in LCM Workflow Library, if we think we need the
            // same level of auditing this will have to be brought over
            // to IdentityLibrary
            // if (doAudit)
            //   auditManualAction(item);
          }
        </Source>
      </AfterScript>
      <Arg name="workItemRequester" value="$(launcher)"/>
      <Arg name="workItemDescription" value="Manual Changes requested for User: $(identityDisplayName)"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="workItemType" value="ManualAction"/>
      <WorkItemConfig escalationStyle="none">
        <NotificationEmailTemplateRef>
          <Reference class="sailpoint.object.EmailTemplate" name="Pending Manual Changes"/>
        </NotificationEmailTemplateRef>
      </WorkItemConfig>
    </Approval>
    <Description>
      Build an Approval structure for the unmanaged plan in the provisioning project.
      The construtor is in the rule "Build Manual Action Approvals" that expects
      to be passed launcher, project, identityName, and fallbackApprover.
    </Description>
  </Step>
</Workflow>
<Workflow libraries="Identity,IdentityRequest" name="Provision with retries" type="Subprocess">
  <Variable input="true" name="project" output="true" required="true">
    <Description>
      Project that will be provisioned.
    </Description>
  </Variable>
  <Variable initializer="script:new Integer(60);" input="true" name="provisioningRetryThreshold" type="integer">
    <Description>
      The interval in minutes to wait to retry the request defaults to 
      60 minutes.  The retryInterval will be read from the underlying
      applications involved in the retry provisioning activity and
      the max interval defined across all applications will be used .
      If an interval is not specified on any of the Applications 
      we'll fall back to the setting in this variable which defaultws
      to an hour.
    </Description>
  </Variable>
  <Variable editable="true" initializer="script:new Integer(-1);" input="true" name="provisioningMaxRetries" type="integer">
    <Description>
       The maximum number of retries that will be attempted before failure 
       of the provisioning activities.  A value of -1 will execute
       retries indefinetly.
 
       Like provisioningRetry the value will be read from the
       application, if not defined on the application 
       we'll fall back to this setting which will default to -1.
    </Description>
  </Variable>
  <Variable initializer="false" input="true" name="enableRetryRequest">
    <Description>
      When set to true it will disable the retries loop and let the 
      Provision step launch requests to handle the retries.  Enabling
      this flag will enable some older functionality.
    </Description>
  </Variable>
  <Variable editable="true" initializer="true" input="true" name="foregroundProvisioning">
    <Description>
      Normally provisioning is done in a step that uses the "background"
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to 
      see the resutls of the request.
    </Description>
  </Variable>
  <Variable editable="true" input="true" name="recompileBeforeProvisioning">
    <Description>
      True to recompile the project prior to calling the Provisioner. This is useful when background
      provisioning is enabled, to pick up any changes that might have happened between the time the
      workflow was backgrounded, and the time in which it is resumed.
    </Description>
  </Variable>
  <Variable input="true" name="disableIdentityRequests">
    <Description>
      May be passed by the calling workflow to disable processing of
      IdentityRequest objects after provisioning.  This option should
      be passed by any workflow that is not used by LCM and does not
      maintain the IdentityRequest model.  This avoids logging a warning
      when the IdentityRequest is not found.
    </Description>
  </Variable>
  <Variable input="true" name="identityRequestId">
    <Description>
      The ID of the IdentityRequest for this request.
    </Description>
  </Variable>
  <Variable input="true" name="trace">
    <Description>
      Used for debugging this subprocess and when set to true trace
      statements will be sent to stdout.
    </Description>
  </Variable>
  <Variable name="retries" output="true" type="integer">
    <Description>
       The number of retries performed during the execution
       of the provisioning activities.
    </Description>
  </Variable>
  <Variable name="retryProject">
    <Description>
      Project that is assembled for retry purposes, the parts of
      original plan are broken into a separate plan that includes
      only the account requests that need to be retried.

      After each visit to retr this project will be rebuilt after
      the previous execution results are assimimlated back onto
      the "main" project.
    </Description>
  </Variable>
  <Variable input="true" name="splitProvisioning">
    <Description>
            True to denote this is a partial of the full ProvisioningPlan. This should be true in the case of LCM Provisioning
            splits.
        </Description>
  </Variable>
  <Step icon="Start" name="Start" posX="17" posY="104">
    <Transition to="Initialize Retries"/>
  </Step>
  <Step icon="Task" name="Initialize Retries" posX="101" posY="104">
    <Description>
      When visiting for the first time initalize the 
      retry variable and avoid the sleep that we'll 
      want when looping for retries.
    </Description>
    <Script>
      <Source>
        if ( retries == null ) { 
            retries = new Integer(0); 
        } else {
            retries++;
        }
        wfcontext.getWorkflowCase().put("retries", retries);
      </Source>
    </Script>
    <Transition to="Wait for next retry" when="script:(retries &gt; 0)"/>
    <Transition to="Provision"/>
  </Step>
  <Step name="Wait for next retry" posX="159" posY="17" wait="ref:retryInterval">
    <Description>
      This is a sleep step and just waits to execute the next step.
      Typically only called when we are retrying to give us some delay
      between calls down to the PE. Skipped during the first loop.
    </Description>
    <Transition to="Provision Retry"/>
  </Step>
  <Step action="call:provisionProject" icon="Provision" name="Provision" posX="258" posY="100">
    <Arg name="project" value="ref:project"/>
    <Arg name="background" value="!ref:foregroundProvisioning"/>
    <Description> 
       Call the typical provisionProject method during our first time
       through the workflow.  If there are retries this step
       will be skipped and should fall into the "Retry Provision"
       step.

       The only thing special here is the flag we specify to
       the PlanEvaluator to prevent the Request object from
       from being created if there are retries in the project.
       Then we can handle them directly in the workflow looping 
       until we are complete.
    </Description>
    <Transition to="Refresh Identity Request"/>
  </Step>
  <Step action="call:refreshIdentityRequestAfterProvisioning" name="Refresh Identity Request" posX="365" posY="100">
    <Arg name="project" value="ref:project"/>
    <Arg name="disableIdentityRequests" value="ref:disableIdentityRequests"/>
    <Description> 
       Refresh the identity request to include provisioning results and
       any other provisioning side effects in the project.
       
       Note that the disableIdentityRequests input variable is passed
       to skip request processing if we're being called from a non-LCM workflow.
       It is easier to pass this option than to transition around this step.
    </Description>
    <Transition to="Check for retry" when="!ref:enableRetryRequest"/>
    <Transition to="End" when="ref:enableRetryRequest"/>
  </Step>
  <Step action="call:retryProvisionProject" icon="Provision" name="Provision Retry" posX="421" posY="17" resultVariable="retryProject">
    <Arg name="project" value="ref:retryProject"/>
    <Arg name="disableRetryRequest" value="true"/>
    <Description> 
       Call retryProvisionProject method that will retry the plans
       in the project. Notice we pass in the retryProject which 
       contains only the parts of the main project that need
       to be retried.
    </Description>
    <Transition to="Merge Retry Project Results"/>
  </Step>
  <Step action="call:mergeRetryProjectResults" name="Merge Retry Project Results" posX="603" posY="17" resultVariable="project">
    <Arg name="project" value="ref:project"/>
    <Arg name="retryProject" value="ref:retryProject"/>
    <Description>
       Merge the results from the retry project back into the project.
       This step will take and items that are no longer marked rety
       over to the orginal project.
    </Description>
    <Transition to="Check for retry"/>
  </Step>
  <Step action="call:assembleRetryProject" icon="Task" name="Check for retry" posX="603" posY="98" resultVariable="retryProject">
    <Arg name="project" value="ref:project"/>
    <Description> 
       Dig into the project and look for things marked retryable.
       Build an new plan that contains only the retryable parts.
    </Description>
    <Transition to="Update Identity Request"/>
  </Step>
  <Step action="call:refreshIdentityRequestAfterRetry" condition="script:(retryProject != null)" name="Update Identity Request" posX="49" posY="262">
    <Arg name="project" value="ref:retryProject"/>
    <Description> 
       Update the Identity Request object with the retry details.
    </Description>
    <Transition to="Calculate Max Retry"/>
  </Step>
  <Step action="call:getProvisioningMaxRetries" name="Calculate Max Retry" posX="178" posY="262" resultVariable="provisioningMaxRetries">
    <Arg name="project" value="ref:retryProject"/>
    <Description> 
       Calculate the provisioningMaxRetries variable by digging into the
       retry project in an attempt to resolve the provisioningMaxRetries
       from the applications that are involved falling back
       to a system config.

       Use the provisioningMaxRetries to drive if we continue to loop or end.
    </Description>
    <Transition to="Calculate Retry Threshold"/>
  </Step>
  <Step action="call:getProvisioningRetryThreshold" name="Calculate Retry Threshold" posX="309" posY="262" resultVariable="retryInterval">
    <Arg name="project" value="ref:retryProject"/>
    <Description> 
       Calculate the retryInterval variable by digging into the
       retry project in an attempt to resolve the provisioningMaxRetries
       from the applications that are involved falling back
       to the workflow setting.
    </Description>
    <Transition to="Start" when="script:( ( retryProject != null ) &amp;&amp; ( provisioningMaxRetries == -1 || retries &lt; provisioningMaxRetries ) )"/>
    <Transition to="Timeout" when="script:( ( retryProject != null ) &amp;&amp;( retries &gt;= provisioningMaxRetries ) )"/>
    <Transition to="Check for more provisioning"/>
  </Step>
  <Step name="Check for more provisioning" posX="472" posY="259" resultVariable="project">
    <Description>
      There may be cases when dependencies that were waiting on a dependency will still have to be fulfulled,
      for those cases loop back to provisioning.
    </Description>
    <Script>
      <Source>
        if ( project.hasUnfinishedIntegrationPlans() ) {
            project.put("disableProjectReset", true);
        }
        return project;
      </Source>
    </Script>
    <Transition to="Provision" when="script: ( ( project != null ) &amp;&amp; (project.hasUnfinishedIntegrationPlans()) ) ;"/>
    <Transition to="End"/>
  </Step>
  <Step action="call:forceRetryTimeoutFailure" name="Timeout" posX="374" posY="413" resultVariable="project">
    <Arg name="message" value="Retry timeout occured."/>
    <Arg name="project" value="ref:project"/>
    <Arg name="disableIdentityRequests" value="ref:disableIdentityRequests"/>
    <Arg name="retryProject" value="ref:retryProject"/>
    <Description> 
       Go back through the project and mark everything that was being
       retried to failure.
    </Description>
    <Transition to="Update Identity Request with timeouts failures"/>
  </Step>
  <Step action="call:refreshIdentityRequestAfterProvisioning" name="Update Identity Request with timeouts failures" posX="539" posY="413">
    <Arg name="project" value="ref:project"/>
    <Description> 
       Update the Identity Request object with the failures that were added to
       the project due to retry timeout.
    </Description>
    <Transition to="End"/>
  </Step>
  <Step icon="Stop" name="End" posX="695" posY="413"/>
</Workflow>
<Workflow libraries="Identity,IdentityRequest" name="Check Status of queued items" type="Subprocess">
  <Variable input="true" name="project" output="true" required="true">
    <Description>
      Project that has account requests in the QUEUED state.
    </Description>
  </Variable>
  <Variable initializer="script:new Integer(60);" input="true" name="provisioningStatusCheckInterval" type="integer">
    <Description>
      The interval in minutes to retry the check status call,
      defaults to 1 hour.
    </Description>
  </Variable>
  <Variable initializer="script:new Integer(-1);" name="provisioningMaxStatusChecks" type="integer">
    <Description>
       The maximum number of status checks that will be tried before failure 
       of the provisioning activities.  A value of -1 will execute
       indefinetly, which is the default.
    </Description>
  </Variable>
  <Variable input="true" name="disableIdentityRequests">
    <Description>
      May be passed by the calling workflow to disable processing of
      IdentityRequest objects after provisioning.  This option should
      be passed by any workflow that is not used by LCM and does not
      maintain the IdentityRequest model.  This avoids logging a warning
      when the IdentityRequest is not found.
    </Description>
  </Variable>
  <Variable initializer="false" input="true" name="trace">
    <Description>
      Used for debugging this subprocess and when set to true trace
      statements will be sent to stdout.
    </Description>
  </Variable>
  <Variable input="true" name="splitProvisioning">
    <Description>
      True to denote this is a partial of the full ProvisioningPlan. This should be true in the case of LCM Provisioning
      splits.
    </Description>
  </Variable>
  <Variable name="statusChecks" output="true" type="integer">
    <Description>
       The number of status checks performed during the execution
       of the provisioning activities.
    </Description>
  </Variable>
  <Step icon="Start" name="Start" posX="25" posY="233">
    <Transition to="Requires Check"/>
  </Step>
  <Step action="call:requiresStatusCheck" icon="Task" name="Requires Check" posX="134" posY="233" resultVariable="requiresStatusCheck">
    <Arg name="project" value="ref:project"/>
    <Description>
       Up front check to compute if the status check is necessary.

       Dig into the plan and check to see if any of the plan results have 
       queued items with requestIds??

       If both are not true, bail out -- otherwise enter a loop 
       that will checking for status.       
    </Description>
    <Transition to="Initialize Status Checks" when="script:(requiresStatusCheck)"/>
    <Transition to="Apply Committed Results"/>
  </Step>
  <Step icon="Task" name="Initialize Status Checks" posX="192" posY="119">
    <Description>
      When visiting for the first time initalize the 
      statusChecks counter variable and avoid the sleep that we'll 
      want when looping while checking status.
    </Description>
    <Script>
      <Source>
        if ( statusChecks == null ) { 
            statusChecks = new Integer(0); 
        } else {
            statusChecks++;
        }
        wfcontext.getWorkflowCase().put("statusChecks", statusChecks);
      </Source>
    </Script>
    <Transition to="Calculate Max Checks"/>
  </Step>
  <Step action="call:getProvisioningMaxStatusChecks" name="Calculate Max Checks" posX="344" posY="119" resultVariable="provisioningMaxStatusChecks">
    <Description> 
       Calculate the maxRetries variable by digging into the
       retry project in an attempt to resolve the maxRetries 
       from the applications that are involved falling back
       to a system config.
    </Description>
    <Transition to="Calculate StatusCheck Threshold"/>
  </Step>
  <Step action="call:getProvisioningStatusCheckInterval" name="Calculate StatusCheck Threshold" posX="526" posY="119" resultVariable="provisioningCheckStatusInterval">
    <Arg name="project" value="ref:project"/>
    <Description> 
       Calculate the provisioningStatusCheckInterval variable by digging into the
       retry project in an attempt to resolve the maxRetries 
       from the applications that are involved falling back
       to the workflow setting.
    </Description>
    <Transition to="CheckStatus" when="script:(statusChecks == 0)"/>
    <Transition to="Wait for next check"/>
  </Step>
  <Step name="Wait for next check" posX="584" posY="16" wait="ref:provisioningCheckStatusInterval">
    <Description>
       Pause and waiting for things to happen on the PE side.  
       Use the configurable interval to determine how long
       we wait in between checks.
    </Description>
    <Transition to="CheckStatus"/>
  </Step>
  <Step action="call:checkProvisioningStatus" name="CheckStatus" posX="730" posY="16" resultVariable="project">
    <Arg name="project" value="ref:project"/>
    <Description> 
       Call the connector's checkStatus method for each queued item found in a project.
       This method will also update the status on the plan as items complete.
    </Description>
  </Step>
  <Step action="call:refreshIdentityRequestAfterProvisioning" name="Refresh Identity Request" posX="730" posY="121">
    <Arg name="project" value="ref:project"/>
    <Arg name="disableIdentityRequests" value="ref:disableIdentityRequests"/>
    <Description> 
       Refresh the identity request to include provisioning results returned
       from the connector's checkStatus any other provisioning side effects updated in the project.
       
       This method gives us the update of each access request item so it can
       be displayed in the UI as they complete instead of waiting for
       the entire process to complete.
       
       Note that the disableIdentityRequests input variable is passed
       to skip request processing if we're being called from a non-LCM workflow.
       It is easier to pass this option than to transition around this step.
    </Description>
    <Transition to="Requires Check" when="script:( provisioningMaxStatusChecks == -1 || statusChecks &lt; provisioningMaxStatusChecks)"/>
    <Transition to="Timeout" when="script:( statusChecks &gt;= provisioningMaxStatusChecks )"/>
    <Transition to="Apply Committed Results"/>
  </Step>
  <Step action="call:addMessage" name="Timeout" posX="916" posY="118">
    <Arg name="message" value="Max number of status checks occurred."/>
    <Description> 
    </Description>
    <Transition to="Apply Committed Results"/>
  </Step>
  <Step action="call:applyCommittedResults" condition="script: return (statusChecks != null );" icon="Task" name="Apply Committed Results" posX="916" posY="229">
    <Arg name="project" value="ref:project"/>
    <Description>
      Apply any of the commited plans, account requests or attribute requests 
      that result from our checking the request status.
    </Description>
    <Transition to="End"/>
  </Step>
  <Step icon="Stop" name="End" posX="1116" posY="229"/>
</Workflow>
<Workflow libraries="Identity,IdentityRequest,Group" name="Manage Ticket" type="Subprocess">
  <Variable input="true" name="project" required="true">
    <Description>
      Project that is being provisioninged.
    </Description>
  </Variable>
  <Variable input="true" name="identityRequestId" output="true" required="true">
    <Description>
      The ID of the IdentityRequest object which can can be used to read/update 
      the external ticket id. 
    </Description>
  </Variable>
  <Variable input="true" name="ticketManagementApplication" required="true">
    <Description>
      Ticketing application that supports creating/updating objects of type ticket.
    </Description>
  </Variable>
  <Variable input="true" name="ticketDataGenerationRule">
    <Description>
      A rule that builds up the ticketing provisioning plan based on the workflow
      context.  This rule gets all of the arguments to this subprocess 
      plus the curreent workflow context.  The rule can return either a 
      ProvisioningPlan or a Map of name value pairs. 
      
      The rule name can be specified here on the subprocess or on the 
      ticketManagementApplication config under the same name as this 
      variable.
    </Description>
  </Variable>
  <Variable input="true" name="action" required="true">
    <Description>
      This is a breadcrumb given to the rule to help it generate the proper
      provisioning plan for the current injection point.  There will be several
      default injection points that will map to an action.
     
      OOTB There are four points which all workflow are injected and will map to the
      "actions" passed into this subprocess.
     
      open
      postApproval
      postProvisioning
      close
    </Description>
  </Variable>
  <Variable initializer="true" input="true" name="trace">
    <Description>
      Used for debugging this subprocess and when set to true trace
      statements will be sent to stdout.
    </Description>
  </Variable>
  <Variable name="ticketPlan">
    <Description>
      Plan that is generated during the processing of the ticektDataGenerationRule
      execution.  This will eventually be turned in to the ticketProject which can 
      be provisioned.
    </Description>
  </Variable>
  <Variable name="ticketProject">
    <Description>
      Variable that will hold our compiled project, that eventually will be 
      provisioned to the backend ticketing system.
    </Description>
  </Variable>
  <Variable input="true" name="ticketId" output="true">
    <Description>
      Variable that will hold the ticketId, it may be passed in for update
      and will be returned on create.  If this value is null AND the
      its not a create action, the ticket id will be read from 
      the identityRequest.externalTicketId field.
    </Description>
  </Variable>
  <Variable input="true" name="workItemPriority">
    <Description>
      String version of WorkItem.level that will be used
      to set the priority of any workitems.
    </Description>
  </Variable>
  <Description>
   A workflow subprocss designed to allow service/help desk tickets opened
   or updated during the lifecycle of a workflow.
  </Description>
  <Step icon="Start" name="Start" posX="27" posY="12"/>
  <Step action="call:generateTicketPlan" name="Generate Ticket Plan" posX="132" posY="12" resultVariable="ticketPlan">
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="identityRequest" value="ref:identityRequest"/>
    <Arg name="action" value="ref:action"/>
    <Arg name="application" value="ref:ticketManagementApplication"/>
    <Arg name="rule" value="ref:ticketDataGenerationRule"/>
    <Arg name="ticketId" value="ref:ticketId"/>
    <Description>
      A workflow service that will call to the generation rule to help
      generate an 'ObjectRequest' based provisioning plan that will be used to 
      create/update the ticket.  If the rule returns a plan that plan will be 
      returned directly by the buildTicketPlan call.  the rule returns a Map it will 
      be converted into a provisioning plan.
    </Description>
  </Step>
  <Step action="call:compileGroupProject" name="Compile Ticket" posX="251" posY="12" resultVariable="ticketProject">
    <Arg name="plan" value="ref:ticketPlan"/>
    <Arg name="requester" value="ref:launcher"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="disableRetryRequest" value="true"/>
    <Arg name="optimisticProvisioning" value="false"/>
    <Description>
      Compile the generated plan in a project so it can be provisioned.
      These will normally compile down to a single targeted connector plan.      
    </Description>
  </Step>
  <Step icon="Task" name="Provision Ticket" posX="379" posY="12">
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="project" value="ref:ticketProject"/>
    <Arg name="foregroundProvisioning" value="true"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="disableIdentityRequests" value="true"/>
    <Description>
      Call the standard subprocess to initialize the request, this includes
      auditing, building the approvalset, compiling the plan into 
      project and checking policy violations.
    </Description>
    <Return name="retries" to="retries"/>
    <Return name="project" to="ticketProject"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Provision with retries"/>
    </WorkflowRef>
    <Transition to="Update IdentityRequest External ID"/>
  </Step>
  <Step action="call:updateExternalTicketId" condition="script:( action.startsWith(&quot;open&quot;) );" name="Update IdentityRequest External ID" posX="551" posY="12" resultVariable="ticketId">
    <Arg name="project" value="ref:ticketProject"/>
    <Arg name="application" value="ref:ticketManagementApplication"/>
    <Description>
      Typically only called once, after the create of the ticket. This call will update
      the IdentityRequest.externalTicketId with the returned ticketId (String).
    </Description>
  </Step>
  <Step icon="Stop" name="End" posX="722" posY="12"/>
</Workflow>
<Workflow libraries="Role" name="Role Modeler - Impact Analysis" type="RoleModeler" workItemRenderer="workflow.xhtml">
  <Variable editable="true" name="doArchive" type="boolean">
    <Description>Set to true to enable archiving role versions.</Description>
    <Prompt>Enable Role Versioning</Prompt>
  </Variable>
  <Variable editable="true" initializer="true" name="doOverlapAnalysis" type="boolean">
    <Description>Set to true to enable role overlap analysis.</Description>
    <Prompt>Enable Overlap Enalysis</Prompt>
  </Variable>
  <Variable editable="true" name="doRoleAssignment" type="boolean">
    <Description>Set to true to enable role assignment analysis.</Description>
    <Prompt>Enable Role Assignment analysis</Prompt>
  </Variable>
  <Variable editable="true" initializer="100" name="maxGainLoss" type="int">
    <Description>Maximum number of Identities contained in the gains/loss list</Description>
    <Prompt>Gain/Loss Limit</Prompt>
  </Variable>
  <Variable editable="true" initializer="1" name="overlapThreshold" type="int">
    <Description>Minimum overlap percentage in any facet a role must have to be included in the result.</Description>
    <Prompt>Minimum Overlap Percentage</Prompt>
  </Variable>
  <Variable input="true" name="approvalObject">
    <Description>New version of role to approve</Description>
  </Variable>
  <Variable name="approvalType">
    <Description>Set to "delete" when deleting roles. Set to "rollback" when restoring a role archive.  Otherwise null.</Description>
  </Variable>
  <Variable input="true" name="approvalSource">
    <Description>
       Where in the UI we are requesting the approval.
       Values: modeler, directed, undirected, certification.
     </Description>
  </Variable>
  <Variable input="true" name="impactAnalysisOwner">
    <Description>Name of user to receive impact analysis result</Description>
  </Variable>
  <Variable initializer="call:getDisplayableRoleName" name="roleName">
    <Description>Role name referenced by the email templates</Description>
  </Variable>
  <Variable editable="true" initializer="false" name="noRolePropagation" type="boolean">
    <Description>Set to true to disable role change propagation.</Description>
  </Variable>
  <Step icon="Start" name="start">
    <Transition to="Impact Analysis"/>
  </Step>
  <Step action="launchImpactAnalysis" condition="script:!(impactAnalysisOwner == unbound || impactAnalysisOwner == null)" icon="Analysis" name="Impact Analysis" posX="141" posY="17">
    <Arg name="doOverlapAnalysis" value="ref:doOverlapAnalysis"/>
    <Arg name="overlapThreshold" value="ref:overlapThreshold"/>
    <Arg name="noApplicationTemplates" value="true"/>
    <Arg name="doRoleAssignment" value="ref:doRoleAssignment"/>
    <Arg name="maxGainLoss" value="ref:maxGainLoss"/>
    <Transition to="Review Analysis"/>
  </Step>
  <Step condition="script:!(impactAnalysisOwner == unbound || impactAnalysisOwner == null)" icon="Email" name="Review Analysis" posX="258" posY="17">
    <Approval owner="ref:impactAnalysisOwner">
      <Arg name="workItemDescription" value="Review impact analysis of $(call:getObjectClass): $(call:getDisplayableRoleName)"/>
      <WorkItemConfig escalationStyle="none">
        <NotificationEmailTemplateRef>
          <Reference class="sailpoint.object.EmailTemplate" name="Role Modeler - Impact Analysis Review"/>
        </NotificationEmailTemplateRef>
      </WorkItemConfig>
    </Approval>
    <Transition to="Commit"/>
  </Step>
  <Step action="commit" condition="script:(impactAnalysisOwner == unbound || impactAnalysisOwner == null) || approved" name="Commit" posX="375" posY="17">
    <Arg name="archive" value="ref:doArchive"/>
    <Transition to="stop"/>
  </Step>
  <Step icon="Stop" name="stop" posX="541" posY="17"/>
</Workflow>
<Workflow libraries="Role" name="Role Modeler - Owner Approval" type="RoleModeler" workItemRenderer="workflow.xhtml">
  <Variable editable="true" name="doArchive" type="boolean">
    <Description>Set to true to enable archiving role versions.</Description>
    <Prompt>Enable Role Versioning</Prompt>
  </Variable>
  <Variable editable="true" initializer="true" name="doOverlapAnalysis" type="boolean">
    <Description>Set to true to enable role overlap analysis.</Description>
    <Prompt>Enable Overlap Enalysis</Prompt>
  </Variable>
  <Variable editable="true" initializer="1" name="overlapThreshold" type="int">
    <Description>Minimum overlap percentage in any facet a role must have to be included in the result.</Description>
    <Prompt>Minimum Overlap Percentage</Prompt>
  </Variable>
  <Variable input="true" name="approvalObject">
    <Description>New version of role to approve</Description>
  </Variable>
  <Variable name="approvalType">
    <Description>Set to "delete" when deleting roles. Set to "rollback" when restoring an archive.  Otherwise null.</Description>
  </Variable>
  <Variable input="true" name="approvalSource">
    <Description>
       Where in the UI we are requesting the approval.
       Values: modeler, directed, undirected, certification.
     </Description>
  </Variable>
  <Variable input="true" name="impactAnalysisOwner">
    <Description>Name of user to receive impact analysis result</Description>
  </Variable>
  <Variable name="roleName">
    <Description>Role name referenced by the email templates</Description>
  </Variable>
  <Variable editable="true" initializer="false" name="noRolePropagation" type="boolean">
    <Description>Set to true to disable role change propagation.</Description>
  </Variable>
  <Step action="getDisplayableRoleName" icon="Start" name="start" resultVariable="roleName">
    <Description>
      Copy the role name to a variable for easier reference in the
      email template.  Skip to approvals if there is no impact
      analysis owner.
    </Description>
    <Transition to="Check Approvals" when="impactAnalysisOwner == unbound || impactAnalysisOwner == null"/>
    <Transition to="Impact Analysis"/>
  </Step>
  <Step action="launchImpactAnalysis" icon="Analysis" name="Impact Analysis" posX="167" posY="16">
    <Arg name="doOverlapAnalysis" value="ref:doOverlapAnalysis"/>
    <Arg name="overlapThreshold" value="ref:overlapThreshold"/>
    <Arg name="noApplicationTemplates" value="true"/>
    <Description>
      Call a handler method to launch the impact analysis task.
    </Description>
    <Transition to="Review Analysis"/>
  </Step>
  <Step icon="Email" name="Review Analysis" posX="276" posY="16">
    <Approval owner="ref:impactAnalysisOwner">
      <Arg name="workItemDescription" value="Review impact analysis of $(call:getObjectClass): $(call:getDisplayableRoleName)"/>
      <WorkItemConfig escalationStyle="none">
        <NotificationEmailTemplateRef>
          <Reference class="sailpoint.object.EmailTemplate" name="Role Modeler - Impact Analysis Review"/>
        </NotificationEmailTemplateRef>
      </WorkItemConfig>
    </Approval>
    <Description>
      Wait for review of the impact analyis report.
    </Description>
    <Transition to="stop" when="!approved"/>
    <Transition to="Check Approvals"/>
  </Step>
  <Step name="Check Approvals" posX="85" posY="125">
    <Description>
      Skip approvals if the launcher is also the (previous) role owner.
    </Description>
    <Transition to="Audit Success" when="call:isSelfApproval"/>
    <Transition to="Approve"/>
  </Step>
  <Step icon="Approval" name="Approve" posX="276" posY="222">
    <Approval owner="call:buildOwnerApproval">
      <WorkItemConfig escalationStyle="none">
        <NotificationEmailTemplateRef>
          <Reference class="sailpoint.object.EmailTemplate" name="Role Modeler - Approval"/>
        </NotificationEmailTemplateRef>
      </WorkItemConfig>
    </Approval>
    <Description>
      Single stage approval by the role owner.
      The handler method will build a suitable Approval object.
    </Description>
    <Transition to="Audit Success" when="approved"/>
    <Transition to="Audit Failure" when="!approved"/>
  </Step>
  <Step action="audit" icon="Audit" name="Audit Failure" posX="423" posY="218">
    <Arg name="source" value="ref:launcher"/>
    <Arg name="action" value="call:getApprovalAuditAction"/>
    <Arg name="target" value="Role: $(roleName)"/>
    <Arg name="string1" value="failure"/>
    <Transition to="stop"/>
  </Step>
  <Step action="audit" icon="Audit" name="Audit Success" posX="334" posY="120">
    <Arg name="source" value="ref:launcher"/>
    <Arg name="action" value="call:getApprovalAuditAction"/>
    <Arg name="target" value="Role: $(roleName)"/>
    <Arg name="string1" value="success"/>
    <Transition to="Commit"/>
  </Step>
  <Step action="commit" name="Commit" posX="423" posY="120">
    <Arg name="archive" value="ref:doArchive"/>
    <Transition to="stop"/>
  </Step>
  <Step icon="Stop" name="stop" posX="423" posY="12"/>
</Workflow>
<Workflow libraries="Identity" name="Identity Refresh" resultExpiration="-1" type="IdentityRefresh">
  <Variable input="true" name="identitizer" transient="true" type="object">
    <Description>
      Instance of sailpoint.object.Identitizer that launched this workflow.
      This is a transient object that will only be used if the
      workflow executes synchronously to completion when launched.
      It saves having finishRefresh allocate and initialize a new Identitizer.
    </Description>
  </Variable>
  <Variable input="true" name="identity" transient="true" type="object">
    <Description>
      Identity object we're refreshing.  This is a transient object
      that will only be used by finishRefresh if the workflow runs to 
      completion without suspending.
    </Description>
  </Variable>
  <Variable input="true" name="refreshOptions" type="object">
    <Description>
      Map of options to configure Identitizer when we're ready to 
      complete the refresh.  These were culled from the original set of
      options given to the Identitizer that launched this workflow.
    </Description>
  </Variable>
  <Variable input="true" name="identityName" type="string">
    <Description>
      The name of the identity object being refreshed.  The first half
      of the refresh will have been committed, this includes link refresh,
      attribute promotion, and role detction.
    </Description>
  </Variable>
  <Variable input="true" name="project">
    <Description>
      A ProvisioningProject object describing the modifications to the identity.
      This may include a list of Question objects which will 
      cause the generation of a Form and a WorkItem to solicit
      additional information necessary for provisioning.
    </Description>
  </Variable>
  <Variable input="true" name="changeEvents">
    <Description>
      A list of IdentityChangeEvent objects generated by pre-provisioning
      triggers.
    </Description>
  </Variable>
  <Variable input="true" name="detectionDifference">
    <Description>
      A sailpoint.object.Difference object with changes made to the
      detected role list during the first half of the refresh.  These
      will already have been committed to the database.  In theory this
      could be used to trigger approvals or notifications though we 
      don't really support the notion of "rejecting" a detection.
    </Description>
  </Variable>
  <Variable input="true" name="previousVersion" type="object">
    <Description>
      A copy of the Identity object made before the refresh.
      This is needed in the second phase of refresh for trigger processing.
    </Description>
  </Variable>
  <Variable editable="true" initializer="false" input="true" name="doManualActions">
    <Description>
      When set to 'true' the unmanged plan from the provisioning project
      will be converted into one or more manual action work items to request
      the changes since they can't be done automatically.
      This may be passed in from the refresh task arguments.
    </Description>
  </Variable>
  <Variable input="true" name="enableManualAccountSelection">
    <Description>
      When set to 'true' the system will send out Account Selection Notification emails 
      for users with more than one account on any one application and the system 
      can't determine the provisioning account.
      This may be passed in from the refresh task arguments.
    </Description>
  </Variable>
  <Step icon="Start" name="start" posX="28" posY="10">
    <Transition to="Evaluate Change Events"/>
  </Step>
  <Step condition="changeEvents != null" name="Evaluate Change Events" posX="161" posY="10">
    <Transition to="Do Provisioning Forms"/>
  </Step>
  <Step condition="project != null &amp;&amp; (project.hasQuestions() || (isTrue(enableManualAccountSelection) &amp;&amp; (project.hasUnansweredAccountSelections() ||  project.hasUnansweredProvisioningTargets())))" name="Do Provisioning Forms" posX="346" posY="10">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="fallbackOwner" value="spadmin"/>
    <Arg name="accountSelectionOwner" value="applicationOwner"/>
    <Arg name="formTemplate" value="Identity Refresh"/>
    <Arg name="disableManualAccountSelection" value="script:!isTrue(enableManualAccountSelection)"/>
    <Description>
      Call the standard subprocess for assembling, presenting, and assimilating
      provisioning forms.
    </Description>
    <Return name="project" to="project"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Do Provisioning Forms"/>
    </WorkflowRef>
    <Transition to="Manual Actions"/>
  </Step>
  <Step condition="isTrue(doManualActions) &amp;&amp; project.getUnmanagedPlan() != null" name="Manual Actions" posX="696" posY="10">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="project" value="ref:project"/>
    <Description>
      Present work items for the parts of the project that could not be sent
      to an integrated IDM system.
    </Description>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Do Manual Actions"/>
    </WorkflowRef>
    <Transition to="Finish Refresh"/>
  </Step>
  <Step action="finishRefresh" name="Finish Refresh" posX="515" posY="10">
    <Arg name="identitizer" value="ref:identitizer"/>
    <Arg name="identity" value="ref:identity"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="refreshOptions" value="ref:refreshOptions"/>
    <Arg name="previousVersion" value="ref:previousVersion"/>
    <Arg name="project" value="ref:project"/>
    <Description>
      Provision what is left in the project then finish the refresh
      by running policy checks, recalculating scores, and other things.
    </Description>
    <Transition to="Save Identity"/>
  </Step>
  <Step action="script: if (identity != null ) { context.saveObject(identity); context.commitTransaction(); }" condition="isTrue(doManualActions) &amp;&amp; project.getUnmanagedPlan() != null" name="Save Identity" posX="587" posY="150">
    <Arg name="identity" value="ref:identity"/>
    <Description>
      Present work items for the parts of the project that could not be sent
      to an integrated IDM system.
    </Description>
    <Transition to="end"/>
  </Step>
  <Step name="end" posX="859" posY="10"/>
</Workflow>
<Workflow configForm="Identity Update Config Form" libraries="Identity" name="Identity Update" type="IdentityUpdate">
  <Variable initializer="false" name="trace">
    <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
  </Variable>
  <Variable editable="true" name="optimisticProvisioning">
    <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be 
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
  </Variable>
  <Variable editable="true" initializer="true" name="foregroundProvisioning">
    <Description>
      Normally provisioning is done in a step that uses the "backgroud"
      option to force the workfow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintanance task to 
      see the resutls of the request.
    </Description>
  </Variable>
  <Variable editable="true" initializer="false" name="doManualActions">
    <Description>
      When set to 'true' the unmanged plan from the provisioning project
      will be converted into one or more manual action work items to request
      the changes since they can't be done automatically.
    </Description>
  </Variable>
  <Variable editable="true" initializer="false" name="doRefresh">
    <Description>
      Set to true to cause an identity refresh after the changes in the plan
      have been provisioned.  This is normally off, you might want this on
      if you want modification of identity or link attributes to result in
      an immediate re-evaluation of assigned and detected roles.
    </Description>
  </Variable>
  <Variable editable="true" initializer="false" name="requireCreateTemplates">
    <Description>
      When set to 'true' any requests for an account that does not exist
      will be forced into the unmanaged plan unless the target application
      specifies an account creation template.  This may be combined with
      doManualActions to have work items sent out to handle account creation.
    </Description>
  </Variable>
  <Variable editable="true" name="approver">
    <Description>
      Name of Identity to approve role assignments.
      This is not set when launched from the UI, but you may want
      to hard code an initializer for testing.
    </Description>
  </Variable>
  <Variable editable="true" initializer="spadmin" name="fallbackApprover">
    <Description>
      The name of an Identity that will be assigned ownership of any
      manual action work items if the application owner is not set.
    </Description>
  </Variable>
  <Variable input="true" name="identityName" required="true">
    <Description>
      Name of Identity that is being updated.
    </Description>
  </Variable>
  <Variable input="true" name="plan" required="true">
    <Description>
      Master provisioning plan containing the changes to process.
    </Description>
  </Variable>
  <Variable name="sessionOwner">
    <Description>
      This is a system variable that we do not need to declare, but it's 
      good for documentation.  This will be set when the workflow is launched
      to the name of the Identity that is considered to be the owner
      of the interactive UI session.  This is passed to call:buildProvisioningForm
      so that we present forms to the active user first before suspending and
      opening work items for other users.
    </Description>
  </Variable>
  <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" name="identityDisplayName">
    <Description>
      The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.
    </Description>
  </Variable>
  <Variable name="project">
    <Description>
      Provisioning project containing assigned roles and side effects,
      compiled from the input plan.
    </Description>
  </Variable>
  <Variable name="newRoles"/>
  <Variable name="oldRoles"/>
  <Variable name="linksToAdd"/>
  <Variable name="linksToMove"/>
  <Variable name="linksToRemove"/>
  <Variable name="approvalSet"/>
  <Variable initializer="LCM Identity Update Approval" input="true" name="approvalEmailTemplate">
    <Description>
     The email template to use for approval notifications.
    </Description>
  </Variable>
  <Step icon="Start" name="start" posX="19" posY="17">
    <Transition to="Inspect Plan"/>
  </Step>
  <Step action="calculateIdentityDifference" name="Inspect Plan" posX="106" posY="17">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="oldRoles" value="oldRoles"/>
    <Arg name="newRoles" value="newRoles"/>
    <Arg name="linksToAdd" value="linksToAdd"/>
    <Arg name="linksToMove" value="linksToMove"/>
    <Arg name="linksToRemove" value="linksToRemove"/>
    <Arg name="approvalSet" value="approvalSet"/>
    <Description>
      Dig some things out of the plan into variables.
      We're setting newRoles and oldRoles temporarily so we can use
      the old approval pages.  Sould be calculating other differences!
    </Description>
    <Transition to="Compile Project"/>
  </Step>
  <Step action="compileProvisioningProject" name="Compile Project" posX="204" posY="17" resultVariable="project">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="requester" value="ref:launcher"/>
    <Arg name="source" value="UI"/>
    <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
    <Arg name="requireCreateTemplates" value="ref:requireCreateTemplates"/>
    <Description>
      Compile the provisioning plan into a provisioning project.
      If you need to pass in provisioner options like "noFiltering"
      or "noRoleDeprovisioning" you must pass them as explicit
      arguments to the call.

      The evaluation options "requester" and "source" are commonly
      set here.

      You can also pass things into the Template and Field scripts by
      defining Args in this step.
    </Description>
    <Transition to="Start Approval Process" when="ref:approver"/>
    <Transition to="Start Provisioning Form Process"/>
  </Step>
  <Step action="setLaunchMessage" icon="Message" name="Start Approval Process" posX="358" posY="13">
    <Arg name="message" value="workflow_identity_approval"/>
    <Arg name="arg1" value="ref:identityDisplayName"/>
    <Arg name="arg2" value="ref:approver"/>
    <Description> 
      Add a message to the worflow launch result indicating that an approval is in progress.
      This also serves an example of building localized messages from the 
      catalog.
    </Description>
    <Transition to="Approval"/>
  </Step>
  <Step icon="Approval" name="Approval" posX="462" posY="13">
    <Approval description="Approve modification to $(identityDisplayName)" owner="ref:approver" renderer="identityUpdate.xhtml" send="identityName,identityDisplayName,newRoles,oldRoles,linksToAdd,linksToMove,linksToRemove,approvalSet">
      <Arg name="workItemNotificationTemplate" value="ref:approvalEmailTemplate"/>
    </Approval>
    <Transition to="end" when="!ref:approved"/>
    <Transition to="Start Provisioning Form Process"/>
  </Step>
  <Step action="setLaunchMessage" icon="Message" name="Start Provisioning Form Process" posX="270" posY="124">
    <Arg name="message" value="workflow_identity_forms"/>
    <Arg name="arg1" value="ref:identityDisplayName"/>
    <Transition to="Do Provisioning Forms"/>
  </Step>
  <Step name="Do Provisioning Forms" posX="270" posY="219">
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="formTemplate" value="Identity Update"/>
    <Arg name="preferredOwner" value="ref:sessionOwner"/>
    <Description>
      Call the standard subprocess for assembling, presenting, and assimilating
      provisioning forms.
    </Description>
    <Return name="project" to="project"/>
    <Return name="approvalSet" to="approvalSet"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Do Provisioning Forms"/>
    </WorkflowRef>
    <Transition to="Start Provisioning Process"/>
  </Step>
  <Step action="setLaunchMessage" icon="Message" name="Start Provisioning Process" posX="270" posY="315">
    <Arg name="message">
      <Script>
        <Source>
          // pick a message with more detail if we're provisioning
          import sailpoint.object.ProvisioningPlan;
          String msg = "workflow_identity_saved";
          boolean otherPlans = false;
          List plans = project.getPlans();
          if (plans != null) {
              for (int i = 0 ; i &lt; plans.size() ; i++) {
                  ProvisioningPlan plan = (ProvisioningPlan)plans.get(i);
                  if (!ProvisioningPlan.APP_IIQ.equals(plan.getTargetIntegration())) {
                     otherPlans = true;
                     break;
                  }
              }
          }

          if (project.getUnmanagedPlan() != null &amp;&amp; isTrue(doManualActions)) {
              if (otherPlans)
                  msg = "workflow_identity_provisioning_manual";
              else
                  msg = "workflow_identity_manual";
          }
          else if (otherPlans) {
              msg = "workflow_identity_provisioning";
          }

          return msg;
        </Source>
      </Script>
    </Arg>
    <Arg name="arg1" value="ref:identityDisplayName"/>
    <Transition to="Provision"/>
  </Step>
  <Step action="call:provisionProject" icon="Provision" name="Provision" posX="394" posY="315">
    <Arg name="background" value="!ref:foregroundProvisioning"/>
    <Arg name="project" value="ref:project"/>
    <Description>
      Provision what remains in the project.  Normally we won't
      be here with unanswered provisioning questions, but if we have them
      the provisioner will just skip creating those accounts and do what it can.
    </Description>
    <Transition to="Manual Actions"/>
  </Step>
  <Step condition="isTrue(doManualActions) &amp;&amp; project.getUnmanagedPlan() != null" name="Manual Actions" posX="490" posY="315">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="project" value="ref:project"/>
    <Description>
      Present work items for the parts of the project that could not be sent
      to an integrated IDM system.
    </Description>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Do Manual Actions"/>
    </WorkflowRef>
    <Transition to="Refresh Identity"/>
  </Step>
  <Step action="call:refreshIdentity" condition="ref:doRefresh" icon="Task" name="Refresh Identity" posX="599" posY="315">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="correlateEntitlements" value="true"/>
    <Arg name="provision" value="true"/>
    <Arg name="synchronizeAttributes" value="true"/>
    <Arg name="doManualActions" value="ref:doManualActions"/>
    <Description>
      Add arguments as necessary to enable refresh features.  Typically you only want this
      to correlate roles and possibly provision if we notice new assigned roles.
      Note that provisioning will be done in the Identity Refresh workflow so if there
      are any provisioning forms to display we won't feed them directly to the 
      current user, they'll have to return to the inbox.
    </Description>
    <Transition to="end"/>
  </Step>
  <Step name="Form Owner Error" posX="701" posY="9">
    <Script>
      <Source>
        //println("Unable to determine owner for provisioning form, terminating process");
        //println(wfcontext.getWorkflowCase().toXml());
      </Source>
    </Script>
    <Transition to="end"/>
  </Step>
  <Step icon="Stop" name="end" posX="599" posY="9"/>
</Workflow>
<Workflow libraries="Identity" name="Scheduled Assignment" resultExpiration="-1" type="ScheduledAssignment">
  <Variable input="true" name="identity">
    <Description>The database id of the target identity</Description>
  </Variable>
  <Variable input="true" name="identityName">
    <Description>The name of the target identity</Description>
  </Variable>
  <Variable input="true" name="assigner">
    <Description>The name of the identity considered to be the source of the assignment.
This is used for the audit event.  It is not necessary to make the assignment
becuase the original assigner will also be stored in RoleAssignment metadata
in the cube.</Description>
  </Variable>
  <Variable editable="true" initializer="script:System.getProperty(&quot;iiq.forceRefreshAfterScheduledRoleChange&quot;)" name="doRefresh">
    <Description>Set to true to cause a cube refresh after the assignment</Description>
  </Variable>
  <Variable input="true" name="eventType">
    <Description>The type of assignment.  This will be one of the constants defined in RoleEventGenerator.</Description>
  </Variable>
  <Variable input="true" name="role">
    <Description>The database id of the role to assign, if this is a role event</Description>
  </Variable>
  <Variable input="true" name="roleName">
    <Description>The name of the role to assign, if this is a role event</Description>
  </Variable>
  <Variable input="true" name="assignmentId">
    <Description>The unique id of the RoleAssignment, if this is a role event</Description>
  </Variable>
  <Variable input="true" name="application">
    <Description>The database id of an application, if this is an entitlement event</Description>
  </Variable>
  <Variable input="true" name="applicationName">
    <Description>The name of an application, if this is an entitlement event</Description>
  </Variable>
  <Variable input="true" name="instance">
    <Description>The name of an application instance, if this is an entitlement event</Description>
  </Variable>
  <Variable input="true" name="nativeIdentity">
    <Description>The specific id of the target account in the application, if this is an entitlement event</Description>
  </Variable>
  <Variable input="true" name="name">
    <Description>The name of an attribute in the account schema, if this is an entitlement event</Description>
  </Variable>
  <Variable input="true" name="value">
    <Description>The value of the account attribute, if this is an entitlement event</Description>
  </Variable>
  <Variable initializer="false" input="true" name="enableRetryRequest">
    <Description>
      When set to true it will disable the workflow retry loop and let the
      Provision step launch requests to handle the retries.  Enabling
      this flag will enable some older functionality.
    </Description>
  </Variable>
  <Variable initializer="true" input="true" name="enableManualAccountSelection">
    <Description>When set to &amp;#39;true&amp;#39; the system will send out Account Selection Notification emails 
    for users with more than one account on any one application and the system 
    can&amp;#39;t determine the provisioning account.
    This may be passed in from the refresh task arguments.</Description>
  </Variable>
  <Variable name="project">
    <Description>ProvisioningProject compiled from the Request</Description>
  </Variable>
  <Variable editable="true" initializer="false" input="true" name="doManualActions">
    <Description>When set to &amp;#39;true&amp;#39; the unmanged plan from the provisioning project
      will be converted into one or more manual action work items to request
      the changes since they can&amp;#39;t be done automatically.
      This may be passed in from the refresh task arguments.</Description>
  </Variable>
  <Variable initializer="false" name="identityHasOutstandingForms"/>
  <Description>
Workflow called to handle a scheduled assignment and deassignments,
commonly known as "sunrise" and "sunset".  These are intended to
be used only from Request objects that are scheduled by the provisioning
plan evaluator.
  </Description>
  <Step icon="Start" name="start" posX="28" posY="10">
    <Transition to="Compile Assignment Project"/>
  </Step>
  <Step action="call:compileScheduledAssignmentProject" icon="Task" name="Compile Assignment Project" posX="161" posY="10" resultVariable="project">
    <Arg name="identity" value="ref:identity"/>
    <Arg name="application" value="ref:application"/>
    <Arg name="nativeIdentity" value="ref:nativeIdentity"/>
    <Arg name="name" value="ref:name"/>
    <Arg name="value" value="ref:value"/>
    <Arg name="role" value="ref:role"/>
    <Arg name="assigner" value="ref:assigner"/>
    <Arg name="eventType" value="ref:eventType"/>
    <Arg name="instance" value="ref:instance"/>
    <Arg name="assignmentId" value="ref:assignmentId"/>
    <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
    <Arg name="disableRetryRequest" value="!ref:enableRetryRequest"/>
    <Arg name="enableManualAccountSelection" value="ref:enableManualAccountSelection"/>
    <Transition to="Inspect Project"/>
  </Step>
  <Step name="Inspect Project" posX="336" posY="10">
    <Script>
      <Source>
        // hooks for project customization before execution
      </Source>
    </Script>
    <Transition to="Check For Outstanding Forms" when="!ref:identityHasOutstandingForms"/>
    <Transition to="Do Provisioning Forms"/>
  </Step>
  <Step action="call:outstandingProvisioningFormsForIdentity" name="Check For Outstanding Forms" resultVariable="identityHasOutstandingForms">
    <Arg name="identity" value="ref:identity"/>
    <Arg name="project" value="ref:project"/>
    <Transition to="Recompile" when="ref:identityHasOutstandingForms"/>
    <Transition to="Do Provisioning Forms"/>
  </Step>
  <Step action="call:compileScheduledAssignmentProject" icon="Task" name="Recompile" resultVariable="project" wait="script:new Integer(5);">
    <Arg name="identity" value="ref:identity"/>
    <Arg name="application" value="ref:application"/>
    <Arg name="nativeIdentity" value="ref:nativeIdentity"/>
    <Arg name="name" value="ref:name"/>
    <Arg name="value" value="ref:value"/>
    <Arg name="role" value="ref:role"/>
    <Arg name="assigner" value="ref:assigner"/>
    <Arg name="eventType" value="ref:eventType"/>
    <Arg name="instance" value="ref:instance"/>
    <Arg name="assignmentId" value="ref:assignmentId"/>
    <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
    <Arg name="disableRetryRequest" value="!ref:enableRetryRequest"/>
    <Arg name="enableManualAccountSelection" value="ref:enableManualAccountSelection"/>
    <ConditionScript>
      <Source>identityHasOutstandingForms</Source>
    </ConditionScript>
    <Transition to="Inspect Project"/>
  </Step>
  <Step name="Do Provisioning Forms" posX="486" posY="10">
    <Arg name="preferredOwner"/>
    <Arg name="workItemComments"/>
    <Arg name="requiredOwner"/>
    <Arg name="fallbackOwner" value="spadmin"/>
    <Arg name="accountSelectionOwner" value="applicationOwner"/>
    <Arg name="formOwnerError"/>
    <Arg name="identityDisplayName"/>
    <Arg name="formTemplate" value="Identity Refresh"/>
    <Arg name="disableManualAccountSelection" value="script:!isTrue(enableManualAccountSelection)"/>
    <Arg name="calculatedAccountSelectionOwner"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="workItemForm"/>
    <Arg name="workItemPriority"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="accountSelectionForm"/>
    <ConditionScript>
      <Source>project != null &amp;&amp; (project.hasQuestions() || (isTrue(enableManualAccountSelection) &amp;&amp; (project.hasUnansweredAccountSelections() ||  project.hasUnansweredProvisioningTargets())))</Source>
    </ConditionScript>
    <Description>
      Call the standard subprocess for assembling, presenting, and assimilating
      provisioning forms.
    </Description>
    <Return name="approvalSet" to="approvalSet"/>
    <Return name="project" to="project"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Do Provisioning Forms"/>
    </WorkflowRef>
    <Transition to="Process Project Pre-Actions"/>
  </Step>
  <Step action="call:processProject" name="Process Project Pre-Actions">
    <Arg name="identity" value="ref:identity"/>
    <Arg name="project" value="ref:project"/>
    <Transition to="Provision"/>
  </Step>
  <Step icon="Task" name="Provision" posX="633" posY="9">
    <Arg name="disableIdentityRequests" value="true"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="maxRetries"/>
    <Arg name="provisioningRetryThreshold"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="identityRequestId"/>
    <Arg name="retryProject"/>
    <Arg name="retries"/>
    <Arg name="enableRetryRequest"/>
    <Arg name="foregroundProvisioning" value="true"/>
    <Description>
      Execute the scheduled assignment project.
      We call the standard subprocess that handles retries.
      Note that the disableIdentityRequests option is passed
      to prevent logging a warning since this workflow does
      not maintain IdentityRequest objects.
    </Description>
    <Return name="project" to="project"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Provision with retries"/>
    </WorkflowRef>
    <Transition to="Refresh Identity"/>
  </Step>
  <Step action="call:refreshIdentity" condition="script:isTrue(doRefresh)" icon="Task" name="Refresh Identity" posX="786" posY="10">
    <Arg name="identity" value="ref:identity"/>
    <Arg name="doManualActions" value="false"/>
    <Arg name="correlateEntitlements" value="true"/>
    <Arg name="provision" value="true"/>
    <Description>
Add arguments as necessary to enable refresh features.  Provisioning is usually done
with an option to the Activate Assignment step.  Here you might want to check
policies or refresh the scorecard.  Correlating entitlements might pick up new
detected roles if the provisioning was done synchronously.
    </Description>
    <Transition to="Manual Actions"/>
  </Step>
  <Step condition="script:project.getUnmanagedPlan() != null" name="Manual Actions" posX="944" posY="10">
    <Arg name="project" value="ref:project"/>
    <Arg name="doAudit"/>
    <Arg name="workItemPriority"/>
    <Arg name="identityDisplayName"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="fallbackApprover"/>
    <Description>
      Present work items for the parts of the project that could not be sent
      to an integrated IDM system.
    </Description>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Do Manual Actions"/>
    </WorkflowRef>
    <Transition to="audit"/>
  </Step>
  <Step action="call:auditScheduledProject" icon="audit" name="audit" posX="1000" posY="10">
    <Transition to="end"/>
  </Step>
  <Step icon="Stop" name="end" posX="1086" posY="10"/>
</Workflow>
<Workflow libraries="Role,Identity" name="Scheduled Role Activation" resultExpiration="1" type="ScheduledRoleActivation">
  <Variable input="true" name="eventType">
    <Description>The type of the role activation event.  This will be one of the constants defined in RoleEventGenerator: roleActivation or roleDeactivation</Description>
  </Variable>
  <Variable input="true" name="role">
    <Description>The database id of the role we're changing.</Description>
  </Variable>
  <Variable input="true" name="roleName">
    <Description>The name of the role we're changing.</Description>
  </Variable>
  <Variable editable="true" initializer="script:System.getProperty(&quot;iiq.forceRefreshAfterScheduledRoleChange&quot;)" name="doRefresh">
    <Description>Set to true to cause a full identity refresh after activation.</Description>
  </Variable>
  <Variable name="activate">
    <Script>
      <Source>
        // we sholld only be here for activation or deactivation events, 
        // but err on the side of activation in case the type is wrong
        import sailpoint.api.RoleEventGenerator;
        return !RoleEventGenerator.EVENT_TYPE_ROLE_DEACTIVATION.equals(eventType);
      </Source>
    </Script>
  </Variable>
  <Variable editable="true" initializer="false" name="noRolePropagation" type="boolean">
    <Description>Set to true to disable role change propagation.</Description>
  </Variable>
  <Description>
Workflow called when a role is ready to be enabled or disabled.
  </Description>
  <Step icon="Start" name="start" posX="30" posY="10">
    <Transition to="Activate Role"/>
  </Step>
  <Step action="call:enableRole" condition="ref:activate" icon="Task" name="Activate Role" posX="140" posY="10">
    <Arg name="role" value="ref:role"/>
    <Transition to="Deactivate Role"/>
  </Step>
  <Step action="call:disableRole" condition="!ref:activate" icon="Task" name="Deactivate Role" posX="260" posY="10">
    <Arg name="role" value="ref:role"/>
    <Transition to="Audit Success"/>
  </Step>
  <Step action="audit" icon="Audit" name="Audit Success" posX="390" posY="10">
    <Arg name="source" value="ref:launcher"/>
    <Arg name="action" value="script:(activate) ? &quot;activate&quot; : &quot;deactivate&quot;"/>
    <Arg name="target" value="ref:roleName"/>
    <Arg name="string1" value="script:((activate) ? &quot;Activated &quot; : &quot;Deactivated &quot;) + roleName"/>
    <Arg name="string2" value="Success"/>
    <Transition to="Refresh Identities"/>
  </Step>
  <Step action="call:refreshIdentities" condition="ref:doRefresh" icon="Task" name="Refresh Identities" posX="525" posY="10">
    <Arg name="identitiesWithRoles">
      <Script>
        <Source>
          // if we're deactivating, only refresh roles that have us
          import sailpoint.api.RoleEventGenerator;
          Object retval = null;
          if (RoleEventGenerator.EVENT_TYPE_ROLE_DEACTIVATION.equals(eventType)) 
             retval = role;
          return retval;
      </Source>
      </Script>
    </Arg>
    <Arg name="correlateEntitlements" value="true"/>
    <Arg name="provision" value="true"/>
    <Arg name="doManualActions" value="false"/>
    <Transition to="end"/>
  </Step>
  <Step icon="Stop" name="end" posX="650" posY="10"/>
</Workflow>
<Workflow libraries="Group" name="Entitlement Update" type="ManagedAttribute">
  <Variable initializer="false" name="trace"/>
  <Variable editable="true" name="optimisticProvisioning">
    <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be 
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
  </Variable>
  <Variable editable="true" initializer="true" name="foregroundProvisioning">
    <Description>
      Normally provisioning is done in a step that uses the "backgroud"
      option to force the workfow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintanance task to 
      see the resutls of the request.  For group requests this is much less
      of a problem than it is for account provisioning.
    </Description>
  </Variable>
  <Variable editable="true" initializer="false" name="doManualActions">
    <Description>
      When set to 'true' the unmanged plan from the provisioning project
      will be converted into one or more manual action work items to request
      the changes since they can't be done automatically.
    </Description>
  </Variable>
  <Variable editable="true" initializer="ref:appOwner" name="fallbackApprover">
    <Description>
      The Identity assigned approval work items for changes to entitlements if the defined approver is not found.
      If the manually assigned fallbackApprover is not found, no approval work item is created.
      By default, the fallbackApprover is set to owner of the application with which the entitlement is associated.
    </Description>
  </Variable>
  <Variable input="true" name="plan" required="true">
    <Description>
      Master provisioning plan containing the changes to process.
    </Description>
  </Variable>
  <Variable initializer="ref:owner" input="true" name="approver">
    <Description>
      The Identity assigned approval work items for entitlement changes.
      If the manually assigned approver is not found, the fallbackApprover is used.
      By default, the approver is set to the entitlement owner.
    </Description>
  </Variable>
  <Variable input="true" name="pamContainersToAggregate">
    <Description>
      List of names of PAM containers to aggregate.  This will likely only be set
      when creating a single PAM container.  Since pam containers are both Managed
      Attributes and Targets, we need to do a target aggregation for the newly created
      Container in order for PAM to see the container.
    </Description>
  </Variable>
  <Variable input="true" name="pamContainerToGroupAggregate">
    <Description>
      A resource object to group aggregate at the end of the workflow. This will only be set when updating a single
      PAM container.
    </Description>
  </Variable>
  <Variable input="true" name="applicationName">
    <Description>
      Name of application for targets to aggregate.  This will likely only be set
      when creating a single PAM container.
    </Description>
  </Variable>
  <Variable name="sessionOwner">
    <Description>
      This is a system variable that we do not need to declare, but it's 
      good for documentation.  This will be set when the workflow is launched
      to the name of the Identity that is considered to be the owner
      of the interactive UI session.  This is passed to call:buildProvisioningForm
      so that we present forms to the active user first before suspending and
      opening work items for other users.
    </Description>
  </Variable>
  <Variable name="summaryName">
    <Description>
      Single string representation of ManagedAttribute identity.
      This must be at least a combination of the application name
      and the managed attribute value (group name).
    </Description>
  </Variable>
  <Variable name="project">
    <Description>
      Provisioning project containing assigned roles and side effects,
      compiled from the input plan.
    </Description>
  </Variable>
  <Variable name="owner">
    <Description>
      Identity object that is the entitlement owner.
    </Description>
  </Variable>
  <Variable name="appOwner">
    <Description>
      Identity object that is the application owner.
    </Description>
  </Variable>
  <Variable name="changes">
    <Description>
      A ChangeSummary object containing a JSF friendly summary of the
      changes being made.  
    </Description>
  </Variable>
  <Step icon="Start" name="start" posX="17" posY="19">
    <Transition to="Examine Plan"/>
  </Step>
  <Step action="getSummaryName" name="Examine Plan" posX="112" posY="19" resultVariable="summaryName">
    <Description>
      Derive a single string we can use as the name of the entitlement
      in approvals and logging.
    </Description>
    <Transition to="Compile Project"/>
  </Step>
  <Step action="compileGroupProject" name="Compile Project" posX="219" posY="19" resultVariable="project">
    <Arg name="plan" value="ref:plan"/>
    <Arg name="requester" value="ref:launcher"/>
    <Arg name="source" value="GroupManagement"/>
    <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
    <Description>
      Compile the provisioning plan into a provisioning project.
      Unlike the project compilation step for identities, we do not
      expect to be dealing with provisioning policies and forms.
    </Description>
    <Transition to="Start Approval Process" when="script:approver!=null||fallbackApprover!=null"/>
    <Transition to="Start Provisioning Process"/>
  </Step>
  <Step action="setLaunchMessage" icon="Message" name="Start Approval Process" posX="285" posY="112">
    <Arg name="message" value="workflow_identity_approval"/>
    <Arg name="arg1" value="ref:summaryName"/>
    <Arg name="arg2" value="ref:approver"/>
    <Description> 
      Add a message to the worflow launch result indicating that an approval is in progress.
      This also serves an example of building localized messages from the catalog.
    </Description>
    <Transition to="Build Approval Summary"/>
  </Step>
  <Step action="buildGroupChangeSummary" name="Build Approval Summary" posX="432" posY="112" resultVariable="changes">
    <Arg name="plan" value="ref:plan"/>
    <Transition to="Approval"/>
  </Step>
  <Step icon="Approval" name="Approval" posX="554" posY="112">
    <Approval renderer="entitlement.xhtml" send="summaryName,changes">
      <Arg name="requester" value="ref:launcher"/>
      <Arg name="workItemDescription">
        <Script>
          <Source>
            String action = "modification";
            if (changes.delete)
                action = "deletion";
            else if (changes.create)
                action = "creation";
            return "Approve " + action + " of entitlement " + summaryName;
          </Source>
        </Script>
      </Arg>
      <OwnerScript>
        <Source>
          import sailpoint.object.Identity;
          Identity approverIdentity = null;
          if (approver instanceof String) {
              approverIdentity = wfcontext.getSailPointContext().getObjectByName(Identity.class, approver);
              if(approverIdentity == null) {
                  log.info("Invalid approver, fallback approver will be used if available");
              }
          }
          else 
              approverIdentity = approver;
          if (approverIdentity != null) {
              if (approverIdentity.getName().equals(requester))
                  return null;
              else
                  return approver;
          }
          else if (fallbackApprover != null) {
              if (fallbackApprover instanceof String) {
                  fallbackApproverIdentity = wfcontext.getSailPointContext().getObjectByName(Identity.class, fallbackApprover);
                  if (fallbackApproverIdentity == null) {
                      log.info("Invalid fallback approver, please verify fallback approver setting");
                  }
              }
              else
                  fallbackApproverIdentity = fallbackApprover;
              if (fallbackApproverIdentity != null) {
                  if (fallbackApproverIdentity.getName().equals(requester))
                      return null;
                  else
                      return fallbackApprover;
              }
          }
          else
              return null;
        </Source>
      </OwnerScript>
      <WorkItemConfig escalationStyle="none">
        <NotificationEmailTemplateRef>
          <Reference class="sailpoint.object.EmailTemplate" name="Entitlement Update Approval"/>
        </NotificationEmailTemplateRef>
      </WorkItemConfig>
    </Approval>
    <Transition to="end" when="!ref:approved"/>
    <Transition to="Start Provisioning Process"/>
  </Step>
  <Step action="setLaunchMessage" icon="Message" name="Start Provisioning Process" posX="612" posY="15">
    <Arg name="message">
      <Script>
        <Source>
          // pick a message with more detail if we're provisioning
          import sailpoint.object.ProvisioningPlan;
          String msg = "workflow_identity_saved";
          boolean otherPlans = false;
          List plans = project.getPlans();
          if (plans != null) {
              for (int i = 0 ; i &lt; plans.size() ; i++) {
                  ProvisioningPlan plan = (ProvisioningPlan)plans.get(i);
                  if (!ProvisioningPlan.APP_IIQ.equals(plan.getTargetIntegration())) {
                     otherPlans = true;
                     break;
                  }
              }
          }

          if (project.getUnmanagedPlan() != null &amp;&amp; isTrue(doManualActions)) {
              if (otherPlans)
                  msg = "workflow_identity_provisioning_manual";
              else
                  msg = "workflow_identity_manual";
          }
          else if (otherPlans) {
              // jsl - if there are errors it looks odd to show
              // a "succesfully requesting provisioning" message
              // followed by the error message, just leave this out,
              // we can say something about manual provisioning but if
              // simply committed the change we dont' need anything more
              // msg = "workflow_identity_provisioning";
          }
          return msg;
        </Source>
      </Script>
    </Arg>
    <Arg name="arg1" value="ref:summaryName"/>
    <Description>
      Leave a launch message that can be displayed in the browser before
      we start provisioning which may be asynchronous.  Note that this
      uses the same message catalog keys as the identity update workflows
      which is okay because they don't mention the type of object being
      processed.  If that changes we'll need our own set of keys.
    </Description>
    <Transition to="Provision"/>
  </Step>
  <Step action="call:provisionGroupProject" icon="Provision" name="Provision" posX="732" posY="15">
    <Arg name="background" value="!ref:foregroundProvisioning"/>
    <Arg name="project" value="ref:project"/>
    <Description>
      Provision what remains in the project.  Normally we won't
      be here with unanswered provisioning questions.
    </Description>
    <Transition to="Check Provisioning Errors"/>
  </Step>
  <Step name="Check Provisioning Errors" posX="851" posY="15">
    <Description>
      Placeholder for custom logging or other actions.  
      If there were group provisioning errors, provisionGroupProject
      will have left them in the WorkflowCase.messages list.
    </Description>
    <Script>
      <Source>
        import sailpoint.tools.Message;
        //System.out.println("Checking provisioning errors...");
        List errors = wfcontext.getWorkflowCase().getErrors();
        if (errors != null) {
            for (Message error : errors) {
                //System.out.println("*** " + error.toString());
            }
        }
      </Source>
    </Script>
    <Transition to="Aggregate Specific Targets" when="(pamContainersToAggregate != null) &amp;&amp; (!pamContainersToAggregate.isEmpty())"/>
    <Transition to="Aggregate Specific Group" when="(pamContainerToGroupAggregate != null)"/>
    <Transition to="end"/>
  </Step>
  <Step action="call:aggregateSpecificTargets" icon="Provision" name="Aggregate Specific Targets" posX="732" posY="15">
    <Arg name="pamContainersToAggregate" value="ref:pamContainersToAggregate"/>
    <Arg name="applicationName" value="ref:applicationName"/>
    <Description>
      Provision what remains in the project.  Normally we won't
      be here with unanswered provisioning questions.
    </Description>
    <Transition to="end"/>
  </Step>
  <Step action="call:aggregateSpecificGroup" icon="Provision" name="Aggregate Specific Group" posX="732" posY="15">
    <Arg name="pamContainerToGroupAggregate" value="ref:pamContainerToGroupAggregate"/>
    <Arg name="applicationName" value="ref:applicationName"/>
    <Description>
      Run a group aggregation on the specified resource object.
    </Description>
    <Transition to="end"/>
  </Step>
  <Step icon="Stop" name="end" posX="977" posY="14"/>
</Workflow>
<Workflow libraries="Identity" name="Password Intercept" type="PasswordIntercept">
  <Variable editable="true" initializer="true" name="syncAll">
    <Description>
      Set to true to enable full synchronization over all
      accounts.
    </Description>
  </Variable>
  <Variable editable="true" name="targetApplications">
    <Description>
      Set to a csv or List(String) of Application names that will be synchronized.
    </Description>
  </Variable>
  <Variable input="true" name="identityName" required="true">
    <Description>
      Name of the Identity whose password has changed.
    </Description>
  </Variable>
  <Variable input="true" name="applicationName" required="true">
    <Description>
      Name of the Application where the password change was detected.
    </Description>
  </Variable>
  <Variable input="true" name="nativeIdentity" required="true">
    <Description>
      Name of the account on the Application where the password change was detected.
    </Description>
  </Variable>
  <Variable input="true" name="password" required="true">
    <Description>
      The new password, encrypted.
    </Description>
  </Variable>
  <Variable name="project">
    <Description>
      A ProvisionignProject compiled from the target list.
    </Description>
  </Variable>
  <Step icon="Start" name="start" posX="28" posY="15">
    <Transition to="Select Targets"/>
  </Step>
  <Step name="Select Targets" posX="127" posY="15">
    <Script>
      <Source>
        // Placeholder for custom application selection.
        // The result must be left on the targetApplications list
        // as either a csv or List(String) of Application names.
      </Source>
    </Script>
    <Transition to="Compile Project"/>
  </Step>
  <Step action="call:compilePasswordInterceptProject" name="Compile Project" posX="239" posY="15" resultVariable="project">
    <Arg name="password" value="ref:password"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="sourceApplication" value="ref:applicationName"/>
    <Arg name="targetApplications" value="ref:targetApplications"/>
    <Arg name="syncAll" value="ref:syncAll"/>
    <Description>
      Perform the default password synchronization using the
      supplied application list. 
    </Description>
    <Transition to="Empty Project" when="project == null"/>
    <Transition to="Examine Project"/>
  </Step>
  <Step name="Examine Project" posX="305" posY="150">
    <Description>
      This is a placeholder for custom code that may want to alter
      the project before execution.
    </Description>
    <Script>
      <Source>
        //System.out.println("Password intercept project:");
        //System.out.println(project.toXml());
      </Source>
    </Script>
    <Transition to="Provision"/>
  </Step>
  <Step icon="Task" name="Provision" posX="418" posY="150">
    <Arg name="project" value="ref:project"/>
    <Arg name="foregroundProvisioning" value="true"/>
    <Arg name="disableIdentityRequests" value="true"/>
    <Arg name="trace" value="ref:trace"/>
    <Description>
      Execute the password synchronization project.
      We call the standard subprocess that handles retries.
      Note that the disableIdentityRequests option is passed
      to prevent logging a warning since this workflow does
      not maintain IdentityRequest objects.
    </Description>
    <Return name="project" to="project"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Provision with retries"/>
    </WorkflowRef>
    <Transition to="Audit"/>
  </Step>
  <Step name="Audit" posX="535" posY="150">
    <Description>
      Placeholder, what kind of auditing should we do?
      We've got low level ProvisioningResults in the project.
    </Description>
    <Transition to="end"/>
  </Step>
  <Step name="Empty Project" posX="418" posY="11">
    <Description>
      Here if there wasn't enough to build a project.  If there
      were missing inputs there should be errors in the log.  We could
      just be here because there were no sync targets.
    </Description>
    <Script>
      <Source>
        //System.out.println("Empty synchronization project");
      </Source>
    </Script>
    <Transition to="end"/>
  </Step>
  <Step icon="Stop" name="end" posX="535" posY="11"/>
</Workflow>
<Workflow explicitTransitions="true" name="Alert - Disable Account" type="Alert">
  <Variable input="true" name="alertDefinition" required="true">
    <Description>The alertDefinition object that matched the alert.</Description>
  </Variable>
  <Variable input="true" name="alertId" required="true">
    <Description>The id of the Alert that triggered the workflow.</Description>
  </Variable>
  <Variable name="plan" output="true">
    <Description>ProvisioningPlan generated for the Alert.</Description>
  </Variable>
  <Variable name="project" output="true">
    <Description>The compiled project from the plan</Description>
  </Variable>
  <Variable initializer="Disable" name="op">
    <Description>Operation to take.</Description>
  </Variable>
  <Description>Disable accounts when alert is triggered.

    If the alert's targetType is Identity, this will set the Identity inactive.

    If the alert's targetType is Link, this will disable the account associated to the link.</Description>
  <Step icon="Start" name="Start" posX="28" posY="10">
    <Transition to="Build Provisioning Plan"/>
  </Step>
  <Step action="buildAlertPlan" icon="Task" name="Build Provisioning Plan" posX="98" posY="10" resultVariable="plan">
    <Arg name="op" value="ref:op"/>
    <Arg name="alertId" value="ref:alertId"/>
    <Description>Build the Provisioning plan to disable the correct account</Description>
    <Transition to="Compile Plan"/>
  </Step>
  <Step action="compileProvisioningProject" icon="Task" name="Compile Plan" posX="312" posY="10" resultVariable="project">
    <Arg name="plan" value="ref:plan"/>
    <Transition to="Provision"/>
  </Step>
  <Step action="provisionProject" icon="Provision" name="Provision" posX="438" posY="10">
    <Arg name="project" value="ref:project"/>
    <Transition to="Stop"/>
  </Step>
  <Step icon="Stop" name="Stop" posX="540" posY="10"/>
</Workflow>
<Workflow handler="sailpoint.api.StandardWorkflowHandler" name="Identity Correlation" type="IdentityCorrelation">
  <Variable input="true" name="identityName">
    <Description>The name of the identity we're supposed to update.</Description>
  </Variable>
  <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
    <Description>
      The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.
    </Description>
  </Variable>
  <Variable input="true" name="plan">
    <Description>The provisioning plan ready to execute.</Description>
  </Variable>
  <Variable input="true" name="flow">
    <Description>
      The name of the LCM flow that launched this workflow.

      This is one of these two values:

      IdentityCreateRequest
      IdentityEditRequest
    </Description>
  </Variable>
  <Variable editable="true" name="optimisticProvisioning">
    <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be 
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
  </Variable>
  <Variable editable="true" initializer="true" name="foregroundProvisioning">
    <Description>
      Normally provisioning is done in a step that uses the "backgroud"
      option to force the workfow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintanance task to 
      see the resutls of the request.
    </Description>
  </Variable>
  <Variable initializer="user,requester" input="true" name="notificationScheme">
    <Description>
     A string that specifies who should be notified when the request has been complete.
     The value can be null or a csv of one or more of the following options. 

     none or null
       disable notifications

     user 
       Identity that is being update will be notified.

     manager
       The manager of the Identity that is being updated will be notified.

     requester
       The person that has requested the update will be notified.
    </Description>
  </Variable>
  <Variable initializer="serial" input="true" name="approvalMode">
    <Description>
     A string that specifies how we should handle the approvals.  

     By default this is serial since most of these request with
     the exception of manager transfers will have only one approver.

     parallel
       Approvals are processed concurrently and there must be consensus,
       we wait for all approvers to approve.  The first approver that
       rejects terminates the entire approval.
 
     parallelPoll 
       Approvals are processed concurrently but consensus is not required.
       All approvals will be processed, we don't stop if there are any
       rejections.  

     serial
       Approvals are processed one at a time and there must be consensus.
       The first approver that rejects terminates the entire approval.

     serialPoll
       Approvals are processed in order but consensus is not required.
       All approvals will be processed, we don't stop if there are any
       rejections.  In effect we are "taking a poll" of the approvers.

     any
      Approvals are processed concurrently, the first approver to 
      respond makes the decision for the group.
    </Description>
  </Variable>
  <Variable initializer="manager, newManager" input="true" name="approvalScheme">
    <Description>
      A String that specifies how approvals should be generated for 
      this workflow there are five built-in modes

      none - disabled approvals

      manager - The user's current manager will get approvals

      newManager - The newly assigned manager will get approvals when 
                   manager transfers occur. Otherwise the user's manager 
                   current manager will be the approver.
    </Description>
  </Variable>
  <Variable initializer="spadmin" input="true" name="fallbackApprover">
    <Description>
      A String that specifies the name of the Identity that will 
      be assigned any approvals where the owner of the approver 
      can't be resolved. Example if the scheme is "owner" and the 
      application doesn't specify and owner.
    </Description>
  </Variable>
  <Variable initializer="continue" input="true" name="policyScheme">
    <Description>
      A String that specifies how policy checks effect the overall
      process.

      none - disabled policy checking

      fail -  fail and exit the workflow if any policy violations are found

      continue -  continue if policy violations are found
    </Description>
  </Variable>
  <Variable input="true" name="policiesToCheck">
    <Description>
      A List of policies that should be checked. If this list is
      empty all violations will be checked. Used in combination
      with policyScheme.
    </Description>
  </Variable>
  <Variable name="approvalSet">
    <Description>
       This attributes is set during the "Build Approval Set" step,
       which builds this list by going through the ProvisioningPlan
       to build the line items that need to be approved,

       This variable includes all ApprovalItems that are part of 
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions 
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
  </Variable>
  <Variable initializer="false" name="trace">
    <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
  </Variable>
  <Variable name="project">
    <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan.
    </Description>
  </Variable>
  <Variable name="policyViolations">
    <Description> 
       List of policy violations that were found during our initial policy scan.
       This list is passed into each work item so the approvers can see 
       pending violations.
    </Description>
  </Variable>
  <Variable name="approvalForm">
    <Description>
       The form that is generated based on the changes that were made.  This
       form will be sent into the workitem and allow editing of the 
       requested values during the approval process. This is generated
       in "Build Approval Form" based on the passed-in plan.
    </Description>
  </Variable>
  <Variable initializer="IdentityCorrelation" name="interface">
    <Description>
      This variable shows up in Audit logs.
    </Description>
  </Variable>
  <RuleLibraries>
    <Reference class="sailpoint.object.Rule" name="Approval Library"/>
    <Reference class="sailpoint.object.Rule" name="LCM Workflow Library"/>
  </RuleLibraries>
  <Step icon="Start" name="start" posX="2" posY="19">
    <Transition to="Build Approval Set"/>
  </Step>
  <Step action="call:buildApprovalSet" icon="Task" name="Build Approval Set" posX="60" posY="92" resultVariable="approvalSet">
    <Description>
       The rule will go through the plan and build an approvalItem for each AccountRequest, 
       typically there is just one for the IIQ application requests.

       The rule will also annotate the plan with the previousValues so that they 
       can be assimilated onto the Form that is build, which is used during the approval 
       process for edits.
    </Description>
    <Transition to="Audit Start"/>
  </Step>
  <Step action="auditLCMStart" icon="Audit" name="Audit Start" posX="60" posY="185">
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Transition to="Build Approval Form"/>
  </Step>
  <Step action="call:buildPlanApprovalForm" icon="Task" name="Build Approval Form" posX="60" posY="287" resultVariable="approvalForm">
    <Arg name="plan" value="ref:plan"/>
    <Arg name="template" value="LCM Identity Approval"/>
    <Transition to="Customize Approval Form"/>
  </Step>
  <Step name="Customize Approval Form" posX="60" posY="381" resultVariable="approvalForm">
    <Description>
       using the form that was generaed, mMrk the password field read only so approvers 
       can't change it.  Also associate a Rule with the name so name changes during 
       approvals can be validate.
    </Description>
    <Script>
      <Source>
        import sailpoint.object.Field;
        import sailpoint.object.Form;
        import sailpoint.object.Rule;

        if ( approvalForm != null ) {
            Field passwordField = approvalForm.getField("IIQ:password");
            if ( passwordField != null ) {
                passwordField.setReadOnly(true);
            }
            Field userId = approvalForm.getField("IIQ:name");
            if ( userId != null ) {
                String ruleName = "LCM Validate Identity Name";
                Rule rule = wfcontext.getSailPointContext().getObject(Rule.class, ruleName);
                if ( rule != null ) {
                    userId.setValidationRule(rule);
                }
            }
            Field manager = approvalForm.getField("IIQ:manager");
            if ( manager != null ) {
                // tell the FormBean to output the value as a name
                // instead of ID which is the default
                manager.addAttribute(Field.ATTR_VALUE_PROPERTY, "name");
            }
        }
        return approvalForm;
      </Source>
    </Script>
    <Transition to="Check Policies"/>
  </Step>
  <Step action="checkPolicyViolations" condition="script: !policyScheme.equals(&quot;none&quot;)" icon="Task" name="Check Policies" posX="180" posY="381" resultVariable="policyViolations">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="policies" value="ref:policiesToCheck"/>
    <Transition to="Exit On Policy Violation" when="script:((Util.size(policyViolations) &gt; 0 ) &amp;&amp; (policyScheme.equals(&quot;fail&quot;)))"/>
    <Transition to="Approval"/>
  </Step>
  <Step condition="script:!approvalScheme.equals(&quot;none&quot;)" icon="Approval" name="Approval" posX="238" posY="288">
    <Approval mode="ref:approvalMode" owner="rule:LCM Build Identity Approvers" renderer="lcmEditableWorkItemRenderer.xhtml" send="identityDisplayName,identityName,policyViolations,approvalSet">
      <AfterScript>
        <Source>
          import sailpoint.object.ApprovalSet;
          import sailpoint.object.WorkItem;
          import sailpoint.object.Workflow.WorkflowCase;
          import sailpoint.object.WorkflowCase;
          import sailpoint.object.Form;
          import sailpoint.util.GeneralException;

          if (item == null) {
              return;
          }
          // Assimilate all of the approvalItem changes into our gloval
          // approval set
          // 
          ApprovalSet set = (ApprovalSet)item.get("approvalSet");
          if ( set != null ) {
              // Global completion comments will apply to each of the items
              // If there are completion comments append them
              // to any other completion comments, but typically its 
              // one or the other
              String completionComments = item.getCompletionComments();
              Identity id = item.getOwner();
              String ownerName = null;
              if ( id != null ) {
                  ownerName = id.getName();
              }
              approvalSet.assimilate(set, ownerName, completionComments, true);
          } else {
              throw new GeneralException("ApprovalSet not found in afterscript.");
          }
 
          // djs: this is kind of a hack, do I have alternatives?
          // come back to this
          Form form = (Form)item.get("workItemForm");
          if ( form != null ) {
              WorkflowCase c = wfcontext.getWorkflowCase();
              if ( c != null ) {
                  c.put("approvalForm", form);
              }
          }

          //
          // If they are all rejected mark the Approval Rejected.
          // This allows the Transition to execute once we
          // get a rejection.
          //
          if ( approvalSet.isAllRejected() ) {
              approval.setState(WorkItem.State.Rejected);          
          }

          auditWorkItemOwnerHistory(item);
          auditWorkItemComments(item);
        </Source>
      </AfterScript>
      <Arg name="workItemRequester" value="$(launcher)"/>
      <Arg name="workItemDescription" value="Account Changes for User: $(identityDisplayName)"/>
      <Arg name="workItemForm" value="ref:approvalForm"/>
      <WorkItemConfig escalationStyle="none">
        <NotificationEmailTemplateRef>
          <Reference class="sailpoint.object.EmailTemplate" name="LCM Identity Update Approval"/>
        </NotificationEmailTemplateRef>
      </WorkItemConfig>
    </Approval>
    <Transition to="Start Provisioning Process"/>
  </Step>
  <Step action="call:addMessage" condition="script:!approvalSet.isAllRejected()" icon="Message" name="Start Provisioning Process" posX="238" posY="191">
    <Arg name="message" value="Modifications to $(identityDisplayName) are being provisioned."/>
    <Transition to="Assimilate Form Changes"/>
  </Step>
  <Step action="assimilatePlanApprovalForm" icon="Task" name="Assimilate Form Changes" posX="238" posY="107" resultVariable="plan">
    <Arg name="form" value="ref:approvalForm"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="plan" value="ref:plan"/>
    <Description>
      This step takes the form from the workitem and applys any edits that were
      made back into the plan.
    </Description>
    <Transition to="Process Approval Decisions"/>
  </Step>
  <Step action="call:processPlanApprovalDecisions" icon="Task" name="Process Approval Decisions" posX="238" posY="14" resultVariable="plan">
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="plan" value="ref:plan"/>
    <Description>
    </Description>
    <Transition to="Notify" when="script:approvalSet.isAllRejected()"/>
    <Transition to="Compile Project"/>
  </Step>
  <Step action="compileProvisioningProject" icon="Task" name="Compile Project" posX="391" posY="11" resultVariable="project">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="requester" value="ref:launcher"/>
    <Arg name="source" value="LCM"/>
    <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
    <Description>
      Compile the provisioning plan into a provisioning project.
      If you need to pass in provisioner options like "noFiltering"
      or "noRoleDeprovisioning" you must pass them as explicit
      arguments to the call.

      The evaluation options "requester" and "source" are commonly
      set here.

      You can also pass things into the Template and Field scripts by
      defining Args in this step.
    </Description>
    <Transition to="Provision"/>
  </Step>
  <Step action="call:provisionProject" icon="Provision" name="Provision" posX="502" posY="11">
    <Arg name="project" value="ref:project"/>
    <Arg name="background" value="!ref:foregroundProvisioning"/>
    <Description>Provision what remains in the project.  Normally we won't
      be here with unanswered provisioning questions, but if we have them
      the provisioner will just skip creating those accounts and do what it can.</Description>
    <Transition to="Post Provision"/>
  </Step>
  <Step action="script:approvalSet.setAllProvisioned();" icon="Task" name="Post Provision" posX="605" posY="11">
    <Description>
      Mark all of the items in the approvalset provisioned since these
      are all synchronous activities.
    </Description>
    <Transition to="Audit Completion"/>
  </Step>
  <Step action="call:auditLCMCompletion" icon="Audit" name="Audit Completion" posX="715" posY="11">
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Transition to="Notify"/>
  </Step>
  <Step icon="Email" name="Notify" posX="362" posY="163">
    <Transition to="Notify User"/>
  </Step>
  <Step action="call:sendEmail" condition="script:Util.csvToList(notificationScheme).contains(&quot;user&quot;)" icon="Email" name="Notify User" posX="576" posY="163">
    <Arg name="template" value="LCM User Notification"/>
    <Arg name="to" value="script:getEmail(identityName)"/>
    <Transition to="Notify Requester"/>
  </Step>
  <Step action="call:sendEmail" condition="script:Util.csvToList(notificationScheme).contains(&quot;requester&quot;)" icon="Email" name="Notify Requester" posX="691" posY="163">
    <Arg name="template" value="LCM Requester Notification"/>
    <Arg name="to" value="script:getEmail(launcher)"/>
    <Transition to="Notify Manager"/>
  </Step>
  <Step action="call:sendEmail" condition="script:Util.csvToList(notificationScheme).contains(&quot;manager&quot;)" icon="Email" name="Notify Manager" posX="812" posY="163">
    <Arg name="template" value="LCM Manager Notification"/>
    <Arg name="to" value="script:getManagersEmail(identityName)"/>
    <Transition to="end"/>
  </Step>
  <Step action="call:addMessage" name="Exit On Policy Violation" posX="919" posY="378">
    <Arg name="message" value="Failed due to policy violation(s)"/>
    <Arg name="type" value="Error"/>
    <Transition to="end"/>
  </Step>
  <Step icon="Catches" name="Check Plan and Update Cart" posX="919" posY="17" resultVariable="plan">
    <Description>
      This step takes looks for name changes during creates and updates
      the stub identity on the plan accordingly.
    </Description>
    <Script>
      <Source>
        import sailpoint.object.ApprovalSet;
        import sailpoint.object.ApprovalItem;
        import sailpoint.object.Identity;
        import sailpoint.object.ProvisioningPlan;
        import sailpoint.object.ProvisioningPlan.AccountRequest;
        import sailpoint.object.ProvisioningPlan.AttributeRequest;

        AccountRequest iiq = plan.getAccountRequest(ProvisioningPlan.APP_IIQ);
        if ( iiq != null ) {
            // Look for the name attribute
            boolean nameChanged = false;
            String idName = identityName;
            AttributeRequest name = iiq.getAttributeRequest("name");
            if ( name != null ) {
                String nameStr = Util.otoa(name.getValue());
                if ( nameStr != null ) {
                    // If they don't match this indicates a form
                    // update changes the accountId
                    if ( identityName.compareTo(nameStr) != 0 ) {
                        idName = nameStr; 
                        nameChanged = true;
                    }
                }
            }
            Identity planIdentity = plan.getIdentity();
            if ( ( planIdentity == null ) || ( nameChanged ) ) {
                SailPointContext ctx = wfcontext.getSailPointContext();
                Identity stub = ctx.getObject(Identity.class, idName);
                if ( stub == null ) {
                    stub = new Identity();
                    stub.setName(idName);
                }
                plan.setIdentity(stub);
            }

            //
            // Update the approval item with any changes that 
            // were made during the approval process
            // 
            if ( approvalSet != null ) {
                List approvalItems =  approvalSet.getItems();
                // in the default case there is always just one item for all the changes
                if ( Util.size(approvalItems) == 1 ) { 
                    // Re-flatten the attribute values so they are accurate when auditing changes
                    // and notifying. The values may have been updated in the approvalForm.
                    ApprovalItem item = approvalItems.get(0);
                    List attrRequestFlat = flattenAttributeRequests(iiq.getAttributeRequests());
                    if ( attrRequestFlat != null ) {
                        item.setValue(attrRequestFlat);
                    }
                    if ( nameChanged ) {
                        item.setNativeIdentity(idName);
                    }
                }
            }
        }
        return plan;
      </Source>
    </Script>
    <Transition to="end"/>
  </Step>
  <Step icon="Stop" name="end" posX="919" posY="163"/>
</Workflow>
<Workflow name="Generic Step Library" template="true" type="StepLibrary">
  <Step icon="Default" name="Generic Step"/>
  <Step icon="Start" name="Start"/>
  <Step icon="Stop" name="Stop"/>
</Workflow>
<Workflow explicitTransitions="true" libraries="Identity" name="Provisioning Approval Subprocess" type="Subprocess">
  <Variable initializer="serial" input="true" name="approvalMode">
    <Description>
        A string that specifies how we should handle the approvals.

        By default this is serial since most of these request with
        the exception of manager transfers will have only one approver.

        parallel
        Approvals are processed concurrently and there must be consensus,
        we wait for all approvers to approve.  The first approver that
        rejects terminates the entire approval.

        parallelPoll
        Approvals are processed concurrently but consensus is not required.
        All approvals will be processed, we don't stop if there are any
        rejections.

        serial
        Approvals are processed one at a time and there must be consensus.
        The first approver that rejects terminates the entire approval.

        serialPoll
        Approvals are processed in order but consensus is not required.
        All approvals will be processed, we don't stop if there are any
        rejections.  In effect we are "taking a poll" of the approvers.

        any
        Approvals are processed concurrently, the first approver to
        respond makes the decision for the group.
    </Description>
  </Variable>
  <Variable input="true" name="approvalScheme">
    <Description>
      A csv string that specifies how approval items should be generated 
      for the incoming request.

      The value can be "none", in which case approvals are disabled.

      The value can also be a combination of any of the values below 
      in any order, separated by commas. The order in which they are 
      specified is the order in which they are processed:

      owner
        The object owner gets the approval item. 
        For Role approvals this is the Role object owner. 
        For Entitlement approvals this is the Entitlement object owner.

      manager
        The manager gets the approval item.

      securityOfficer
        The identity in the variable securityOfficerName gets the approval item.

      identity
        The identities/workgroups in the variable approvingIdentities get the approval item.

    </Description>
  </Variable>
  <Variable input="true" name="approvingIdentities">
    <Description>
       List of identities and/or workgroups names/ids that should be involved in the approval 
       process.    
    </Description>
  </Variable>
  <Variable initializer="spadmin" input="true" name="fallbackApprover">
    <Description>
      A String that specifies the name of the Identity that will 
      be assigned any approvals where the owner of the approver 
      can't be resolved. Example if the scheme is "owner" and the 
      application doesn't specify and owner.
    </Description>
  </Variable>
  <Variable input="true" name="flow">
    <Description>
      The name of the LCM flow that launched this workflow.

      This is one of these values:

      AccountsRequest
      EntitlementsRequest
      RolesRequest
      IdentityCreateRequest
      IdentityEditRequest
      ForgotPassword
      ExpiredPassword
      PasswordRequest
      joiner
      mover
      leaver
      AttributeSync

    </Description>
  </Variable>
  <Variable input="true" name="identityName">
    <Description>The name of the identity being updated.</Description>
  </Variable>
  <Variable input="true" name="identityDisplayName">
    <Description>
      The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.      
    </Description>
  </Variable>
  <Variable input="true" name="identityRequestId">
    <Description>
       The ID of the IdentityRequest for this request.
    </Description>
  </Variable>
  <Variable input="true" name="noTriggers">
    <Description>
      If true, then do no attempt to trigger lifecycle events.
    </Description>
  </Variable>
  <Variable input="true" name="policyViolations">
    <Description>
       List of policy violations that were found during our initial policy scan.
       This list is passed into each work item so the approvers can see
       pending violations.
    </Description>
  </Variable>
  <Variable input="true" name="managerElectronicSignature">
    <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by a manager.
    </Description>
  </Variable>
  <Variable input="true" name="ownerElectronicSignature">
    <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by object owners.
    </Description>
  </Variable>
  <Variable input="true" name="securityOfficerElectronicSignature">
    <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by the security officer.
    </Description>
  </Variable>
  <Variable input="true" name="identityElectronicSignature">
    <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by object owners.
    </Description>
  </Variable>
  <Variable initializer="LCM Identity Update Approval" input="true" name="managerEmailTemplate">
    <Description>
       Name of the email template to use when manager of pending approvals.
    </Description>
  </Variable>
  <Variable initializer="LCM Identity Update Approval" input="true" name="ownerEmailTemplate">
    <Description>
       Name of the email template to use when notifying the owner of pending approvals.
    </Description>
  </Variable>
  <Variable initializer="LCM Identity Update Approval" input="true" name="securityOfficerEmailTemplate">
    <Description>
       Name of the email template to use when notifying the security officer of pending approvals.
    </Description>
  </Variable>
  <Variable initializer="LCM Identity Update Approval" input="true" name="identityEmailTemplate">
    <Description>
       Name of the email template to use when notifying the security officer of pending approvals.
    </Description>
  </Variable>
  <Variable initializer="false" name="trace">
    <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
  </Variable>
  <Variable input="true" name="workItemDescription">
    <Description>String "template" that will be used as the workitem description.</Description>
  </Variable>
  <Variable input="true" name="workItemEscalationTemplate">
    <Description>The email template that should be used when sending out reminders.</Description>
  </Variable>
  <Variable input="true" name="workItemHoursBetweenReminders">
    <Description>The number of hours to wait between sending reminders to approvers.</Description>
  </Variable>
  <Variable input="true" name="workItemHoursTillEscalation">
    <Description>The number of hourse to wait until an approval should be escalated.</Description>
  </Variable>
  <Variable initializer="Normal" input="true" name="workItemPriority">
    <Description>
       The String version of a WorkItem.Priority. This variable is
       used to set the priority on all of the workitems generated
       as part of this workflow and also set on the IdentityRequest
       object.
    </Description>
  </Variable>
  <Variable input="true" name="workItemReminderTemplate">
    <Description>The email template that should be used when sending out reminders.</Description>
  </Variable>
  <Variable input="true" name="workItemEscalationRule">
    <Description>The rule used to assign a new ownder during escalation.</Description>
  </Variable>
  <Variable input="true" name="workItemMaxReminders">
    <Description>The maximum number of reminder emails that will be sent before we begin the escalation process.</Description>
  </Variable>
  <Variable initializer="true" input="true" name="filterRejects">
    <Description>True to filter rejected items when running in Serial/SerialPoll mode.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="setPreviousApprovalDecisions">
    <Description>True to pre-populate approval decisions from previous approvals.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="clearApprovalDecisions">
    <Description>True to clear all decisions when generating approvals</Description>
  </Variable>
  <Variable initializer="true" input="true" name="dontUpdatePlan">
    <Description>True to skip updating the ProvisioningProject masterPlan when processing approval decisions.</Description>
  </Variable>
  <Variable input="true" name="approvalSet" output="true">
    <Description>
      ApprovalSet representing the things that were requested and come from
      the master provisioning plan. 
    </Description>
  </Variable>
  <Variable input="true" name="project" output="true">
    <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan, the 
      master plan will be adjusted when approval decisions are applied and a new 
      revised provisiobion project will be returned.
    </Description>
  </Variable>
  <Variable input="true" name="plan" output="true">
    <Description>The provisioning plan.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="requireCommentsForApproval">
    <Description>When true we will require comments when an approval item is approved.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="requireCommentsForDenial">
    <Description>When true we will require comments when an approval item is denied.</Description>
  </Variable>
  <Description>
    Simple approval subrocess introduced into release 6.2 to make
    adding custom approvals easier.  This approval subprocess
    has a configuration form to make it easier to configure
    from the Business Process Editor.
  </Description>
  <RuleLibraries>
    <Reference class="sailpoint.object.Rule" name="LCM Workflow Library"/>
  </RuleLibraries>
  <Step icon="Start" name="Start" posX="20" posY="22">
    <Transition to="Approval"/>
  </Step>
  <Step icon="Approval" name="Approval" posX="158" posY="22">
    <Approval mode="ref:approvalMode" owner="call:buildCommonApprovals" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName,approvalSet,flow,policyViolations,identityRequestId">
      <AfterScript>
        <Source>
          import sailpoint.workflow.IdentityRequestLibrary;
                    
          if ( item == null ) 
              return;

          assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);          
          auditDecisions(item);  
          IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, approvalSet);
        </Source>
      </AfterScript>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="workItemDescription" value="ref:workItemDescription"/>
      <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
      <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
      <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
      <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
      <Arg name="workItemEscalationFrequency" value="ref:workItemEscalationFrequency"/>
      <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
      <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
      <Arg name="workItemNotificationTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="approvalMode" value="ref:approvalMode"/>
      <Arg name="approvalScheme" value="ref:approvalScheme"/>
      <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
      <Arg name="clearApprovalDecisions" value="ref:clearApprovalDecisions"/>
      <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
      <Arg name="workItemRequester" value="$(launcher)"/>
      <InterceptorScript>
        <Source>
            
            import sailpoint.object.Workflow.Approval;
            import sailpoint.object.ApprovalItem;
            import sailpoint.object.ApprovalSet;
            import sailpoint.object.Workflow;
            import sailpoint.object.WorkItem;
            import sailpoint.tools.Util;
            import java.util.Iterator;
            import java.util.ArrayList;
            import java.lang.Boolean;

            if (Workflow.INTERCEPTOR_PRE_ASSIMILATION.equals(method)) {
                // promote completion state to Rejected if all items are rejected
                ApprovalSet aset = item.getApprovalSet();
                if (aset != null) {
                    List items = aset.getItems();
                    if (items != null) {
                        int rejectCount = 0;
                        for (ApprovalItem item : items) {
                            // note that isRejected can't be used since that
                            // assumes no answer means rejected
                            if (item.getState() == WorkItem.State.Rejected) {
                                rejectCount++;
                            }
                        }
                        if (rejectCount == items.size()) {
                            item.setState(WorkItem.State.Rejected);
                        }
                    }
                }
            } else if (Workflow.INTERCEPTOR_START_APPROVAL.equals(method)) {

                ApprovalSet currentSet = approval.getApprovalSet();

                if (currentSet != null &amp;&amp; !Util.isEmpty(currentSet.getItems())) {
                    //If filterRejects is true, filter any rejected items in the master ApprovalSet from the currentSet
                    if (Boolean.valueOf(filterRejects)) {
                        filterRejectsFromApprovalSet(approvalSet, currentSet);
                    }

                    //We've filtered all items from the approval set
                    if (Util.isEmpty(currentSet.getItems())) {
                        //Complete the approval if it contains no ApprovalItems
                        approval.setComplete(true);
                    } else {

                        if (Boolean.valueOf(setPreviousApprovalDecisions)) {
                            // If setPreviousApprovalDecisions is enabled, set the decision
                            // on the items to that of the global item.
                            setPreviousDecisionsOnApprovalSet(approvalSet, currentSet);
                        }
                    }
                }

            } else if (Workflow.INTERCEPTOR_END_APPROVAL.equals(method)) {
                // Owner children approvals need to propagate the rejection state if all children are rejected
                Approval parentApp = approval.getParent();
                // Never relay the state to the root approval
                // If we don't have an approvalSet, must be a container approval
                if (parentApp != null &amp;&amp; approval.getApprovalSet() == null) {
                    boolean completeAndRejected = false;
                    for (Approval child : Util.safeIterable(approval.getChildren())) {
                        if (child.isComplete() &amp;&amp; child.getState() == WorkItem.State.Rejected) {
                            completeAndRejected = true;
                        } else {
                            completeAndRejected = false;
                            break;
                        }
                    }
                    //If all children complete and rejected, set the status on the parent approval
                    if (completeAndRejected) {
                        approval.setState(WorkItem.State.Rejected);
                    }
                }
            } else if (Workflow.INTERCEPTOR_OPEN_WORK_ITEM.equals(method)) {
               import sailpoint.workflow.IdentityRequestLibrary;

               //Sync IdentityRequestItems with the WorkItem
               IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, item.getApprovalSet(), false);
            }
            
        </Source>
      </InterceptorScript>
    </Approval>
    <Transition to="Process Approval Decisions" when="script:(step.getApproval() != null &amp;&amp; step.getApproval().containsApprovalItems())"/>
    <Transition to="end"/>
  </Step>
  <Step action="call:processApprovalDecisions" icon="Task" name="Process Approval Decisions" posX="420" resultVariable="project">
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="disableAudit" value="true"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="recompilePlan" value="true"/>
    <Arg name="dontUpdatePlan" value="ref:dontUpdatePlan"/>
    <Transition to="end"/>
  </Step>
  <Step icon="Stop" name="end" posX="420" posY="225"/>
</Workflow>
<Workflow name="IdentityProvisioningStepLibrary" template="true" type="StepLibrary">
  <Step configForm="Provisioning Approval Step Form" icon="Task" name="Account Approval">
    <Arg name="approvalMode"/>
    <Arg name="approvalScheme"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="approvalAssignmentRule"/>
    <Arg name="approvingIdentities"/>
    <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="identityElectronicSignature"/>
    <Arg name="identityEmailTemplate"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="launcher" value="ref:launcher"/>
    <Arg name="managerEmailTemplate"/>
    <Arg name="managerElectronicSignature"/>
    <Arg name="ownerEmailTemplate"/>
    <Arg name="ownerElectronicSignature"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="policyViolations" value="ref:policyViolations"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="securityOfficerName"/>
    <Arg name="securityOfficerEmailTemplate"/>
    <Arg name="securityOfficerElectronicSignature"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="workItemComments"/>
    <Arg name="workItemReminderTemplate"/>
    <Arg name="workItemHoursBetweenReminders"/>
    <Arg name="workItemMaxReminders"/>
    <Arg name="workItemEscalationTemplate"/>
    <Arg name="workItemHoursTillEscalation"/>
    <Arg name="workItemEscalationRule"/>
    <Description>
        Step library that can be used for provisioning request approvals.
        The process assumes many of the Provisioning Workflow structures exist
        and has things like provisioning plans and approvalSets are required.           
      </Description>
    <Return name="project"/>
    <Return name="approvalSet"/>
    <Return name="workItemComments"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Provisioning Approval Subprocess"/>
    </WorkflowRef>
  </Step>
  <Step action="call:sendMultipleNotifications" configForm="Provisioning Notification Step Form" icon="Email" name="Notify">
    <Arg name="notificationScheme"/>
    <Arg name="userEmail" value="script:getUserEmail(identityName, plan)"/>
    <Arg name="userEmailTemplate"/>
    <Arg name="requesterEmail" value="script:getEmail(launcher)"/>
    <Arg name="requesterEmailTemplate"/>
    <Arg name="managerEmail" value="script:getManagersEmail(identityName, plan)"/>
    <Arg name="managerEmailTemplate"/>
    <Arg name="securityOfficerName"/>
    <Arg name="securityOfficerEmailTemplate"/>
    <Arg name="otherUsersToNotify"/>
    <Arg name="otherUsersToNotifyEmailTemplate"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="launcher" value="ref:launcher"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="source" value="ref:source"/>
    <Description>
      	  Notify the various actors specified on notification scheme.
        </Description>
  </Step>
</Workflow>
<Workflow name="Identity Request Violation Review" type="Subprocess">
  <Variable initializer="false" name="trace">
    <Description>
      The name of the identity object being modified.
    </Description>
  </Variable>
  <Variable input="true" name="identityName" required="true">
    <Description>
      The name of the identity object being modified.
    </Description>
  </Variable>
  <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
    <Description>
      The displayName of the identity being updated.
      This may be passed in, if not the script queries for this
      using a projection query and falls back to the name.
    </Description>
  </Variable>
  <Variable input="true" name="project" required="true">
    <Description>The provisioning plan ready to execute.</Description>
  </Variable>
  <Variable input="true" name="plan" required="true">
    <Description>The provisioning plan ready to execute.</Description>
  </Variable>
  <Variable input="true" name="source"/>
  <Variable input="true" name="optimisticProvisioning" required="true">
    <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
  </Variable>
  <Variable initializer="false" input="true" name="enableRetryRequest">
    <Description>
      When set to true it will disable the workflow retry loop and let the
      Provision step launch requests to handle the retries.  Enabling
      this flag will enable some older functionality.
    </Description>
  </Variable>
  <Variable name="policyViolations">
    <Description>
       List of policy violations that were found during our initial policy scan.
       This list is passed into each work item so the approvers can see
       pending violations.
    </Description>
  </Variable>
  <Variable input="true" name="policiesToCheck">
    <Description>
      A List of policies that should be checked. If this list is
      empty all violations will be checked. Used in combination
      with policyScheme.
    </Description>
  </Variable>
  <Variable input="true" name="policyScheme"/>
  <Variable input="true" name="asyncCacheRefresh">
    <Description>
      Set to true to enable asynchronous refresh of the policy and role
      caches.  This speeds up response time for the LCM user, but you
      may want to disable this during demonstrations after editing
      the role or policy models.  This may also be enabled globally
      in the system configuration.  This variable overrides the system
      configuration if it has a value.
    </Description>
  </Variable>
  <Variable input="true" name="workItemPriority">
    <Description>
      String version of WorkItem.level that will be used
      to set the priority of the IdentityRequest.
    </Description>
  </Variable>
  <Variable name="approvalSet">
    <Description>
       This attribute is passed in and contains the current
       set of approvalItems in the request. When a user chooses
       to remove a problematic approval item from the request, we
       update this value before returning to the calling workflow.
    </Description>
  </Variable>
  <Variable input="true" name="flow">
    <Description>
      The name of the LCM flow that launched this workflow.

      This is one of these values:

      AccountsRequest
      EntitlementsRequest
      RolesRequest
      IdentityCreateRequest
      IdentityEditRequest
      ForgotPassword
      ExpiredPassword
      PasswordRequest
      joiner
      mover
      leaver
      AttributeSync

    </Description>
  </Variable>
  <Variable input="true" name="allowRequestsWithViolations">
    <Description>
      If this variable is set to true, requesters will be able to proceed past
      the Policy Violation Review form without taking any action on
      policy violations resulting from the request.
    </Description>
  </Variable>
  <Variable input="true" name="requireViolationReviewComments">
    <Description>
      If true, requesters will be required to enter in comments if they
      proceed with a request that will result in policy violations.
     </Description>
  </Variable>
  <Variable name="violationReviewDecision">
    <Description>
       Decision made by the user in the Policy Violation Review step.
       This may be one of three choices:

       -ignore:   User is ignoring the violations and letting the request continue. If
                   requireViolationReviewComments=true the user will be required to enter
                   comments indicating why they are allowing the violations.

       -remediate: Indicates that the user removed the request items that were causing the
                   violations

       -cancel:   Indicates that the user decided to abandon the request, terminating the workflow.

    </Description>
  </Variable>
  <Variable name="workItemComments">
    <Description>
      Completion comments added if the user decides to proceed with the
      request without addressing the policy violations. These comments
      will be propagated to all other approvals.
    </Description>
  </Variable>
  <Variable name="originalPlan">
    <Description>
      The original plan calculated for the request.  As request modifications
      are submitted and resubmitted after violation review, we will revert to
      the original plan, so that the new selections can be calculated starting
      from a clean slate. 
    </Description>
  </Variable>
  <Description>
   This sub-process determines if there are any violations which will be
   caused by the request specified in the plan. If the policy scheme is
   'interactive' the user will be presented with a form which details
   the actions they can take to deal with the violations. Otherwise,
   control is returned to the calling process.
  </Description>
  <RuleLibraries>
    <Reference class="sailpoint.object.Rule" name="LCM Workflow Library"/>
  </RuleLibraries>
  <Step icon="Start" name="Start" posX="22" posY="13">
    <Transition to="Save Original Plan"/>
  </Step>
  <Step name="Save Original Plan" posX="118" posY="13">
    <Description>
      When a policyScheme of "interactive" is set, the user has an opportunity
      to resolve the violation by removing requests.  Multiple iterations of
      this form may be submitted.  Each submission must reset the plan so that
      when the plan is compiled anew with the new set of decisions, the
      original master plan is utilized.  This step saves that master plan.
      It is reloaded in the "Reset Original Plan" step.
    </Description>
    <Script>
      <Source>
        import sailpoint.object.ProvisioningPlan;
        
        if (null != project) {
            ProvisioningPlan master = project.getMasterPlan();
            if (null != master) {
                ProvisioningPlan copy = (ProvisioningPlan) master.deepCopy(wfcontext.getSailPointContext());
                workflow.put("originalPlan", copy);
            }
        }
      </Source>
    </Script>
    <Transition to="Check Policies"/>
  </Step>
  <Step action="checkPolicyViolations" icon="Task" name="Check Policies" posX="220" posY="13" resultVariable="policyViolations">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="policies" value="ref:policiesToCheck"/>
    <Arg name="policyScheme" value="ref:policyScheme"/>
    <Arg name="asyncCacheRefresh" value="ref:asyncCacheRefresh"/>
    <Return name="policyViolations" to="policyViolations"/>
    <Transition to="Reset Original Plan" when="script:((!&quot;ignore&quot;.equals(violationReviewDecision) &amp;&amp; !&quot;cancel&quot;.equals(violationReviewDecision) ) &amp;&amp; size(policyViolations) &gt; 0 &amp;&amp; (policyScheme.equals(&quot;interactive&quot;)))"/>
    <Transition to="end"/>
  </Step>
  <Step name="Reset Original Plan" posX="378" posY="9">
    <Description>
      In this step, we need to reload the original plan because previous
      decisions may have modified the plan, so start with the original complete
      plan.  Also see the step "Save Original Plan".
    </Description>
    <Script>
      <Source>
        if (null != originalPlan) {
            plan = (ProvisioningPlan) originalPlan.deepCopy(wfcontext.getSailPointContext());
            workflow.put("plan", plan);
        }
      </Source>
    </Script>
    <Transition to="Violation Review"/>
  </Step>
  <Step icon="Approval" name="Violation Review" posX="446" posY="210">
    <Approval mode="ref:approvalMode" owner="ref:launcher" renderer="lcmViolationReviewRenderer.xhtml" send="identityDisplayName,identityName,policyViolations,approvalSet,violationReviewDecision,requireViolationReviewComments,allowRequestsWithViolations">
      <AfterScript>
        <Source>
          import sailpoint.object.ApprovalSet;
          import sailpoint.object.ApprovalItem;
          import sailpoint.object.WorkItem;
          import sailpoint.object.ProvisioningPlan;
          import sailpoint.object.Comment;


          if (item == null) {
              return;
          }

          workflow.put("violationReviewDecision", item.get("violationReviewDecision"));
          
          // Assimilate all of the approvalItem changes into our global
          // approval set
          ApprovalSet set = (ApprovalSet)item.get("approvalSet");
          if ( set != null ) {
              // Global completion comments will apply to each of the items
              // If there are completion comments append them
              // to any other completion comments, but typically its 
              // one or the other
              String completionComments = item.getCompletionComments();
              Identity id = item.getOwner();
              String ownerName = null;
              if ( id != null ) {
                  ownerName = id.getName();
              }
              approvalSet.assimilate(set, ownerName, completionComments, false);
          } else {
              throw new GeneralException("ApprovalSet not found in afterscript.");
          }
          
          assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);
        </Source>
      </AfterScript>
      <Arg name="workItemRequester" value="$(launcher)"/>
      <Arg name="workItemDescription" value="Policy Violation Review - Account Changes for User: $(identityDisplayName)"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="workItemType" value="ViolationReview"/>
    </Approval>
    <Description>
      Give the user the option of either removing problematic request items, or
      affirm that they are aware of the violations and wish to continue.
    </Description>
    <Transition to="Handle Violation Review Decision"/>
  </Step>
  <Step icon="Task" name="Handle Violation Review Decision" posX="248" posY="210">
    <Description>

    </Description>
    <Transition to="Process Violation Review Decisions"/>
  </Step>
  <Step action="call:processPlanApprovalDecisions" icon="Task" name="Process Violation Review Decisions" posX="60" posY="210" resultVariable="plan">
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="disableAudit" value="true"/>
    <Description>
      Process the decisions made by the user. This will update the plan by removing
      any items that were rejected by the user.
    </Description>
    <Transition to="Compile Project"/>
  </Step>
  <Step action="compileProvisioningProject" icon="Task" name="Compile Project" posX="114" posY="134" resultVariable="project">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="requester" value="ref:launcher"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="disableRetryRequest" value="!ref:enableRetryRequest"/>
    <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
    <Description>Recompile the provisioning plan into a provisioning project, taking into
      consideration any items removed on the violation review form.</Description>
    <Transition to="Save Original Plan"/>
    <Transition to="end" when="script:(&quot;cancel&quot;.equals(violationReviewDecision) || &quot;ignore&quot;.equals(violationReviewDecision))"/>
  </Step>
  <Step icon="Stop" name="end" posX="288" posY="131"/>
</Workflow>
<Workflow libraries="Identity,IdentityRequest" name="Identity Request Initialize" type="Subprocess">
  <Variable input="true" name="identityName" required="true">
    <Description>
      The name of the identity object being modified.
    </Description>
  </Variable>
  <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
    <Description>
      The displayName of the identity being updated.
      This may be passed in, if not the script queries for this
      using a projection query and falls back to the name.
    </Description>
  </Variable>
  <Variable initializer="false" input="true" name="endOnManualWorkItems">
    <Description>Option to skip requests with manual work items.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="endOnProvisioningForms">
    <Description>Option to skip requests with provisioning forms.</Description>
  </Variable>
  <Variable input="true" name="flow">
    <Description>
      The name of the LCM flow that launched this workflow.

      This is one of these values:

      AccountsRequest
      EntitlementsRequest
      RolesRequest
      IdentityCreateRequest
      IdentityEditRequest
      ForgotPassword
      ExpiredPassword
      PasswordRequest
      joiner
      mover
      leaver
      AttributeSync

    </Description>
  </Variable>
  <Variable input="true" name="plan" required="true">
    <Description>The provisioning plan ready to execute.</Description>
  </Variable>
  <Variable input="true" name="optimisticProvisioning" required="true">
    <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
  </Variable>
  <Variable input="true" name="asyncCacheRefresh">
    <Description>
      Set to true to enable asynchronous refresh of the policy and role
      caches.  This speeds up response time for the LCM user, but you
      may want to disable this during demonstrations after editing
      the role or policy models.  This may also be enabled globally
      in the system configuration.  This variable overrides the
      system configuration if it has a value.
    </Description>
  </Variable>
  <Variable input="true" name="policiesToCheck">
    <Description>
      A List of policies that should be checked. If this list is
      empty all violations will be checked. Used in combination
      with policyScheme.
    </Description>
  </Variable>
  <Variable input="true" name="allowRequestsWithViolations">
    <Description>
      If this variable is set to true, requesters will be able to proceed past
      the Policy Violation Review form without taking any action on
      policy violations resulting from the request.
    </Description>
  </Variable>
  <Variable input="true" name="requireViolationReviewComments">
    <Description>
      If true, requesters will be required to enter in comments if they
      proceed with a request that will result in policy violations.
     </Description>
  </Variable>
  <Variable initializer="Identity Update" input="true" name="formTemplate">
    <Description>
      Template used when processing provisioning forms.
    </Description>
  </Variable>
  <Variable initializer="false" name="trace">
    <Description>
      Used for debugging this subprocess and when set to true trace
      statements will be sent to stdout.
    </Description>
  </Variable>
  <Variable initializer="continue" input="true" name="policyScheme">
    <Description>
      A String that specifies how policy checks effect the overall
      process.

      none - disabled policy checking

      interactive -  allow requester to remove request items which are causing violations

      continue -  continue if policy violations are found

      fail -  fail and exit the workflow if any policy violations are found

    </Description>
  </Variable>
  <Variable initializer="LCM" input="true" name="source">
    <Description>
      String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.
    </Description>
  </Variable>
  <Variable input="true" name="workItemPriority">
    <Description>
      String version of WorkItem.level that will be used
      to set the priority any generated workitems. It will
      also configure the priority of the request as
      on the generated Access Request.
    </Description>
  </Variable>
  <Variable initializer="false" input="true" name="enableRetryRequest">
    <Description>
      When set to true it will disable the workflow retry loop and let the
      Provision step launch requests to handle the retries.  Enabling
      this flag will enable some older functionality.
    </Description>
  </Variable>
  <Variable name="project" output="true">
    <Description>
      A ProvisioningProject object describing the modifications to the identity.
      This may include a list of Question objects which will
      cause the generation of a Form and a WorkItem to solicit
      additional information necessary for provisioning.
    </Description>
  </Variable>
  <Variable name="policyViolations" output="true">
    <Description>
       List of policy violations that were found during our initial policy scan.
       This list is passed into each work item so the approvers can see
       pending violations.
    </Description>
  </Variable>
  <Variable name="approvalSet" output="true">
    <Description>
       This attribute is set during the "Build Approval Set" step,
       which builds this list by going through the ProvisioningPlan
       to build the line items that need to be approved.

       This variable includes all ApprovalItems that are part of
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
  </Variable>
  <Variable name="identityRequest">
    <Description>
       The request object we get back from the create call. This is
       primarily useful for debugging.
    </Description>
  </Variable>
  <Variable name="identityRequestId">
    <Description>
        The id of the IdentityRequest created.
    </Description>
  </Variable>
  <Variable name="violationReviewDecision" output="true">
    <Description>
     Decision made by the user in the Policy Violation Review step.
     This may be one of three choices:

     -ignore:   User is ignoring the violations and letting the request continue. If
                 requireViolationReviewComments=true the user will be required to enter
                 comments indicating why they are allowing the violations.

     -remediate: Indicates that the user removed the request items that were causing the
                 violations

     -cancel:   Indicates that the user decided to abandon the request, terminating the workflow.

    </Description>
  </Variable>
  <Variable initializer="script:( Util.otob(getConfiguration(&quot;lcmEnableApprovalRecommendations&quot;)))" input="true" name="enableApprovalRecommendations">
    <Description>
        Flag to determine if recommendations should be gathered for the approvals.
      </Description>
  </Variable>
  <Variable name="workItemComments">
    <Description>
      Global comments accumulated during the workflow which should be shared
      with other approvals. When a new approval is created, the comments in this
      list will be added to the work item.
    </Description>
  </Variable>
  <Description>
      This workflow subprocess is used to initialize the various
      object necessary when executing workflows that deal
      with provisioning.

      This subprocess was added in 5.5 in an effort to
      break groups of related steps into a single call
      from the top level workflow.

      It now encapsulates the following services:

        - Compliation of the plan into a project
        - Build an approval set
           defaults to using buildApprovalSet but allows it to be passed in
        - Audit Start
        - Create the IdentityRequest object for the request tracking
        - Check policies
        - Build required forms for the launcher

  </Description>
  <Step icon="Start" name="Start" posX="25" posY="15">
    <Transition to="Compile Project"/>
  </Step>
  <Step action="call:compileProvisioningProject" icon="Task" name="Compile Project" posX="121" posY="15" resultVariable="project">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="requester" value="ref:launcher"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
    <Arg name="disableRetryRequest" value="!ref:enableRetryRequest"/>
    <Arg name="noApplicationTemplates">
      <Script>
        <Source>
            boolean ignoreForms = false;
            if ("ForgotPassword".equals(flow) || "ExpirePassword".equals(flow)) {
               ignoreForms = true;
            }
            return ignoreForms;
        </Source>
      </Script>
    </Arg>
    <Arg name="noLocking">
      <Script>
        <Source>
            boolean noLocking = false;
            if ("Lifecycle".equals(flow)) {
               noLocking = true;
            }
            return noLocking;
        </Source>
      </Script>
    </Arg>
    <Description>Compile the provisioning plan into a provisioning project.
      If you need to pass in provisioner options like "noFiltering"
      or "noRoleDeprovisioning" you must pass them as explicit
      arguments to the call.

      The evaluation options "requester" and "source" are commonly
      set here.

      You can also pass things into the Template and Field scripts by
      defining Args in this step.</Description>
    <Transition to="end" when="script:(isTrue(endOnManualWorkItems) &amp;&amp; (project.getUnmanagedPlan() != null))"/>
    <Transition to="end" when="script:(isTrue(endOnProvisioningForms) &amp;&amp; (project.hasQuestions()))"/>
    <Transition to="Build Approval Set" when="script:isNull(approvalSet)"/>
    <Transition to="Rebuild Approval Set"/>
  </Step>
  <Step action="call:buildApprovalSet" condition="script:isNull(approvalSet)" name="Build Approval Set" posX="260" posY="92" resultVariable="approvalSet">
    <Arg name="plan" value="ref:plan"/>
    <Return name="approvalSet" to="approvalSet"/>
    <Transition to="Check Policies"/>
  </Step>
  <Step condition="script:(!policyScheme.equals(&quot;none&quot;))" name="Check Policies" posX="391" posY="92">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="policyScheme" value="ref:policyScheme"/>
    <Arg name="policiesToCheck" value="ref:policiesToCheck"/>
    <Arg name="asyncCacheRefresh" value="ref:asyncCacheRefresh"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="requireViolationReviewComments" value="ref:requireViolationReviewComments"/>
    <Arg name="allowRequestsWithViolations" value="ref:allowRequestsWithViolations"/>
    <Return name="policyViolations" to="policyViolations"/>
    <Return name="project" to="project"/>
    <Return name="plan" to="plan"/>
    <Return name="violationReviewDecision" to="violationReviewDecision"/>
    <Return merge="true" name="workItemComments" to="workItemComments"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Identity Request Violation Review"/>
    </WorkflowRef>
    <Transition to="end" when="script:(&quot;cancel&quot;.equals(violationReviewDecision))"/>
    <Transition to="end" when="script:((policyScheme.equals(&quot;fail&quot;) &amp;&amp; (size(policyViolations) &gt; 0 )  ))"/>
    <Transition to="Rebuild Approval Set"/>
  </Step>
  <Step action="call:buildApprovalSet" name="Rebuild Approval Set" posX="187" posY="252" resultVariable="approvalSet">
    <Arg name="plan" value="ref:plan"/>
    <Return name="approvalSet" to="approvalSet"/>
    <Transition to="Build Approval Recommendations"/>
  </Step>
  <Step action="call:populateRecommendationsInApprovalSet" condition="ref:enableApprovalRecommendations" name="Build Approval Recommendations" posX="322" posY="252" resultVariable="approvalSet">
    <Arg name="identitySource" value="ref:plan"/>
    <Return name="approvalSet" to="approvalSet"/>
    <Transition to="Audit Start"/>
  </Step>
  <Step action="call:auditLCMStart" icon="Audit" name="Audit Start" posX="439" posY="252">
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Transition to="Create Identity Request"/>
  </Step>
  <Step action="call:createIdentityRequest" icon="Task" name="Create Identity Request" posX="577" posY="252" resultVariable="identityRequest">
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="source" value="ref:source"/>
    <Transition to="Do Provisioning Forms Pre-Approval"/>
  </Step>
  <Step icon="Task" name="Do Provisioning Forms Pre-Approval" posX="741" posY="252">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="formTemplate" value="ref:formTemplate"/>
    <Arg name="requiredOwner">
      <Script>
        <Source>
            
           if(sessionOwner.equals("System") || sessionOwner.equals("Scheduler") || sessionOwner.equals("RequestHandler"))
           {
            return "spadmin";
           }
           else
           {
           return sessionOwner;
           }
           
          </Source>
      </Script>
    </Arg>
    <Arg name="workItemComments" value="ref:workItemComments"/>
    <Description>
      Call the standard subprocess for assembling, presenting, and assimilating
      provisioning forms that can be filled out before approvals.
    </Description>
    <Return name="approvalSet" to="approvalSet"/>
    <Return name="project" to="project"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Do Provisioning Forms"/>
    </WorkflowRef>
    <Transition to="Assimilate Account Id Changes"/>
  </Step>
  <Step action="call:assimilateAccountIdChanges" icon="Task" name="Assimilate Account Id Changes" posX="740" posY="119" resultVariable="approvalSet">
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Description>
      Assimilate the result of any accountId changes that may have been compiled into the plan back onto the ApprovalSet and IdentityRequest.
    </Description>
    <Transition to="end"/>
  </Step>
  <Step icon="Stop" name="end" posX="740" posY="12"/>
</Workflow>
<Workflow name="Identity Request Approve" type="Subprocess">
  <Variable input="true" name="identityName" required="true">
    <Description>
      The name of the identity object being modified.
    </Description>
  </Variable>
  <Variable input="true" name="batchRequestId">
    <Description>
      Batch request id.
    </Description>
  </Variable>
  <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
    <Description>
      The displayName of the identity being updated.
      This may be passed in, if not the script queries for this
      using a projection query and falls back to the name.
    </Description>
  </Variable>
  <Variable initializer="script:getIdentityProperty(identityName, &quot;id&quot;)" input="true" name="identityId">
    <Description>
      The id of the identity being updated.
    </Description>
  </Variable>
  <Variable input="true" name="identityRequestId">
    <Description>
       The ID of the IdentityRequest for this request.
    </Description>
  </Variable>
  <Variable input="true" name="approvalScheme" required="true">
    <Description>
      A csv string that specifies how approvals should be generated for
      the incoming request.

      The value can be any of the values below, combined together but
      are always processed in this order:

      1. manager
      2. owner
      3. securityOfficer

      Any rejected items from previous approvals will be omitted from the
      next phase of approvers.

      none - disabled approvals

      owner - the object owner gets the approval
              For Role approvals this is the Role object owner. When dealing
              with things like Unlock and other account level changes
              the approvals will be assigned to the the application owner.

      manager - The manager will get all approvals

      securityOfficer - The identity named security the security in the variable
                        securityOfficerName.

    </Description>
  </Variable>
  <Variable initializer="serial" input="true" name="approvalMode">
    <Description>
     A string that specifies how we should handle the approvals.

     By default this is serial since most of these request with
     the exception of manager transfers will have only one approver.

     parallel
       Approvals are processed concurrently and there must be consensus,
       we wait for all approvers to approve.  The first approver that
       rejects terminates the entire approval.

     parallelPoll
       Approvals are processed concurrently but consensus is not required.
       All approvals will be processed, we don't stop if there are any
       rejections.

     serial
       Approvals are processed one at a time and there must be consensus.
       The first approver that rejects terminates the entire approval.

     serialPoll
       Approvals are processed in order but consensus is not required.
       All approvals will be processed, we don't stop if there are any
       rejections.  In effect we are "taking a poll" of the approvers.

     any
      Approvals are processed concurrently, the first approver to
      respond makes the decision for the group.
    </Description>
  </Variable>
  <Variable input="true" name="fallbackApprover" required="true">
    <Description>
      A String that specifies the name of the Identity that will
      be assigned any approvals where the owner of the approver
      can't be resolved. Example if the scheme is "owner" and the
      application doesn't specify and owner.
    </Description>
  </Variable>
  <Variable input="true" name="securityOfficerName">
    <Description>
       The name of the identity that will be sent approvals
       during security officer approvals.
    </Description>
  </Variable>
  <Variable input="true" name="batchRequestApprover">
    <Description>
       Identity responsible for approving batch requests.
    </Description>
  </Variable>
  <Variable initializer="false" input="true" name="includeRejectedItemsInApprovalChain">
    <Description>
       When using multi approvalSchemes a flag to indicate if new
       approvals in the chain will include rejected items.
    </Description>
  </Variable>
  <Variable input="true" name="policyViolations">
    <Description>
       List of policy violations that were found during our initial policy scan.
       This list is passed into each work item so the approvers can see
       pending violations.
    </Description>
  </Variable>
  <Variable input="true" name="flow">
    <Description>
      The name of the LCM flow that launched this workflow.

      This is one of these values:

      AccountsRequest
      EntitlementsRequest
      RolesRequest
      IdentityCreateRequest
      IdentityEditRequest
      ForgotPassword
      ExpiredPassword
      PasswordRequest
      joiner
      mover
      leaver
      AttributeSync

    </Description>
  </Variable>
  <Variable input="true" name="trace">
    <Description>
      Used for debugging this subprocess and when set to true trace
      statements will be sent to stdout.
    </Description>
  </Variable>
  <Variable input="true" name="approvalSet" output="true">
    <Description>
       This attributes is set during the "Build Approval Set" step,
       which builds this list by going through the ProvisioningPlan
       to build the line items that need to be approved,

       This variable includes all ApprovalItems that are part of
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
  </Variable>
  <Variable initializer="LCM Identity Update Approval" input="true" name="managerEmailTemplate">
    <Description>
       Name of the email template to use when manager of pending approvals.
    </Description>
  </Variable>
  <Variable initializer="LCM Identity Update Approval" input="true" name="ownerEmailTemplate">
    <Description>
       Name of the email template to use when notifying the owner of pending approvals.
    </Description>
  </Variable>
  <Variable initializer="LCM Identity Update Approval" input="true" name="securityOfficerEmailTemplate">
    <Description>
       Name of the email template to use when notifying the security officer of pending approvals.
    </Description>
  </Variable>
  <Variable initializer="Batch Approval" input="true" name="batchApproverEmailTemplate">
    <Description>
       Name of the email template to use when notifying the batch approver of pending approval.
    </Description>
  </Variable>
  <Variable input="true" name="workItemComments">
    <Description>
       List of global workflow comments to be appended to the approval workitem.
    </Description>
  </Variable>
  <Variable input="true" name="managerElectronicSignature">
    <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by a manager.
    </Description>
  </Variable>
  <Variable input="true" name="ownerElectronicSignature">
    <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by object owners.
    </Description>
  </Variable>
  <Variable input="true" name="securityOfficerElectronicSignature">
    <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by the security officer.
    </Description>
  </Variable>
  <Variable input="true" name="batchApproverElectronicSignature">
    <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by the batch approver when performing batch operations.
    </Description>
  </Variable>
  <Variable input="true" name="workItemPriority">
    <Description>
      String version of WorkItem.level that will be used
      to set the priority of the workitems generated
      as part of any generated approvals.
    </Description>
  </Variable>
  <Variable name="tmpApprovalSet">
    <Description>
       Temporary and transient  ApprovalSet used to hold filtered
       approval sets as we transition through the approval chain.
    </Description>
  </Variable>
  <Variable name="tmpApproval">
    <Description>
       Temporary and transient list of Approval object used to hold filtered
       approval as we transition through the approval chain.
    </Description>
  </Variable>
  <RuleLibraries>
    <Reference class="sailpoint.object.Rule" name="Approval Library"/>
    <Reference class="sailpoint.object.Rule" name="LCM Workflow Library"/>
  </RuleLibraries>
  <Step icon="Start" name="Start" posX="28" posY="10">
    <Transition to="Start Approval"/>
  </Step>
  <Step icon="Task" name="Start Approval" posX="28" posY="149">
    <Transition to="Manager Approval" when="script:isApprovalEnabled(approvalScheme, &quot;manager&quot;)"/>
    <Transition to="Build Owner ApprovalSet" when="script:isApprovalEnabled(approvalScheme, &quot;owner&quot;)"/>
    <Transition to="Build Security Officer ApprovalSet" when="script:isApprovalEnabled(approvalScheme, &quot;securityOfficer&quot;)"/>
    <Transition to="Batch Request Approval" when="script:isApprovalEnabled(approvalScheme, &quot;batchRequest&quot;)"/>
    <Transition to="end"/>
  </Step>
  <Step icon="Approval" name="Manager Approval" posX="172" posY="7">
    <Approval mode="serial" owner="call:buildManagerApproval" renderer="lcmWorkItemRenderer.xhtml" send="approvalSet,identityDisplayName,identityName,policyViolations">
      <AfterScript>
        <Source>
          import sailpoint.workflow.IdentityRequestLibrary;

            assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);
            IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, approvalSet);
            auditDecisions(item);
        </Source>
      </AfterScript>
      <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
      <Arg name="workItemElectronicSignature" value="ref:managerElectronicSignature"/>
      <Arg name="workItemRequester" value="$(launcher)"/>
      <Arg name="workItemDescription" value="Manager Approval - Account Changes for User: $(identityDisplayName)"/>
      <Arg name="workItemNotificationTemplate" value="ref:managerEmailTemplate"/>
      <Arg name="workItemTargetClass" value="sailpoint.object.Identity"/>
      <Arg name="workItemTargetName" value="$(identityName)"/>
      <Arg name="workItemTargetId" value="$(identityId)"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
    </Approval>
    <Description>
      If approvalScheme contains manager, send an approval for all
      requested items in the request. This approval will get the entire
      approvalSet as part of the workitem.
    </Description>
    <Transition to="Build Owner ApprovalSet" when="script:isApprovalEnabled(approvalScheme, &quot;owner&quot;)"/>
    <Transition to="Build Security Officer ApprovalSet" when="script:isApprovalEnabled(approvalScheme, &quot;securityOfficer&quot;)"/>
    <Transition to="end"/>
  </Step>
  <Step action="script:filterApprovalSet(approvalSet,includeRejectedItemsInApprovalChain,false)" icon="Task" name="Build Owner ApprovalSet" posX="237" posY="212" resultVariable="tmpApprovalSet">
    <Transition to="Owner Approval"/>
  </Step>
  <Step icon="Approval" name="Owner Approval" posX="389" posY="211">
    <Approval mode="ref:approvalMode" owner="call:buildOwnerApprovals" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName,policyViolations">
      <AfterScript>
        <Source>

          import sailpoint.workflow.IdentityRequestLibrary;

          if ( item == null )
              return;

          assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);
          IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, approvalSet);
          auditDecisions(item);
        </Source>
      </AfterScript>
      <Arg name="approvalSet" value="ref:tmpApprovalSet"/>
      <Arg name="workItemDescription" value="Owner Approval - Account Changes for User: $(identityDisplayName)"/>
      <Arg name="workItemElectronicSignature" value="ref:ownerElectronicSignature"/>
      <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
      <Arg name="workItemNotificationTemplate" value="ref:ownerEmailTemplate"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="workItemRequester" value="$(launcher)"/>
    </Approval>
    <Description>
      If approvalScheme contains owner, send approvals out to all
      of the owners for items in the request. The main approvalSet
      is broken up into owner specific approval sets and assimilated
      back into the main approvalset as decisions are made.

      The previous decisions made on the items will be present along
      with any comments made by the manager.

      This step will be skipped if all items are
      rejected and includeRejectedItemsInApprovalChain is set to false
    </Description>
    <Transition to="Build Security Officer ApprovalSet" when="script:isApprovalEnabled(approvalScheme, &quot;securityOfficer&quot;)"/>
    <Transition to="end"/>
  </Step>
  <Step action="script:filterApprovalSet(approvalSet,includeRejectedItemsInApprovalChain,false)" icon="Task" name="Build Security Officer ApprovalSet" posX="309" posY="61" resultVariable="tmpApprovalSet">
    <Transition to="Security Officer Approval"/>
  </Step>
  <Step condition="script:!isNull(tmpApprovalSet) &amp;&amp; !tmpApprovalSet.isEmpty()" icon="Approval" name="Security Officer Approval" posX="698" posY="59">
    <Approval mode="serial" owner="call:buildSecurityOfficerApproval" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName,policyViolations">
      <AfterScript>
        <Source>
          import sailpoint.workflow.IdentityRequestLibrary;

          assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);
          IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, approvalSet);
        </Source>
      </AfterScript>
      <Arg name="approvalSet" value="ref:tmpApprovalSet"/>
      <Arg name="workItemElectronicSignature" value="ref:securityOfficerElectronicSignature"/>
      <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
      <Arg name="workItemRequester" value="$(launcher)"/>
      <Arg name="workItemDescription" value="Security Officer Approval - Account Changes for User: $(identityDisplayName)"/>
      <Arg name="workItemNotificationTemplate" value="ref:securityOfficerEmailTemplate"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="workItemTargetClass" value="sailpoint.object.Identity"/>
      <Arg name="workItemTargetName" value="ref:identityName"/>
      <Arg name="workItemTargetId" value="ref:identityId"/>
    </Approval>
    <Description>
     If approvalScheme contains securityOfficer and the securityOfficeName is
     non null this step will send items with decisions and comments
     from the cart for final decision.

     The previous decisions made on the item will be present along with
     any comments made in previous approval steps.
    </Description>
    <Transition to="Batch Request Approval"/>
  </Step>
  <Step icon="Approval" name="Batch Request Approval" posX="833" posY="59">
    <Approval mode="serial" owner="ref:batchRequestApprover" renderer="lcmWorkItemRenderer.xhtml" send="identityDisplayName,identityName">
      <AfterScript>
        <Source>
          assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);
        </Source>
      </AfterScript>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="workItemDescription" value="Batch Request Approval requested by $(launcher)"/>
      <Arg name="workItemElectronicSignature" value="ref:batchApproverElectronicSignature"/>
      <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
      <Arg name="workItemNotificationTemplate" value="ref:batchApproverEmailTemplate"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="workItemRequester" value="$(launcher)"/>
      <Arg name="workItemTargetClass" value="sailpoint.object.BatchRequest"/>
      <Arg name="workItemTargetId" value="ref:batchRequestId"/>
    </Approval>
    <Description>
     If approvalScheme contains batchRequest and the batchRequestApprover is
     non null this step will send items with decisions and comments
     from the cart for final decision.
    </Description>
    <Transition to="end"/>
  </Step>
  <Step icon="Stop" name="end" posX="920" posY="1"/>
</Workflow>
<Workflow libraries="IdentityRequest" name="Identity Request Notify" type="Subprocess">
  <Variable input="true" name="identityName" required="true">
    <Description>
      The name of the identity object being modified.
    </Description>
  </Variable>
  <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
    <Description>
      The displayName of the identity being updated.
      This may be passed in, if not the script queries for this
      using a projection query and falls back to the name.
    </Description>
  </Variable>
  <Variable initializer="user,requester" input="true" name="notificationScheme">
    <Description>
     A string that specifies who should be notified when the request has been complete.
     The value can be null or a csv of one or more of the following options.

     none or null
       disable notifications

     user
       Identity that is being update will be notified.

     manager
       The manager of the Identity that is being updated will be notified.

     requester
       The person that has requested the update will be notified.

     securityOfficer
       The identity named in the securityOfficerNameVariable will be notified.
    </Description>
  </Variable>
  <Variable input="true" name="securityOfficerName">
    <Description>
      The name of the security officer identity.
    </Description>
  </Variable>
  <Variable input="true" name="policyViolations">
    <Description>
       List of policy violations that were found during our initial policy scan.
       This list is passed into each work item so the approvers can see
       pending violations.
    </Description>
  </Variable>
  <Variable input="true" name="flow">
    <Description>
      The name of the LCM flow that launched this workflow.

      This is one of these values:

      AccountsRequest
      EntitlementsRequest
      RolesRequest
      IdentityCreateRequest
      IdentityEditRequest
      ForgotPassword
      ExpiredPassword
      PasswordRequest
      joiner
      mover
      leaver
      AttributeSync

    </Description>
  </Variable>
  <Variable input="true" name="trace">
    <Description>
      Used for debugging this subprocess and when set to true trace
      statements will be sent to stdout.
    </Description>
  </Variable>
  <Variable input="true" name="approvalScheme">
    <Description>
       A string that specifies how approvals should be generated for
       this workflow.
       
       This is usefull for the notification subprocess incase
       the template wants to render specific text in the email
       when certain schemes are configured.
    </Description>
  </Variable>
  <Variable input="true" name="approvalSet">
    <Description>
       This attributes is set during the "Build Approval Set" step,
       which builds this list by going through the ProvisioningPlan
       to build the line items that need to be approved,

       This variable includes all ApprovalItems that are part of
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
  </Variable>
  <Variable input="true" name="plan">
    <Description>The provisioning plan for the request.</Description>
  </Variable>
  <Variable initializer="LCM User Notification" input="true" name="userEmailTemplate">
    <Description>
       Name of the email template to use when notifying the user.
    </Description>
  </Variable>
  <Variable initializer="LCM Manager Notification" input="true" name="managerEmailTemplate">
    <Description>
       Name of the email template to use when notifying the manager.
    </Description>
  </Variable>
  <Variable initializer="LCM Requester Notification" input="true" name="requesterEmailTemplate">
    <Description>
       Name of the email template to use when notifying the requester.
    </Description>
  </Variable>
  <Variable initializer="LCM Manager Notification" input="true" name="securityOfficerEmailTemplate">
    <Description>
       Name of the email template to use when notifying the security officer.
    </Description>
  </Variable>
  <Variable input="true" name="workItemPriority">
    <Description>
      String version of WorkItem.level that was used
      to set the priority on the access request and
      any workitems.
    </Description>
  </Variable>
  <Step icon="Start" name="Start" posX="28" posY="10">
    <Transition to="Notify User"/>
  </Step>
  <Step action="call:sendEmail" condition="script:Util.csvToList(notificationScheme).contains(&quot;user&quot;)" icon="Email" name="Notify User" posX="98" posY="10">
    <Arg name="template" value="ref:userEmailTemplate"/>
    <Arg name="to" value="script:getUserEmail(identityName, plan)"/>
    <Arg name="approvalSet" value="call:prepareApprovalSetForNotification"/>
    <Transition to="Notify Requester"/>
  </Step>
  <Step action="call:sendEmail" condition="script:Util.csvToList(notificationScheme).contains(&quot;requester&quot;)" icon="Email" name="Notify Requester" posX="216" posY="10">
    <Arg name="template" value="ref:requesterEmailTemplate"/>
    <Arg name="to" value="script:getEmail(launcher)"/>
    <Arg name="approvalSet" value="call:prepareApprovalSetForNotification"/>
    <Transition to="Notify Manager"/>
  </Step>
  <Step action="call:sendEmail" condition="script:Util.csvToList(notificationScheme).contains(&quot;manager&quot;)" icon="Email" name="Notify Manager" posX="351" posY="10">
    <Arg name="template" value="ref:managerEmailTemplate"/>
    <Arg name="to" value="script:getManagersEmail(identityName, plan)"/>
    <Arg name="approvalSet" value="call:prepareApprovalSetForNotification"/>
    <Transition to="Notify Security Officer"/>
  </Step>
  <Step action="call:sendEmail" condition="script:Util.csvToList(notificationScheme).contains(&quot;securityOfficer&quot;)" icon="Email" name="Notify Security Officer" posX="483" posY="10">
    <Arg name="template" value="ref:securityOfficerEmailTemplate"/>
    <Arg name="to" value="script:getEmail(securityOfficerName)"/>
    <Arg name="approvalSet" value="call:prepareApprovalSetForNotification"/>
    <Transition to="end"/>
  </Step>
  <Step icon="Stop" name="end" posX="602" posY="10"/>
</Workflow>
<Workflow libraries="Identity,IdentityRequest" name="Identity Request Provision" type="Subprocess">
  <Variable editable="true" initializer="false" input="true" name="optimisticProvisioning">
    <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
  </Variable>
  <Variable editable="true" initializer="true" input="true" name="foregroundProvisioning">
    <Description>
      Normally provisioning is done in a step that uses the "background"
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to
      see the resutls of the request.
    </Description>
  </Variable>
  <Variable input="true" name="fallbackApprover" required="true">
    <Description>
      A String that specifies the name of the Identity that will
      be assigned any manual actions  where the owner of the approver
      can't be resolved.
    </Description>
  </Variable>
  <Variable input="true" name="approvalSet">
    <Description>
       This attributes is set during the "Build Approval Set" step,
       which builds this list by going through the ProvisioningPlan
       to build the line items that need to be approved,

       This variable includes all ApprovalItems that are part of
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
  </Variable>
  <Variable initializer="Identity Update" input="true" name="formTemplate">
    <Description>
      Template used when processing provisioning forms.
    </Description>
  </Variable>
  <Variable input="true" name="trace">
    <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
  </Variable>
  <Variable input="true" name="plan">
    <Description>
      The plan may be passed in from the Create/Update Identity workflows.
      Otherwise the passed in project's master plan is typically used.
    </Description>
  </Variable>
  <Variable initializer="true" input="true" name="recompile">
    <Description>
       Option that can be used to prevent recompilation after approval
       changes have been applied to the plan/project.
    </Description>
  </Variable>
  <Variable initializer="Pending Manual Changes" input="true" name="manualActionsEmailTemplate">
    <Description>
       Option that can be used to prevent recompilation after approval
       changes have been applied to the plan/project.
    </Description>
  </Variable>
  <Variable input="true" name="noTriggers">
    <Description>
      If true, then do no attempt to trigger lifecycle events.
    </Description>
  </Variable>
  <Variable input="true" name="workItemComments">
    <Description>
       Global comments which should be appended to each approval item.
    </Description>
  </Variable>
  <Variable input="true" name="approvalScheme">
    <Description>
      A csv string that specifies how approvals should be generated for
      the incoming request.

      The value can be any of the values below, combined together but
      are always processed in this order:

      1. manager
      2. owner
      3. securityOfficer

      Any rejected items from previous approvals will be omitted from the
      next phase of approvers.

      none - disabled approvals

      owner - the object owner gets the approval
              For Role approvals this is the Role object owner. When dealing
              with things like Unlock and other account level changes
              the approvals will be assigned to the the application owner.

      manager - The manager will get all approvals

      securityOfficer - The identity named security the security in the variable
                        securityOfficerName.

    </Description>
  </Variable>
  <Variable input="true" name="identityRequestId">
    <Description>
       The ID of the IdentityRequest.
    </Description>
  </Variable>
  <Variable input="true" name="workItemPriority">
    <Description>
      String version of WorkItem.level that will be used
      to set the priority on any generated workitems for
      of forms or manual actions.
    </Description>
  </Variable>
  <Variable input="true" name="splitProvisioning">
    <Description>
          True to denote this is a partial of the full ProvisioningPlan. This should be true in the case of LCM Provisioning
          splits.
      </Description>
  </Variable>
  <Variable initializer="true" input="true" name="saveUnmanagedPlan">
    <Description>
      When true we will save unmanaged plan as ProvisioningRequest.
    </Description>
  </Variable>
  <Variable initializer="false" input="true" name="saveUnmanagedPlan_WithProjectArgument">
    <Description>
      When true we will pass the project in to save unmanaged plan as an argument.
    </Description>
  </Variable>
  <Variable input="true" name="project" output="true">
    <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan.
    </Description>
  </Variable>
  <Description>
      This workflow subprocess is used to provision a
      project.

      This subprocess was added in 5.5 in an effort to
      break groups of related steps into a single call
      from the top level workflow.

      It now encapsulates the following services:

        - Process approval decisions
           -- which recompiles the project
        - Post provisioning forms for user's outside of the requester

  </Description>
  <RuleLibraries>
    <Reference class="sailpoint.object.Rule" name="LCM Workflow Library"/>
  </RuleLibraries>
  <Step icon="Start" name="Start" posX="15" posY="12">
    <Transition to="Start Provisioning Process"/>
  </Step>
  <Step action="call:addMessage" icon="Message" name="Start Provisioning Process" posX="130" posY="12">
    <Arg name="message" value="Modifications to $(identityDisplayName) are being provisioned."/>
    <Transition to="Process Approval Decisions"/>
  </Step>
  <Step action="call:processApprovalDecisions" condition="script:!isNull(approvalSet)" icon="Task" name="Process Approval Decisions" posX="309" posY="11" resultVariable="project">
    <Arg name="project" value="ref:project"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="recompile" value="ref:recompile"/>
    <Arg name="disableAudit" value="true"/>
    <Description>
      Dig through the ApprovalSets found in the Approval step and build an audit
      trail for the decisions.  Then for any rejected items remove them from
      the provisioning plan so they are not part of the provisioning request.
    </Description>
    <Transition to="Do Provisioning Forms Post-Approval"/>
  </Step>
  <Step icon="Task" name="Do Provisioning Forms Post-Approval" posX="511" posY="12">
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="formTemplate" value="ref:formTemplate"/>
    <Arg name="preferredOwner" value="ref:sessionOwner"/>
    <Description>
      Call the standard subprocess for assembling, presenting, and assimilating
      provisioning forms that remain after approvals.
    </Description>
    <Return name="project" to="project"/>
    <Return name="approvalSet" to="approvalSet"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Do Provisioning Forms"/>
    </WorkflowRef>
    <Transition to="Pre Provision"/>
  </Step>
  <Step action="call:assimilateAccountIdChanges" icon="Task" name="Pre Provision" posX="682" posY="13" resultVariable="approvalSet">
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Description>
      Before we approve assimilate the result of any accountId changes that may have been compiled
      into the plan back onto the ApprovalSet and IdentityRequest.
    </Description>
    <Transition to="Refresh Identity Request"/>
  </Step>
  <Step action="call:refreshIdentityRequestAfterApproval" icon="Task" name="Refresh Identity Request" posX="813" posY="13">
    <Arg name="project" value="ref:project"/>
    <Arg name="splitProvisioning" value="ref:splitProvisioning"/>
    <Description>
       Assimilate any approval summaries that were built up during
       the provisioning process.
    </Description>
    <Transition to="Provision"/>
  </Step>
  <Step icon="Task" name="Provision" posX="941" posY="13">
    <Arg name="project" value="ref:project"/>
    <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="noTriggers" value="ref:noTriggers"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="splitProvisioning" value="ref:splitProvisioning"/>
    <Arg name="recompileBeforeProvisioning" value="!ref:foregroundProvisioning"/>
    <Description>
      Call the standard subprocess to initialize the request, this includes
      auditing, building the approvalset, compiling the plan into
       project and checking policy violations.
    </Description>
    <Return name="retries" to="retries"/>
    <Return name="project" to="project"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Provision with retries"/>
    </WorkflowRef>
    <Transition to="Wait for Queued Items"/>
  </Step>
  <Step icon="Task" name="Wait for Queued Items" posX="1074" posY="13">
    <Arg name="project" value="ref:project"/>
    <Arg name="splitProvisioning" value="ref:splitProvisioning"/>
    <Arg name="trace" value="ref:trace"/>
    <Return name="project" to="project"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Check Status of queued items"/>
    </WorkflowRef>
    <Transition to="Post Provision"/>
  </Step>
  <Step icon="Task" name="Post Provision" posX="1205" posY="13">
    <Script>
      <Source>
        import sailpoint.api.ObjectUtil;
        import sailpoint.tools.Util;
        import sailpoint.object.ProvisioningProject;

        if ( approvalSet != null ) {
            // Set state to pending
            approvalSet.initializeProvisioningState();
            if ( Util.otob(trace) ) {
                 System.out.println("ApprovalSet:\n" + approvalSet.toXml());
            }
        }
        if ( project != null ) {
            if ( Util.otob(trace) ) {
                 // clone and scrub the project so passwords are not visible
                 ProvisioningProject clonedProject = project.deepCopy(wfcontext.getSailPointContext());
                 ObjectUtil.scrubPasswords(clonedProject);
                 System.out.println("Project Executed in identitiy:\n" + clonedProject.toXml());
            }
        }
      </Source>
    </Script>
    <Transition to="Manual Actions"/>
  </Step>
  <Step condition="script:project.getUnmanagedPlan() != null" icon="Approval" name="Manual Actions" posX="1316" posY="13">
    <Approval mode="parallelPoll" owner="rule:Build Manual Action Approvals" renderer="lcmManualActionsRenderer.xhtml" send="identityDisplayName,identityName,policyViolations">
      <AfterScript>
        <Source>
          
          import sailpoint.object.ApprovalSet;
          import sailpoint.object.ApprovalItem;
          import sailpoint.object.WorkItem;
          import sailpoint.object.WorkItem;
          import sailpoint.workflow.IdentityRequestLibrary;
          import sailpoint.workflow.IdentityLibrary;
          import sailpoint.tools.Util;

          if (item == null) {
              // must not be a leaf approval...
              return;
          }

          // mark all of the items finished once the item is complete
          ApprovalSet set = (ApprovalSet)item.get("approvalSet");
          if ( set != null ) {
              List approvalItems = set.getItems();
              for ( ApprovalItem approvalItem : approvalItems ) {
                  approvalItem.setState(WorkItem.State.Finished);
                  // update identity request provisioning state
                  IdentityRequestLibrary.updateIdentityRequestItemProvisioningState(approvalItem, wfcontext);
              }
          }
          
          //save unmanaged plan as ProvisioningRequest
          if ( Util.otob(saveUnmanagedPlan) ) {
              if( ( Util.otob(saveUnmanagedPlan_WithProjectArgument) ) &amp;&amp; ( project != null ) ) {
                  IdentityLibrary.saveUnmanagedPlan(wfcontext, project);
              } else {
                  IdentityLibrary.saveUnmanagedPlan(wfcontext);
              }
          }
          
          // Audit the manual change
          auditManualAction(item);
          
        </Source>
      </AfterScript>
      <Arg name="project" value="ref:project"/>
      <Arg name="workItemRequester" value="$(launcher)"/>
      <Arg name="workItemDescription" value="Manual Changes requested for User: $(identityDisplayName)"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="workItemType" value="ManualAction"/>
      <Arg name="workItemNotificationTemplate" value="ref:manualActionsEmailTemplate"/>
      <Arg name="saveUnmanagedPlan_WithProjectArgument" value="ref:saveUnmanagedPlan_WithProjectArgument"/>
    </Approval>
    <Transition to="end"/>
  </Step>
  <Step icon="Stop" name="end" posX="1419" posY="13"/>
</Workflow>
<Workflow libraries="Identity,IdentityRequest" name="Identity Request Finalize" type="Subprocess">
  <Variable name="project">
    <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan.
      From the project the IdentityRequestItem model will be updated.
    </Description>
  </Variable>
  <Variable input="true" name="identityRequestId" output="true">
    <Description>
       The ID ot the identitytRequestId.

       This step will update the identityRequest status and completion
       status.
    </Description>
  </Variable>
  <Variable input="true" name="approvalSet">
    <Description>
       This attributes is set during the "Build Approval Set" step,
       which builds this list by going through the ProvisioningPlan
       to build the line items that need to be approved,

       This variable includes all ApprovalItems that are part of
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
  </Variable>
  <Variable input="true" name="trace">
    <Description>
      Used for debugging this subprocess and when set to true trace
      statements will be sent to stdout.
    </Description>
  </Variable>
  <Variable input="true" name="ticketManagementApplication">
    <Description>
      Name of the application that can handle ticket requests.
      When non-null the Manage Ticket Steps will be visited to open
      tickets during the workflow lifecycle.
    </Description>
  </Variable>
  <Variable input="true" name="ticketDataGenerationRule">
    <Description>
      A rule that builds up the ticketing provisioning plan based on the workflow
      context.  This rule gets all of the arguments to this subprocess
      plus the curreent workflow context.  The rule can return either a
      ProvisioningPlan or a Map of name value pairs.

      The rule name can be specified here on the subprocess or on the
      ticketManagementApplication config under the same name as this
      variable.
    </Description>
  </Variable>
  <Variable name="autoVerifyIdentityRequest">
    <Description>
      Flag to indicate when finishing the request we should
      automatically mark it verified. Currently used by
      the change password workflow so we don't wait to
      verify since passwords can't be verifed.
    </Description>
  </Variable>
  <Variable input="true" name="workItemPriority">
    <Description>
      String version of WorkItem.level that was used
      to set the priority of the IdentityRequest and
      workitems.
    </Description>
  </Variable>
  <Step icon="Start" name="Start" posX="15" posY="12">
    <Transition to="Audit Completion"/>
  </Step>
  <Step action="call:auditLCMCompletion" icon="Audit" name="Audit Completion" posX="115" posY="12">
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Transition to="Complete Identity Request"/>
  </Step>
  <Step action="call:completeIdentityRequest" icon="Task" name="Complete Identity Request" posX="261" posY="12" resultVariable="identityRequest">
    <Arg name="project" value="ref:project"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="autoVerify" value="$(autoVerifyIdentityRequest)"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Transition to="Update Ticket On Complete"/>
  </Step>
  <Step condition="script:(ticketManagementApplication != null)" icon="Task" name="Update Ticket On Complete" posX="443" posY="12">
    <Arg name="action" value="complete"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="ticketDataGenerationRule" value=""/>
    <Arg name="trace" value="ref:trace"/>
    <Description>
      Call a subprocess to update the ticket in the ticketManagementApplication is non-null.

      You can specify a specific 'ticketDataGenerationRule' here or you can also specify
      it on the application.  It'll be read from the argument first and fall back to the '
      application config.
    </Description>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Manage Ticket"/>
    </WorkflowRef>
    <Transition to="end"/>
  </Step>
  <Step icon="Stop" name="end" posX="601" posY="13"/>
</Workflow>
<Workflow explicitTransitions="true" name="Identity Request Approve Identity Changes" type="Subprocess">
  <Variable input="true" name="identityName" required="true">
    <Description>
      The name of the identity object being modified.
    </Description>
  </Variable>
  <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
    <Description>
      The displayName of the identity being updated.
      This may be passed in, if not the script queries for this
      using a projection query and falls back to the name.
    </Description>
  </Variable>
  <Variable input="true" name="identityRequestId">
    <Description>
       The ID of the IdentityRequest.
    </Description>
  </Variable>
  <Variable input="true" name="plan" required="true">
    <Description>The provisioning plan ready to execute.</Description>
  </Variable>
  <Variable initializer="LCM Identity Approval" input="true" name="formTemplate">
    <Description>Name of the form Template to use when building provisioning form.</Description>
  </Variable>
  <Variable input="true" name="approvalSet" output="true">
    <Description>
       This variable includes all ApprovalItems that are part of
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
  </Variable>
  <Variable input="true" name="approvers">
    <Description>Owners that should recieve the approval.</Description>
  </Variable>
  <Variable input="true" name="approvalScheme">
    <Description>
      A String that specifies how approvals should be generated for
      this workflow there are five built-in modes

      none - disabled approvals

      manager - The user's current manager will get approvals

      newManager - The newly assigned manager will get approvals when
                   manager transfers occur. Otherwise the user's manager
                   current manager will be the approver.

      securityOfficer - The identity in the securityOfficerName variable
                        will get approvals.
    </Description>
  </Variable>
  <Variable initializer="LCM Identity Update Approval" input="true" name="approvalEmailTemplate">
    <Description>
     The email template to use for approval notifications.
    </Description>
  </Variable>
  <Variable input="true" name="securityOfficerName">
    <Description>
       The name of the identity that will be sent approvals
       during security officer approvals.
    </Description>
  </Variable>
  <Variable name="approvalForm">
    <Description>The generated form that is displayed to the user during the approval.</Description>
  </Variable>
  <Variable input="true" name="fallbackApprover" required="true">
    <Description>
      A String that specifies the name of the Identity that will
      be assigned any manual actions  where the owner of the approver
      can't be resolved.
    </Description>
  </Variable>
  <Variable initializer="serial" input="true" name="approvalMode">
    <Description>
     A string that specifies how we should handle the approvals.

     By default this is serial since most of these request with
     the exception of manager transfers will have only one approver.

     parallel
       Approvals are processed concurrently and there must be consensus,
       we wait for all approvers to approve.  The first approver that
       rejects terminates the entire approval.

     parallelPoll
       Approvals are processed concurrently but consensus is not required.
       All approvals will be processed, we don't stop if there are any
       rejections.

     serial
       Approvals are processed one at a time and there must be consensus.
       The first approver that rejects terminates the entire approval.

     serialPoll
       Approvals are processed in order but consensus is not required.
       All approvals will be processed, we don't stop if there are any
       rejections.  In effect we are "taking a poll" of the approvers.

     any
      Approvals are processed concurrently, the first approver to
      respond makes the decision for the group.
    </Description>
  </Variable>
  <Variable input="true" name="policyViolations">
    <Description>
       List of policy violations that were found during our initial policy scan.
       This list is passed into each work item so the approvers can see
       pending violations.
    </Description>
  </Variable>
  <Variable input="true" name="workItemPriority">
    <Description>
      String version of WorkItem.level that will be used
      to set the priority of any generated approval
      workitems.
    </Description>
  </Variable>
  <Variable input="true" name="approverElectronicSignature">
    <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by the batch approver when performing batch operations.
    </Description>
  </Variable>
  <Description>
     The subprocess that drives the Create and Update Identity workflows.
     This is different then the Identity Request Approve subprocess because this
     approval process produces a form with the approval so that
     approvers can update values while approving.

     This subprocess builds the form necessary for the editable approvals
     and then assimilates that data entered back to the plan, which
     can be returned from the subprocess.
  </Description>
  <RuleLibraries>
    <Reference class="sailpoint.object.Rule" name="Approval Library"/>
    <Reference class="sailpoint.object.Rule" name="LCM Workflow Library"/>
  </RuleLibraries>
  <Step icon="Start" name="Start" posX="14" posY="12">
    <Transition to="Build Approval Form"/>
  </Step>
  <Step action="call:buildPlanApprovalForm" icon="Task" name="Build Approval Form" posX="106" posY="12" resultVariable="approvalForm">
    <Arg name="plan" value="ref:plan"/>
    <Arg name="template" value="ref:formTemplate"/>
    <Transition to="Customize Approval Form"/>
  </Step>
  <Step name="Customize Approval Form" posX="247" posY="12" resultVariable="approvalForm">
    <Description>
       using the form that was generaed, mMrk the password field read only so approvers
       can't change it.  Also associate a Rule with the name so name changes during
       approvals can be validate.
    </Description>
    <Script>
      <Source>
        import sailpoint.object.Field;
        import sailpoint.object.Form;
        import sailpoint.object.Rule;
        import sailpoint.object.Configuration;
        import sailpoint.tools.Util;

        if ( approvalForm != null ) {
            Field passwordField = approvalForm.getField("IIQ:password");
            if ( passwordField != null ) {
                passwordField.setReadOnly(true);

                Configuration config = wfcontext.getSailPointContext().getObject(Configuration.class, Configuration.OBJ_NAME);
                boolean requirePassword = Util.atob(config.getString(Configuration.LCM_REQUIRE_PASSWORD_IDENTITY_CREATE));
                passwordField.setRequired(requirePassword);
            }
            Field userId = approvalForm.getField("IIQ:name");
            if ( userId != null ) {
                String ruleName = "LCM Validate Identity Name";
                Rule rule = wfcontext.getSailPointContext().getObject(Rule.class, ruleName);
                if ( rule != null ) {
                    userId.setValidationRule(rule);
                }
            }
            Field manager = approvalForm.getField("IIQ:manager");
            if ( manager != null ) {
                // tell the FormBean to output the value as a name
                // instead of ID which is the default
                manager.addAttribute(Field.ATTR_VALUE_PROPERTY, "name");
            }
        }
        return approvalForm;
      </Source>
    </Script>
    <Transition to="Build Approvers If Necessary"/>
  </Step>
  <Step action="call:getIdentityCreateUpdateApprovals" condition="script:isNull(approvers)" icon="Task" name="Build Approvers If Necessary" posX="429" posY="12" resultVariable="approvers">
    <Description>
      If the approvals weren't passed in then build them up using our
      default rule.
    </Description>
    <Transition to="Approval"/>
  </Step>
  <Step icon="Approval" name="Approval" posX="577" posY="12">
    <Approval mode="ref:approvalMode" owner="ref:approvers" renderer="lcmEditableWorkItemRenderer.xhtml" send="identityDisplayName,identityName,policyViolations, approvalSet">
      <AfterScript>
        <Source>
          import sailpoint.workflow.IdentityRequestLibrary;

          import sailpoint.object.ApprovalSet;
          import sailpoint.object.WorkItem;
          import sailpoint.object.WorkflowCase;
          import sailpoint.object.Form;
          import sailpoint.object.ProvisioningPlan.AccountRequest;
          import sailpoint.object.ProvisioningPlan.AttributeRequest;
          import sailpoint.util.GeneralException;

          if (item == null) {
              return;
          }
          // Assimilate all of the approvalItem changes into our gloval
          // approval set
          //
          ApprovalSet set = (ApprovalSet)item.get("approvalSet");
          if ( set != null ) {
              // Global completion comments will apply to each of the items
              // If there are completion comments append them
              // to any other completion comments, but typically its
              // one or the other
              String completionComments = item.getCompletionComments();
              Identity id = item.getOwner();
              String ownerName = null;
              if ( id != null ) {
                  ownerName = id.getName();
              }
              approvalSet.assimilate(set, ownerName, completionComments, true);
          } else {
              throw new GeneralException("ApprovalSet not found in afterscript.");
          }

          // djs: this is kind of a hack, do I have alternatives?
          // come back to this
          // jsl: Yes, I think you want &lt;Return name='workItemForm' to='approvalForm'/&gt;
          Form form = (Form)item.get("workItemForm");
          if ( form != null ) {
              WorkflowCase c = wfcontext.getWorkflowCase();
              if ( c != null ) {
                  c.put("approvalForm", form);
              }
          }

          // bug#9611 if we notice that the manager request was edited,
          // change the next approval
          if (approvalScheme == null ||
              approvalScheme.contains("manager") ||
              approvalScheme.contains("newManager")) {
              Form form = item.getForm();
              if (form != null) {
                  Field field = form.getField("IIQ:manager");
                  if (field != null) {
                      String newManager = field.getValue();
                      if (newManager != null) {
                          Approval newApproval = null;
                          if (approval != null) {
                              Approval parent = approval.getParent();
                              if (parent != null) {
                                  // find the one after us
                                  List approvals = parent.getChildren();
                                  if (approvals != null) {
                                      Approval prev = null;
                                      for (int i = 0 ; i &lt; approvals.size() ; i++) {
                                          Approval a = (Approval)approvals.get(i);
                                          if (prev == approval) {
                                             newApproval = a;
                                             break;
                                          }
                                          else
                                            prev = a;
                                      }
                                  }
                              }
                          }

                          // newApproval can be null if the user didn't start
                          // with a manager or if the current manager requested
                          // the change
                          if (newApproval != null) {
                              String oldManager = newApproval.getOwner();

                              // If the managers aren't equal, this *could* be a manager change
                              // or it could just be some other type of approval.
                              if (!newManager.equals(oldManager)) {

                                  // Get the manager that was submitted in the plan.
                                  String planager = null;
                                  if (null == plan) {
                                      log.warn("Expected a plan variable in identity request " +
                                               "approval AfterScript.");
                                  }
                                  else {
                                      AccountRequest iiqReq = plan.getIIQAccountRequest();
                                      if (null != iiqReq) {
                                          AttributeRequest managerReq =
                                              iiqReq.getAttributeRequest("manager");
                                          if (null != managerReq) {
                                              planager = managerReq.getValue();

                                              // May have an ID or name, so load it to get the name.
                                              Identity manager =
                                                  context.getObject(Identity.class, planager);
                                              if (null != manager) {
                                                  planager = manager.getName();
                                              }
                                          }
                                      }
                                  }

                                  // If the newManager is the same as what was originally submitted
                                  // then we haven't really changed the manager ... the newApproval
                                  // was for a different type of approver (eg - securityOfficer).
                                  if ((null == planager) || !planager.equals(newManager)) {
                                      log.info("Changing new manager approval owner from " +
                                               oldManager + " to " + newManager);
                                      newApproval.setOwner(newManager);

                                      // The old owner could have been cached.  Clear it to
                                      // make sure this goes to the right guy.
                                      newApproval.setIdentity(null);
                                  }
                              }
                          }
                      }
                  }
              }
          }

          //
          // If they are all rejected mark the Approval Rejected.
          // This allows the Transition to execute once we
          // get a rejection.
          //
          if ( approvalSet.isAllRejected() ) {
              approval.setState(WorkItem.State.Rejected);
          }

          IdentityRequestLibrary.assimilateWorkItemApprovalSetToIdentityRequest(wfcontext, approvalSet);
          auditWorkItemOwnerHistory(item);
          auditWorkItemComments(item);
          auditDecisions(item);
        </Source>
      </AfterScript>
      <Arg name="workItemDescription" value="Account Changes for User: $(identityDisplayName)"/>
      <Arg name="workItemElectronicSignature" value="ref:approverElectronicSignature"/>
      <Arg name="workItemForm" value="ref:approvalForm"/>
      <Arg name="workItemIdentityRequestId" value="ref:identityRequestId"/>
      <Arg name="workItemNotificationTemplate" value="ref:approvalEmailTemplate"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="workItemRequester" value="$(launcher)"/>
      <Arg name="workItemType" value="Approval"/>
    </Approval>
    <Transition to="Assimilate Form Changes"/>
  </Step>
  <Step action="call:assimilatePlanApprovalForm" icon="Task" name="Assimilate Form Changes" posX="712" posY="12" resultVariable="plan">
    <Arg name="form" value="ref:approvalForm"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="plan" value="ref:plan"/>
    <Description>
      This step takes the form from the workitem and applys any edits that were
      made back into the plan.
    </Description>
    <Transition to="Check Plan and Update Cart"/>
  </Step>
  <Step icon="Task" name="Check Plan and Update Cart" posX="877" posY="12" resultVariable="plan">
    <Description>
      This step takes looks for name changes during creates and updates
      the stub identity on the plan accordingly.
    </Description>
    <Script>
      <Source>
        
        import sailpoint.api.ObjectUtil;
        import sailpoint.object.ApprovalSet;
        import sailpoint.object.ApprovalItem;
        import sailpoint.object.Filter;
        import sailpoint.object.Identity;
        import sailpoint.object.ProvisioningPlan;
        import sailpoint.object.ProvisioningPlan.AccountRequest;
        import sailpoint.object.ProvisioningPlan.AttributeRequest;
        import sailpoint.object.QueryOptions;

        List accountRequests = plan.getAccountRequests(ProvisioningPlan.APP_IIQ);

        if ( accountRequests != null &amp;&amp; !accountRequests.isEmpty() &amp;&amp; accountRequests.get(0) != null) {
            AccountRequest iiq = accountRequests.get(0);
            // Look for the name attribute
            boolean nameChanged = false;
            String idName = identityName;
            AttributeRequest name = iiq.getAttributeRequest("name");
            if ( name != null ) {
                String nameStr = Util.otoa(name.getValue());
                if ( nameStr != null ) {
                    nameStr = nameStr.trim();
                    // If they don't match this indicates a form
                    // update changes the accountId
                    if ( identityName.compareTo(nameStr) != 0 ) {
                        // If this is a create request, then it is a new identity, and we need to
                        // re-verify that the identity does not exist. This is validated at the form level so should never
                        // happen in the normal course of events, but important to check in case of http request manipulation.
                        if (AccountRequest.Operation.Create.equals(iiq.getOperation())) {
                            QueryOptions qo = new QueryOptions();
                            Filter filter  = Filter.or(Filter.eq("id", nameStr), Filter.ignoreCase(Filter.eq("name", nameStr)));
                            qo.add(new Filter[]{filter});
                            qo.addFilter(ObjectUtil.buildWorkgroupInclusiveIdentityFilter());
                            int count = wfcontext.getSailPointContext().countObjects(Identity.class, qo);
                            if (count &gt; 0) {
                                throw new GeneralException("User '"+ nameStr + "' already exists.");
                            }
                        }

                        idName = nameStr;
                        nameChanged = true;
                         // update the plan with the new/correct account ID
                        iiq.setNativeIdentity(idName);
                    }
                }
            }
            Identity planIdentity = plan.getIdentity();
            if ( ( planIdentity == null ) || ( nameChanged ) ) {
                SailPointContext ctx = wfcontext.getSailPointContext();
                Identity stub = ctx.getObjectByName(Identity.class, idName);
                if ( stub == null ) {
                    stub = new Identity();
                    stub.setName(idName);
                }
                plan.setIdentity(stub);
            }

            //
            // Update the approval item with any changes that
            // were made during the approval process
            //
            if ( approvalSet != null ) {
                List approvalItems =  approvalSet.getItems();
                // in the default case there is always just one item for all the changes
                if ( Util.size(approvalItems) == 1 ) {
                    // Re-flatten the attribute values so they are accurate when auditing changes
                    // and notifying. The values may have been updated in the approvalForm.
                    ApprovalItem item = approvalItems.get(0);
                    List attrRequestFlat = flattenAttributeRequests(iiq.getAttributeRequests());
                    if ( attrRequestFlat != null ) {
                        item.setValue(attrRequestFlat);
                    }
                    if ( nameChanged ) {
                        item.setNativeIdentity(idName);
                    }
                }
            }
        }
        return plan;
        
      </Source>
    </Script>
    <Transition to="end"/>
  </Step>
  <Step icon="Stop" name="end" posX="1021" posY="12"/>
</Workflow>
<Workflow explicitTransitions="true" name="Approve and Provision Subprocess" type="Subprocess">
  <Variable input="true" name="identityName">
    <Description>The name of the identity being updated.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="endOnManualWorkItems">
    <Description>Option to skip requests with manual work items.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="endOnProvisioningForms">
    <Description>Option to skip requests with provisioning forms.</Description>
  </Variable>
  <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
    <Description>
            The displayName of the identity being updated.
            Query for this using a projection query and fall back to the name.
        </Description>
  </Variable>
  <Variable input="true" name="plan">
    <Description>The provisioning plan ready to execute.</Description>
  </Variable>
  <Variable input="true" name="noTriggers">
    <Description>
        If true, then do no attempt to trigger lifecycle events.
      </Description>
  </Variable>
  <Variable input="true" name="flow">
    <Description>
            The name of the LCM flow that launched this workflow.

            This is one of these three values:

            AccountsRequest
            EntitlementsRequest
            RolesRequest
            AttributeSync
        </Description>
  </Variable>
  <Variable editable="true" initializer="false" name="optimisticProvisioning">
    <Description>
            Set to true to enable optimistic provisioning.  This will cause
            changes to the entitlements compiled from role assignments to be
            applied immediately to the identity cube rather than waiting
            for the next refresh/reaggregation after the provisioning system
            completes the request.
        </Description>
  </Variable>
  <Variable editable="true" initializer="true" name="foregroundProvisioning">
    <Description>
            Normally provisioning is done in a step that uses the "background"
            option to force the workflow to be suspend and be resumed in a
            background task thread.  This prevents the browser session from
            hanging since provision can sometimes take a long time.  For demos
            and testing it can be better to do this in the foreground so that
            provisioning will have been performed when control is returned to the
            user.  This prevents having to run the Perform Maintenance task to
            see the results of the request.
        </Description>
  </Variable>
  <Variable input="true" name="batchRequestItemId">
    <Description>
            Used by the batch interface to record back individual request item status. The specific item id for the individual request in the batch file.
        </Description>
  </Variable>
  <Variable initializer="LCM User Notification" input="true" name="userEmailTemplate">
    <Description>
            The email template to use for user notification.
        </Description>
  </Variable>
  <Variable initializer="LCM Requester Notification" input="true" name="requesterEmailTemplate">
    <Description>
            The email template to use for requester notification.
        </Description>
  </Variable>
  <Variable initializer="LCM Manager Notification" input="true" name="managerEmailTemplate">
    <Description>
            The email template to use for manager notification.
        </Description>
  </Variable>
  <Variable input="true" name="securityOfficerEmailTemplate">
    <Description>
            The email template to use for security officer notification.
        </Description>
  </Variable>
  <Variable initializer="parallel" input="true" name="approvalMode">
    <Description>
            A string that specifies how we should handle the approvals.

            By default this is serial since most of these request with
            the exception of manager transfers will have only one approver.

            parallel
            Approvals are processed concurrently and there must be consensus,
            we wait for all approvers to approve.  The first approver that
            rejects terminates the entire approval.

            parallelPoll
            Approvals are processed concurrently but consensus is not required.
            All approvals will be processed, we don't stop if there are any
            rejections.

            serial
            Approvals are processed one at a time and there must be consensus.
            The first approver that rejects terminates the entire approval.

            serialPoll
            Approvals are processed in order but consensus is not required.
            All approvals will be processed, we don't stop if there are any
            rejections.  In effect we are "taking a poll" of the approvers.

            any
            Approvals are processed concurrently, the first approver to
            respond makes the decision for the group.
        </Description>
  </Variable>
  <Variable initializer="owner" input="true" name="approvalScheme">
    <Description>
            A csv string that specifies how approval items should be generated
            for the incoming request.

            The value can be "none", in which case approvals are disabled.

            The value can also be a combination of any of the values below
            in any order, separated by commas. The order in which they are
            specified is the order in which they are processed:

            owner
            The object owner gets the approval item.
            For Role approvals this is the Role object owner.
            For Entitlement approvals this is the Entitlement object owner.

            manager
            The manager gets the approval item.

            securityOfficer
            The identity in the variable securityOfficerName gets the approval item.

            identity
            The identities/workgroups in the variable approvingIdentities get the approval item.
        </Description>
  </Variable>
  <Variable initializer="LCM Identity Update Approval" input="true" name="approvalEmailTemplate">
    <Description>
            The email template to use for approval notifications.
        </Description>
  </Variable>
  <Variable initializer="Normal" input="true" name="workItemPriority">
    <Description>
            The String version of a WorkItem.Priority. This variable is
            used to set the priority on all of the workitems generated
            as part of this workflow and also set on the IdentityRequest
            object.
        </Description>
  </Variable>
  <Variable input="true" name="securityOfficerName">
    <Description>
            The name of the identity that will be sent approvals
            during security officer approvals.
        </Description>
  </Variable>
  <Variable initializer="spadmin" input="true" name="fallbackApprover">
    <Description>
            A String that specifies the name of the Identity that will
            be assigned any approvals where the owner of the approver
            can't be resolved. Example if the scheme is "owner" and the
            application doesn't specify and owner.
        </Description>
  </Variable>
  <Variable initializer="false" input="true" name="enableRetryRequest">
    <Description>
            When set to true it will disable the workflow retry loop and let the
            Provision step launch requests to handle the retries.  Enabling
            this flag will enable some older functionality.
        </Description>
  </Variable>
  <Variable initializer="LCM" input="true" name="source">
    <Description>
            String version of sailpoint.object.Source to indicate
            where the request originated.  Defaults to LCM.
        </Description>
  </Variable>
  <Variable initializer="false" name="trace">
    <Description>
            Used for debugging this workflow and when set to true trace
            will be sent to stdout.
        </Description>
  </Variable>
  <Variable name="approvalSet">
    <Description>
            This attributes is set during the "Build Approval Set" step,
            which builds this list by going through the ProvisioningPlan
            to build the line items that need to be approved,

            This variable includes all ApprovalItems that are part of
            the request process and is updated during the AfterScript
            of the approval process by assimilating the decisions
            and comments from the Approvals copy of the ApprovalItem.
        </Description>
  </Variable>
  <Variable input="true" name="approvalAssignmentRule"/>
  <Variable name="project">
    <Description>
            ProvisioningProject which is just a compiled version of the ProvisioningPlan.
        </Description>
  </Variable>
  <Variable name="policyViolations">
    <Description>
            List of policy violations that were found during our initial policy scan.
            This list is passed into each work item so the approvers can see
            pending violations.
        </Description>
  </Variable>
  <Variable name="identityRequestId" output="true">
    <Description>
            The sequence id of the Identity request object which is stored in
            the name field of the identity request and auto-incremented.
        </Description>
  </Variable>
  <Variable name="workItemComments">
    <Description>
            Global comments accumulated during the workflow which should be shared
            with other approvals. When a new approval is created, the comments in this
            list will be added to the work item.
        </Description>
  </Variable>
  <Variable input="true" name="ticketManagementApplication">
    <Description>
            Name of the application that can handle ticket requests.
            When non-null the Manage Ticket Steps will be visited to open
            tickets during the workflow lifecycle.
        </Description>
  </Variable>
  <Variable input="true" name="managerElectronicSignature">
    <Description>
            The name of the electronic signature object that should be used when workitems
            are completed by a manager.
        </Description>
  </Variable>
  <Variable input="true" name="ownerElectronicSignature">
    <Description>
            The name of the electronic signature object that should be used when workitems
            are completed by object owners.
        </Description>
  </Variable>
  <Variable input="true" name="securityOfficerElectronicSignature">
    <Description>
            The name of the electronic signature object that should be used when workitems
            are completed by the security officer.
        </Description>
  </Variable>
  <Variable initializer="true" input="true" name="filterRejects">
    <Description>True to filter rejected items when running in Serial/SerialPoll mode.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="setPreviousApprovalDecisions">
    <Description>True to pre-populate approval decisions from previous approvals.</Description>
  </Variable>
  <Variable input="true" name="approvalSplitPoint">
    <Description>Approval Scheme to split on.</Description>
  </Variable>
  <Variable input="true" name="clearApprovalDecisions">
    <Description>
            True to clear any decisions on approvals built with buildCommonApprovals
        </Description>
  </Variable>
  <Variable input="true" name="approvingIdentities">
    <Description>
            List of identities and/or workgroups names/ids that should be involved in the approval
            process.
        </Description>
  </Variable>
  <Variable input="true" name="formTemplate"/>
  <Variable input="true" name="manualActionsEmailTemplate"/>
  <Variable initializer="LCM Identity Update Approval" input="true" name="ownerEmailTemplate">
    <Description>
            Name of the email template to use when notifying the owner of pending approvals.
        </Description>
  </Variable>
  <Variable initializer="false" input="true" name="splitProvisioning">
    <Description>
            True to tell IdentityRequest Provisioning subprocess that this is a subset of the initial provisioning plan
        </Description>
  </Variable>
  <Variable initializer="false" input="true" name="saveUnmanagedPlan_WithProjectArgument">
    <Description>
        When true we will pass the project in to save unmanaged plan as an argument.
      </Description>
  </Variable>
  <Variable initializer="false" input="true" name="requireCommentsForApproval">
    <Description>When true we will require comments when an approval item is approved.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="requireCommentsForDenial">
    <Description>When true we will require comments when an approval item is denied.</Description>
  </Variable>
  <Description>Subprocess to approve and provision immediately. This is used after splitting an ApprovalSet into individual items to run in parallel.</Description>
  <RuleLibraries>
    <Reference class="sailpoint.object.Rule" name="LCM Workflow Library"/>
  </RuleLibraries>
  <Step icon="Start" name="Start" posX="20" posY="20">
    <Transition to="Compile Project"/>
  </Step>
  <Step action="call:compileProvisioningProject" condition="script:(!approvalScheme.equalsIgnoreCase(&quot;none&quot;) &amp;&amp; !isNull(approvalSplitPoint))" icon="Task" name="Compile Project" posX="120" posY="20" resultVariable="project">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="requester" value="ref:launcher"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
    <Arg name="disableRetryRequest" value="!ref:enableRetryRequest"/>
    <Arg name="noApplicationTemplates">
      <Script>
        <Source>
                    boolean ignoreForms = false;
                    if ("ForgotPassword".equals(flow) || "ExpirePassword".equals(flow)) {
                    ignoreForms = true;
                    }
                    return ignoreForms;
                </Source>
      </Script>
    </Arg>
    <Transition to="Build Approval Set"/>
  </Step>
  <Step action="call:buildSplitApprovalSet" condition="script:(!approvalScheme.equalsIgnoreCase(&quot;none&quot;) &amp;&amp; !isNull(approvalSplitPoint))" icon="Task" name="Build Approval Set" posX="220" posY="20" resultVariable="approvalSet">
    <Arg name="plan" value="ref:plan"/>
    <Return name="approvalSet" to="approvalSet"/>
    <Transition to="Approve"/>
  </Step>
  <Step condition="script:((flow == null) ||  (!&quot;UnlockAccount&quot;.equals(flow)))" configForm="Provisioning Approval Step Form" icon="Approval" name="Approve" posX="320" posY="20">
    <Arg name="approvalMode" value="ref:approvalMode"/>
    <Arg name="approvalScheme" value="ref:approvalScheme"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
    <Arg name="approvalAssignmentRule"/>
    <Arg name="approvingIdentities"/>
    <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
    <Arg name="filterRejects" value="ref:filterRejects"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="identityElectronicSignature"/>
    <Arg name="identityEmailTemplate"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="launcher" value="ref:launcher"/>
    <Arg name="managerEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Arg name="managerElectronicSignature" value="ref:managerElectronicSignature"/>
    <Arg name="ownerEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Arg name="ownerElectronicSignature" value="ref:ownerElectronicSignature"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="policyViolations" value="ref:policyViolations"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
    <Arg name="securityOfficerEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Arg name="securityOfficerElectronicSignature" value="ref:securityOfficerElectronicSignature"/>
    <Arg name="setPreviousApprovalDecisions" value="ref:setPreviousApprovalDecisions"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="workItemReminderTemplate"/>
    <Arg name="workItemHoursBetweenReminders"/>
    <Arg name="workItemMaxReminders"/>
    <Arg name="workItemEscalationTemplate"/>
    <Arg name="workItemHoursTillEscalation"/>
    <Arg name="workItemEscalationRule"/>
    <Arg name="workItemComments"/>
    <Arg name="clearApprovalDecisions" value="script:(!isNull(approvalSplitPoint) &amp;&amp; csvToList(approvalScheme).contains(approvalSplitPoint))"/>
    <Return name="approvalSet"/>
    <Return name="workItemComments"/>
    <Return name="project"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Provisioning Approval Subprocess"/>
    </WorkflowRef>
    <Transition to="Update Ticket Post Approval"/>
  </Step>
  <Step condition="script:(ticketManagementApplication != null)" icon="Task" name="Update Ticket Post Approval" posX="470" posY="20">
    <Arg name="action" value="postApproval"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="ticketDataGenerationRule" value=""/>
    <Arg name="trace" value="ref:trace"/>
    <Description>
            Call a subprocess to update the ticket in the ticketManagementApplication is non-null.

            You can specify a specific 'ticketDataGenerationRule' here or you can also specify
            it on the application.  It'll be read from the argument first and fall back to the '
            application config.

        </Description>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Manage Ticket"/>
    </WorkflowRef>
    <Transition to="Provision"/>
  </Step>
  <Step icon="Provision" name="Provision" posX="600" posY="20">
    <Arg name="approvalScheme" value="ref:approvalScheme"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
    <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
    <Arg name="formTemplate" value="Identity Update"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="launcher" value="ref:launcher"/>
    <Arg name="manualActionsEmailTemplate" value="Pending Manual Changes"/>
    <Arg name="noTriggers" value="ref:noTriggers"/>
    <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
    <Arg name="policyViolations" value="ref:policyViolations"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="policyScheme" value="ref:policyScheme"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="workItemComments" value="ref:workItemComments"/>
    <Arg name="splitProvisioning" value="ref:splitProvisioning"/>
    <Arg name="saveUnmanagedPlan_WithProjectArgument" value="ref:saveUnmanagedPlan_WithProjectArgument"/>
    <Description>
            Call the standard subprocess that will process the
            approval decisions and do provisioning.  This
            includes calling any configured provisioning
            connectors and building manual actions.
        </Description>
    <Return name="project" to="project"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Identity Request Provision"/>
    </WorkflowRef>
    <Transition to="Update Ticket Post Provision"/>
  </Step>
  <Step condition="script:(ticketManagementApplication != null)" icon="Task" name="Update Ticket Post Provision" posX="700" posY="20">
    <Arg name="action" value="postProvisioning"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="ticketDataGenerationRule" value=""/>
    <Arg name="trace" value="ref:trace"/>
    <Description>
            Call a subprocess to update the ticket in the ticketManagementApplication is non-null.

            You can specify a specific 'ticketDataGenerationRule' here or you can also specify
            it on the application.  It'll be read from the argument first and fall back to the '
            application config.

        </Description>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Manage Ticket"/>
    </WorkflowRef>
  </Step>
</Workflow>
<Workflow configForm="Provisioning Workflow Config Form" explicitTransitions="true" handler="sailpoint.api.StandardWorkflowHandler" libraries="Identity,Role,PolicyViolation,LCM,BatchRequest" name="LCM Provisioning" taskType="LCM" type="LCMProvisioning">
  <Variable input="true" name="identityName">
    <Description>The name of the identity being updated.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="endOnManualWorkItems">
    <Description>Option to skip requests with manual work items.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="endOnProvisioningForms">
    <Description>Option to skip requests with provisioning forms.</Description>
  </Variable>
  <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
    <Description>The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.</Description>
  </Variable>
  <Variable input="true" name="plan">
    <Description>The provisioning plan ready to execute.</Description>
  </Variable>
  <Variable input="true" name="flow">
    <Description>The name of the LCM flow that launched this workflow.

      This is one of these three values:

      AccountsRequest
      EntitlementsRequest
      RolesRequest
      AttributeSync</Description>
  </Variable>
  <Variable editable="true" initializer="false" name="optimisticProvisioning">
    <Description>Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.</Description>
  </Variable>
  <Variable editable="true" initializer="true" name="foregroundProvisioning">
    <Description>Normally provisioning is done in a step that uses the &amp;quot;background&amp;quot;
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to
      see the results of the request.</Description>
  </Variable>
  <Variable input="true" name="batchRequestItemId">
    <Description>Used by the batch interface to record back individual request item status. The specific item id for the individual request in the batch file.</Description>
  </Variable>
  <Variable editable="true" initializer="false" name="doRefresh">
    <Description>Set to true to cause an identity refresh after the changes in the plan
      have been provisioned.  This is normally off, you might want this on
      if you want modification of identity or link attributes to result in
      an immediate re-evaluation of assigned and detected roles.</Description>
  </Variable>
  <Variable initializer="manager, user" input="true" name="notificationScheme">
    <Description>A string that specifies who should be notified when the request has been complete.
     The value can be null or a csv of one or more of the following options.

     none or null
       disable notifications

     user
       Identity that is being update will be notified.

     manager
       The manager of the Identity that is being updated will be notified.

     requester
       The person that has requested the update will be notified.</Description>
  </Variable>
  <Variable initializer="LCM User Notification" input="true" name="userEmailTemplate">
    <Description>The email template to use for user notification.</Description>
  </Variable>
  <Variable initializer="LCM Requester Notification" input="true" name="requesterEmailTemplate">
    <Description>The email template to use for requester notification.</Description>
  </Variable>
  <Variable initializer="LCM Manager Notification" input="true" name="managerEmailTemplate">
    <Description>The email template to use for manager notification.</Description>
  </Variable>
  <Variable input="true" name="securityOfficerEmailTemplate">
    <Description>The email template to use for security officer notification.</Description>
  </Variable>
  <Variable initializer="parallel" input="true" name="approvalMode">
    <Description>A string that specifies how we should handle the approvals.

        By default this is serial since most of these request with
        the exception of manager transfers will have only one approver.

        parallel
        Approvals are processed concurrently and there must be consensus,
        we wait for all approvers to approve.  The first approver that
        rejects terminates the entire approval.

        parallelPoll
        Approvals are processed concurrently but consensus is not required.
        All approvals will be processed, we don&amp;#39;t stop if there are any
        rejections.

        serial
        Approvals are processed one at a time and there must be consensus.
        The first approver that rejects terminates the entire approval.

        serialPoll
        Approvals are processed in order but consensus is not required.
        All approvals will be processed, we don&amp;#39;t stop if there are any
        rejections.  In effect we are &amp;quot;taking a poll&amp;quot; of the approvers.

        any
        Approvals are processed concurrently, the first approver to
        respond makes the decision for the group.</Description>
  </Variable>
  <Variable initializer="manager, owner" input="true" name="approvalScheme">
    <Description>A csv string that specifies how approval items should be generated
      for the incoming request.

      The value can be &amp;quot;none&amp;quot;, in which case approvals are disabled.

      The value can also be a combination of any of the values below
      in any order, separated by commas. The order in which they are
      specified is the order in which they are processed:

      owner
        The object owner gets the approval item.
        For Role approvals this is the Role object owner.
        For Entitlement approvals this is the Entitlement object owner.

      manager
        The manager gets the approval item.

      securityOfficer
        The identity in the variable securityOfficerName gets the approval item.

      identity
        The identities/workgroups in the variable approvingIdentities get the approval item.</Description>
  </Variable>
  <Variable initializer="LCM Identity Update Approval" input="true" name="approvalEmailTemplate">
    <Description>The email template to use for approval notifications.</Description>
  </Variable>
  <Variable initializer="Normal" input="true" name="workItemPriority">
    <Description>The String version of a WorkItem.Priority. This variable is
       used to set the priority on all of the workitems generated
       as part of this workflow and also set on the IdentityRequest
       object.</Description>
  </Variable>
  <Variable input="true" name="securityOfficerName">
    <Description>The name of the identity that will be sent approvals
       during security officer approvals.</Description>
  </Variable>
  <Variable initializer="spadmin" input="true" name="fallbackApprover">
    <Description>A String that specifies the name of the Identity that will
      be assigned any approvals where the owner of the approver
      can&amp;#39;t be resolved. Example if the scheme is &amp;quot;owner&amp;quot; and the
      application doesn&amp;#39;t specify and owner.</Description>
  </Variable>
  <Variable initializer="continue" input="true" name="policyScheme">
    <Description>A String that specifies how policy checks effect the overall
      process.

      none - disabled policy checking

      continue -  continue if policy violations are found

      interactive -  allow requester to remove request items which are causing violations

      fail -  this option will cause the workflow to terminate immediately if any policy violations are found.
              Note that the requester will not be notified that the workflow has terminated.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="enableRetryRequest">
    <Description>When set to true it will disable the workflow retry loop and let the
      Provision step launch requests to handle the retries.  Enabling
      this flag will enable some older functionality.</Description>
  </Variable>
  <Variable input="true" name="policiesToCheck">
    <Description>A List of policies that should be checked. If this list is
      empty all violations will be checked. Used in combination
      with policyScheme.</Description>
  </Variable>
  <Variable initializer="LCM" input="true" name="source">
    <Description>String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.</Description>
  </Variable>
  <Variable initializer="false" name="trace">
    <Description>Used for debugging this workflow and when set to true trace
      will be sent to stdout.</Description>
  </Variable>
  <Variable name="approvalSet">
    <Description>This attributes is set during the &amp;quot;Build Approval Set&amp;quot; step,
       which builds this list by going through the ProvisioningPlan
       to build the line items that need to be approved,

       This variable includes all ApprovalItems that are part of
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions
       and comments from the Approvals copy of the ApprovalItem.</Description>
  </Variable>
  <Variable initializer="true" name="allowRequestsWithViolations">
    <Description>If this variable is set to true, requesters will be able to proceed past
      the Policy Violation Review form without taking any action on
      policy violations resulting from the request. This is only relevant
      if policyScheme=interactive.</Description>
  </Variable>
  <Variable initializer="true" name="requireViolationReviewComments">
    <Description>If true, requesters will be required to enter in comments if they
      proceed with a request that will result in policy violations. This
      is only relevant if policyScheme=interactive.</Description>
  </Variable>
  <Variable name="project">
    <Description>ProvisioningProject which is just a compiled version of the ProvisioningPlan.</Description>
  </Variable>
  <Variable name="policyViolations">
    <Description>List of policy violations that were found during our initial policy scan.
       This list is passed into each work item so the approvers can see
       pending violations.</Description>
  </Variable>
  <Variable name="identityRequestId" output="true">
    <Description>The sequence id of the Identity request object which is stored in
       the name field of the identity request and auto-incremented.</Description>
  </Variable>
  <Variable name="violationReviewDecision">
    <Description>Decision made by the user in the Policy Violation Review step.
       This may be one of three choices:

       -ignore:   User is ignoring the violations and letting the request continue. If
                   requireViolationReviewComments=true the user will be required to enter
                   comments indicating why they are allowing the violations.

       -remediate: Indicates that the user removed the request items that were causing the
                   violations

       -cancel:   Indicates that the user decided to abandon the request, terminating the workflow.</Description>
  </Variable>
  <Variable name="workItemComments">
    <Description>Global comments accumulated during the workflow which should be shared
      with other approvals. When a new approval is created, the comments in this
      list will be added to the work item.</Description>
  </Variable>
  <Variable input="true" name="ticketManagementApplication">
    <Description>Name of the application that can handle ticket requests.
      When non-null the Manage Ticket Steps will be visited to open
      tickets during the workflow lifecycle.</Description>
  </Variable>
  <Variable name="ticketId">
    <Description>The id of the ticket that is generated by the ticketingManagementApplication.
      This is typically generated on the &amp;quot;open&amp;quot; call, and then used in subsequent
      calls.  It is also stored on the IdentityRequest object under the
      externalTicketId variable.</Description>
  </Variable>
  <Variable input="true" name="managerElectronicSignature">
    <Description>The name of the electronic signature object that should be used when workitems
       are completed by a manager.</Description>
  </Variable>
  <Variable input="true" name="ownerElectronicSignature">
    <Description>The name of the electronic signature object that should be used when workitems
       are completed by object owners.</Description>
  </Variable>
  <Variable input="true" name="securityOfficerElectronicSignature">
    <Description>The name of the electronic signature object that should be used when workitems
       are completed by the security officer.</Description>
  </Variable>
  <Variable input="true" name="approvingIdentities">
    <Description>List of identities and/or workgroups names/ids that should be involved in the approval
      process.</Description>
  </Variable>
  <Variable input="true" name="identityElectronicSignature">
    <Description>The name of the electronic signature object that should be used when workitems
      are completed by identities and/or workgroups.</Description>
  </Variable>
  <Variable input="true" name="identityEmailTemplate">
    <Description>Name of the email template to use when notifying the identities/workgroups of pending approvals.</Description>
  </Variable>
  <Variable initializer="true" input="true" name="filterRejects">
    <Description>True to filter rejected items when running in Serial/SerialPoll mode.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="setPreviousApprovalDecisions">
    <Description>True to pre-populate approval decisions from previous approvals.</Description>
  </Variable>
  <Variable name="approvalSplitPoint">
    <Description>Variable to determine when to split into parallel processing.
          This should map to a configured approvalScheme. We will process all schemes up until
          the approvalSplitPoint in the Pre Split approvals, and the remaining schemes after
          we split the items. If this is not specified, we will not split the Provisioning
          project, and process the entire project as a whole.</Description>
  </Variable>
  <Variable name="splitPlans">
    <Description>List of ProvisioningPlan that is generated from the splitPlans step if approvalSplitPoint is set.</Description>
  </Variable>
  <Variable name="splitProjects">
    <Description>Variable to store the returns if approvalSplitPoint is set. This will contain a List&amp;lt;ProvisioningProject&amp;gt;</Description>
  </Variable>
  <Variable name="splitApprovalSet">
    <Description>Variable to store the list of approvalSets returned from the split subprocess if approvalSplitPoint is set.</Description>
  </Variable>
  <Variable name="splitWorkItemComments">
    <Description>Variable to store the list of WorkItem comments returned from the split subprocess if approvalSplitPoint is set.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="saveUnmanagedPlan_WithProjectArgument">
    <Description>When true we will pass the project in to save unmanaged plan as an argument.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="requireCommentsForApproval">
    <Description>When true we will require comments when an approval item is approved.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="requireCommentsForDenial">
    <Description>When true we will require comments when an approval item is denied.</Description>
  </Variable>
  <RuleLibraries>
    <Reference class="sailpoint.object.Rule" name="LCM Workflow Library"/>
  </RuleLibraries>
  <Step icon="Start" name="Start" posX="25" posY="10">
    <Transition to="Initialize"/>
  </Step>
  <Step icon="Task" name="Initialize" posX="134" posY="10">
    <Arg name="formTemplate" value="Identity Update"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="enableRetryRequest" value="ref:enableRetryRequest"/>
    <Arg name="allowRequestsWithViolations" value="ref:allowRequestsWithViolations"/>
    <Arg name="endOnManualWorkItems" value="ref:endOnManualWorkItems"/>
    <Arg name="policiesToCheck" value="ref:policiesToCheck"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="policyScheme" value="ref:policyScheme"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="requireViolationReviewComments" value="ref:requireViolationReviewComments"/>
    <Arg name="identityRequest"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="batchRequestItemId" value="ref:batchRequestItemId"/>
    <Arg name="enableApprovalRecommendations"/>
    <Arg name="asyncCacheRefresh"/>
    <Arg name="endOnProvisioningForms" value="ref:endOnProvisioningForms"/>
    <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="launcher" value="ref:launcher"/>
    <Description>
      Call the standard subprocess to initialize the request, this includes
      auditing, building the approvalset, compiling the plan into
       project and checking policy violations.
    </Description>
    <Return name="project" to="project"/>
    <Return name="approvalSet" to="approvalSet"/>
    <Return name="policyViolations" to="policyViolations"/>
    <Return name="identityRequestId" to="identityRequestId"/>
    <Return name="violationReviewDecision" to="violationReviewDecision"/>
    <Return merge="true" name="workItemComments" to="workItemComments"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Identity Request Initialize"/>
    </WorkflowRef>
    <Transition to="Exit On Manual Work Items" when="script:(isTrue(endOnManualWorkItems) &amp;&amp; (project.getUnmanagedPlan() != null))"/>
    <Transition to="Exit On Provisioning Form" when="script:(isTrue(endOnProvisioningForms) &amp;&amp; (project.hasQuestions()))"/>
    <Transition to="Exit On Policy Violation">
      <Script>
        <Source>("cancel".equals(violationReviewDecision) || ((size(policyViolations) &gt; 0 ) &amp;&amp; (policyScheme.equals("fail"))))</Source>
      </Script>
    </Transition>
    <Transition to="Create Ticket"/>
  </Step>
  <Step condition="script:(ticketManagementApplication != null)" icon="Task" name="Create Ticket" posX="381" posY="6">
    <Arg name="trace" value="ref:trace"/>
    <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="action" value="open"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="ticketProject"/>
    <Arg name="ticketId" value="ref:ticketId"/>
    <Arg name="ticketDataGenerationRule"/>
    <Arg name="ticketPlan"/>
    <Description>
      Call a subprocess to create a ticket in the ticketManagementApplication is non-null.
      You can specify a specific 'ticketDataGenerationRule' here or you can also specify
      it on the application.  It'll be read from the argument first and fall back to the '
      application config.
    </Description>
    <Return name="ticketId" to="externalTicketId"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Manage Ticket"/>
    </WorkflowRef>
    <Transition to="Pre Split Approve" when="script:(!isNull(approvalSplitPoint) &amp;&amp; csvToList(approvalScheme).contains(approvalSplitPoint))"/>
    <Transition to="Approve and Provision"/>
  </Step>
  <Step condition="script:((flow == null) ||  (!&quot;UnlockAccount&quot;.equals(flow)))" icon="Task" name="Pre Split Approve" posX="518" posY="63">
    <Arg name="approvalScheme">
      <Script>
        <Source>
              import java.util.List;
              import java.util.ArrayList;
              import java.util.Iterator;
              import sailpoint.tools.Util;

              List schemes = Util.csvToList(approvalScheme);
              List preSchemes = new ArrayList&lt;String&gt;();
              for (String s : Util.safeIterable(schemes)) {
                if (s.equals(approvalSplitPoint)) {
                    break;
                } else {
                    preSchemes.add(s);
                }
              }
              return Util.listToCsv(preSchemes);
          </Source>
      </Script>
    </Arg>
    <Arg name="identityEmailTemplate" value="ref:identityEmailTemplate"/>
    <Arg name="securityOfficerElectronicSignature" value="ref:securityOfficerElectronicSignature"/>
    <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
    <Arg name="workItemHoursBetweenReminders"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="workItemComments"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
    <Arg name="managerElectronicSignature" value="ref:managerElectronicSignature"/>
    <Arg name="workItemDescription"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="ownerElectronicSignature" value="ref:ownerElectronicSignature"/>
    <Arg name="approvalMode" value="ref:approvalMode"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="dontUpdatePlan"/>
    <Arg name="workItemEscalationRule"/>
    <Arg name="approvalAssignmentRule"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="requireCommentsForApproval" value="ref:requireCommentsForApproval"/>
    <Arg name="identityElectronicSignature" value="ref:identityElectronicSignature"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="policyViolations" value="ref:policyViolations"/>
    <Arg name="ownerEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Arg name="filterRejects" value="ref:filterRejects"/>
    <Arg name="workItemReminderTemplate"/>
    <Arg name="workItemEscalationTemplate"/>
    <Arg name="setPreviousApprovalDecisions" value="ref:setPreviousApprovalDecisions"/>
    <Arg name="clearApprovalDecisions"/>
    <Arg name="noTriggers"/>
    <Arg name="workItemMaxReminders"/>
    <Arg name="requireCommentsForDenial" value="ref:requireCommentsForDenial"/>
    <Arg name="approvingIdentities" value="ref:approvingIdentities"/>
    <Arg name="securityOfficerEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
    <Arg name="workItemHoursTillEscalation"/>
    <Arg name="managerEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Arg name="launcher" value="ref:launcher"/>
    <Description>
      Call to our standard subprocess to handle the default approvals for
      manager, owner and security officer.
    </Description>
    <Return name="approvalSet"/>
    <Return name="workItemComments"/>
    <Return name="project"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Provisioning Approval Subprocess"/>
    </WorkflowRef>
    <Transition to="Split Plan"/>
  </Step>
  <Step action="call:splitProvisioningPlan" icon="Task" name="Split Plan" posX="618" posY="63" resultVariable="splitPlans">
    <Arg name="project" value="ref:project"/>
    <Description>
          Step to split the provisioning project into individual projects for each item requested.
          This will only run if the approvalSplitPoint is configured.
      </Description>
    <Transition to="Approve and Provision Split"/>
  </Step>
  <Step icon="Task" name="Approve and Provision Split" posX="783" posY="63">
    <Arg name="formTemplate" value="Identity Update"/>
    <Arg name="identityEmailTemplate" value="ref:identityEmailTemplate"/>
    <Arg name="enableRetryRequest" value="ref:enableRetryRequest"/>
    <Arg name="securityOfficerElectronicSignature" value="ref:securityOfficerElectronicSignature"/>
    <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
    <Arg name="endOnManualWorkItems" value="ref:endOnManualWorkItems"/>
    <Arg name="userEmailTemplate" value="ref:userEmailTemplate"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="workItemComments" value="ref:workItemComments"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
    <Arg name="ownerElectronicSignature" value="ref:ownerElectronicSignature"/>
    <Arg name="batchRequestItemId" value="ref:batchRequestItemId"/>
    <Arg name="saveUnmanagedPlan_WithProjectArgument" value="ref:saveUnmanagedPlan_WithProjectArgument"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="identityElectronicSignature" value="ref:identityElectronicSignature"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="filterRejects" value="ref:filterRejects"/>
    <Arg name="ownerEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Arg name="splitProvisioning" value="true"/>
    <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
    <Arg name="clearApprovalDecisions"/>
    <Arg name="noTriggers"/>
    <Arg name="requireCommentsForDenial" value="ref:requireCommentsForDenial"/>
    <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
    <Arg name="requesterEmailTemplate" value="ref:requesterEmailTemplate"/>
    <Arg name="approvalEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
    <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
    <Arg name="approvingIdentities" value="ref:approvingIdentities"/>
    <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
    <Arg name="managerEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Arg name="launcher" value="ref:launcher"/>
    <Arg name="approvalScheme">
      <Script>
        <Source>
              import java.util.List;
              import java.util.Iterator;
              import sailpoint.tools.Util;
              List schemes = Util.csvToList(approvalScheme);
              Iterator it = schemes.iterator();
              while (it.hasNext()) {
                String s = it.next();
                if (!s.equals(approvalSplitPoint)) {
                    it.remove();
                } else {
                    break;
                }
              }
              return Util.listToCsv(schemes);
            </Source>
      </Script>
    </Arg>
    <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="managerElectronicSignature" value="ref:managerElectronicSignature"/>
    <Arg name="approvalMode" value="ref:approvalMode"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
    <Arg name="endOnProvisioningForms" value="ref:endOnProvisioningForms"/>
    <Arg name="approvalAssignmentRule"/>
    <Arg name="requireCommentsForApproval" value="ref:requireCommentsForApproval"/>
    <Arg name="manualActionsEmailTemplate" value="Pending Manual Changes"/>
    <Arg name="policyViolations" value="ref:policyViolations"/>
    <Arg name="policyScheme" value="ref:policyScheme"/>
    <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
    <Arg name="setPreviousApprovalDecisions" value="ref:setPreviousApprovalDecisions"/>
    <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
    <Arg name="securityOfficerEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Description>
          Call the Approve and Provision Subprocess for each Provisioning Project generated in the Split Plan step.
      </Description>
    <Replicator arg="plan" items="splitPlans"/>
    <Return name="project" to="splitProjects"/>
    <Return name="workItemComments" to="splitWorkItemComments"/>
    <Return name="approvalSet" to="splitApprovalSet"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Approve and Provision Subprocess"/>
    </WorkflowRef>
    <Transition to="Assimilate Splits"/>
  </Step>
  <Step action="call:joinLCMProvWorkflowSplits" icon="Task" name="Assimilate Splits" posX="914" posY="63">
    <Arg name="splitProjects" value="ref:splitProjects"/>
    <Arg name="splitApprovalSet" value="ref:splitApprovalSet"/>
    <Arg name="splitWorkItemComments" value="ref:splitWorkItemComments"/>
    <Description>
          Assimilate all projects returned from the split into the global project.
      </Description>
    <Transition to="Refresh Identity"/>
  </Step>
  <Step icon="Task" name="Approve and Provision" posX="699" posY="7">
    <Arg name="formTemplate" value="Identity Update"/>
    <Arg name="identityEmailTemplate" value="ref:identityEmailTemplate"/>
    <Arg name="enableRetryRequest" value="ref:enableRetryRequest"/>
    <Arg name="securityOfficerElectronicSignature" value="ref:securityOfficerElectronicSignature"/>
    <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
    <Arg name="endOnManualWorkItems" value="ref:endOnManualWorkItems"/>
    <Arg name="userEmailTemplate" value="ref:userEmailTemplate"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="workItemComments" value="ref:workItemComments"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
    <Arg name="ownerElectronicSignature" value="ref:ownerElectronicSignature"/>
    <Arg name="batchRequestItemId" value="ref:batchRequestItemId"/>
    <Arg name="saveUnmanagedPlan_WithProjectArgument" value="ref:saveUnmanagedPlan_WithProjectArgument"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="identityElectronicSignature" value="ref:identityElectronicSignature"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="filterRejects" value="ref:filterRejects"/>
    <Arg name="ownerEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Arg name="splitProvisioning" value="false"/>
    <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
    <Arg name="clearApprovalDecisions"/>
    <Arg name="noTriggers" value="ref:noTriggers"/>
    <Arg name="requireCommentsForDenial" value="ref:requireCommentsForDenial"/>
    <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
    <Arg name="requesterEmailTemplate" value="ref:requesterEmailTemplate"/>
    <Arg name="approvalEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
    <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
    <Arg name="approvingIdentities" value="ref:approvingIdentities"/>
    <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
    <Arg name="managerEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Arg name="launcher" value="ref:launcher"/>
    <Arg name="approvalScheme" value="ref:approvalScheme"/>
    <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="managerElectronicSignature" value="ref:managerElectronicSignature"/>
    <Arg name="approvalMode" value="ref:approvalMode"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
    <Arg name="endOnProvisioningForms" value="ref:endOnProvisioningForms"/>
    <Arg name="approvalAssignmentRule"/>
    <Arg name="requireCommentsForApproval" value="ref:requireCommentsForApproval"/>
    <Arg name="manualActionsEmailTemplate" value="Pending Manual Changes"/>
    <Arg name="policyViolations" value="ref:policyViolations"/>
    <Arg name="policyScheme" value="ref:policyScheme"/>
    <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
    <Arg name="setPreviousApprovalDecisions" value="ref:setPreviousApprovalDecisions"/>
    <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
    <Arg name="securityOfficerEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Description>
          Finish any remaining approvals and provision.
      </Description>
    <Return name="project" to="project"/>
    <Return name="approvalSet" to="approvalSet"/>
    <Return name="workItemComments" to="workItemComments"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Approve and Provision Subprocess"/>
    </WorkflowRef>
    <Transition to="Refresh Identity"/>
  </Step>
  <Step action="call:refreshIdentity" condition="ref:doRefresh" icon="Task" name="Refresh Identity" posX="1028" posY="7">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="correlateEntitlements" value="true"/>
    <Description>
      Add arguments as necessary to enable refresh features.  Typically you
      only want this to correlate roles.  Don't ask for provisioning  since that
      can result in provisioning policies that need to be presented and it's
      too late for that.  This is only to get role detection and exception
      entitlements in the cube.
    </Description>
    <Transition to="Notify"/>
  </Step>
  <Step icon="Task" name="Notify" posX="1131" posY="7">
    <Arg name="approvalScheme" value="ref:approvalScheme"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="notificationScheme" value="ref:notificationScheme"/>
    <Arg name="userEmailTemplate" value="ref:userEmailTemplate"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="policyViolations" value="ref:policyViolations"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="requesterEmailTemplate" value="ref:requesterEmailTemplate"/>
    <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
    <Arg name="securityOfficerEmailTemplate" value="ref:securityOfficerEmailTemplate"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="managerEmailTemplate" value="ref:managerEmailTemplate"/>
    <Arg name="launcher" value="ref:launcher"/>
    <Description>
      Call the standard subprocess that will notify the various
      actors based on notification scheme.
    </Description>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Identity Request Notify"/>
    </WorkflowRef>
    <Transition to="end"/>
  </Step>
  <Step action="call:addMessage" name="Exit On Policy Violation" posX="201" posY="253">
    <Arg name="message" value="Failed due to policy violation(s)"/>
    <Arg name="type" value="Error"/>
    <Transition to="end"/>
  </Step>
  <Step action="call:addMessage" name="Exit On Manual Work Items" posX="364" posY="107">
    <Arg name="message" value="Failed due to manual work item(s)"/>
    <Arg name="type" value="Error"/>
    <Transition to="end"/>
  </Step>
  <Step action="call:addMessage" name="Exit On Provisioning Form" posX="280" posY="178">
    <Arg name="message" value="Failed due to provisioning form"/>
    <Arg name="type" value="Error"/>
    <Transition to="end"/>
  </Step>
  <Step catches="complete" icon="Catches" name="Finalize" posX="1058" posY="308">
    <Arg name="trace" value="ref:trace"/>
    <Arg name="batchRequestItemId" value="ref:batchRequestItemId"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="autoVerifyIdentityRequest"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="ticketDataGenerationRule"/>
    <Description>
      Call the standard subprocess that can audit/finalize the request.
    </Description>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Identity Request Finalize"/>
    </WorkflowRef>
    <Transition to="end"/>
  </Step>
  <Step icon="Stop" name="end" posX="1131" posY="253"/>
</Workflow>
<Workflow configForm="Provisioning Workflow Config Form" handler="sailpoint.api.StandardWorkflowHandler" libraries="Identity,BatchRequest" name="LCM Create and Update" taskType="LCM" type="LCMIdentity">
  <Variable input="true" name="identityName">
    <Description>The name of the identity we're supposed to update.</Description>
  </Variable>
  <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
    <Description>
      The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.
    </Description>
  </Variable>
  <Variable initializer="false" input="true" name="endOnManualWorkItems">
    <Description>Option to skip requests with manual work items.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="endOnProvisioningForms">
    <Description>Option to skip requests with provisioning forms.</Description>
  </Variable>
  <Variable input="true" name="batchRequestItemId">
    <Description>
      Used by the batch interface to record back individual request item status. The specific item id for the individual request in the batch file.
    </Description>
  </Variable>
  <Variable input="true" name="plan">
    <Description>The provisioning plan ready to execute.</Description>
  </Variable>
  <Variable input="true" name="flow">
    <Description>
      The name of the LCM flow that launched this workflow.

      This is one of these two values:

      IdentityCreateRequest
      IdentityEditRequest
    </Description>
  </Variable>
  <Variable editable="true" name="optimisticProvisioning">
    <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
  </Variable>
  <Variable editable="true" initializer="true" name="foregroundProvisioning">
    <Description>
      Normally provisioning is done in a step that uses the "background"
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to
      see the results of the request.
    </Description>
  </Variable>
  <Variable editable="true" name="doRefresh">
    <Description>
      Set to true to cause an identity refresh after the changes in the plan
      have been provisioned.  This is normally off, you might want this on
      if you want modification of identity or link attributes to result in
      an immediate re-evaluation of assigned and detected roles.
    </Description>
  </Variable>
  <Variable initializer="Normal" input="true" name="workItemPriority">
    <Description>
       The String version of a WorkItem.Priority. This variable is
       used to set the priority on all of the workitems generated
       as part of this workflow and also set on the IdentityRequest
       object.
    </Description>
  </Variable>
  <Variable initializer="user,requester" input="true" name="notificationScheme">
    <Description>
     A string that specifies who should be notified when the request has been complete.
     The value can be null or a csv of one or more of the following options.

     none or null
       disable notifications

     user
       Identity that is being update will be notified.

     manager
       The manager of the Identity that is being updated will be notified.

     requester
       The person that has requested the update will be notified.
    </Description>
  </Variable>
  <Variable initializer="LCM User Notification" input="true" name="userEmailTemplate">
    <Description>
     The email template to use for user notification.
    </Description>
  </Variable>
  <Variable initializer="LCM Requester Notification" input="true" name="requesterEmailTemplate">
    <Description>
     The email template to use for requester notification.
    </Description>
  </Variable>
  <Variable initializer="LCM Manager Notification" input="true" name="managerEmailTemplate">
    <Description>
     The email template to use for manager notification.
    </Description>
  </Variable>
  <Variable input="true" name="securityOfficerEmailTemplate">
    <Description>
     The email template to use for security officer notification.
    </Description>
  </Variable>
  <Variable initializer="serial" input="true" name="approvalMode">
    <Description>
     A string that specifies how we should handle the approvals.

     By default this is serial since most of these request with
     the exception of manager transfers will have only one approver.

     parallel
       Approvals are processed concurrently and there must be consensus,
       we wait for all approvers to approve.  The first approver that
       rejects terminates the entire approval.

     parallelPoll
       Approvals are processed concurrently but consensus is not required.
       All approvals will be processed, we don't stop if there are any
       rejections.

     serial
       Approvals are processed one at a time and there must be consensus.
       The first approver that rejects terminates the entire approval.

     serialPoll
       Approvals are processed in order but consensus is not required.
       All approvals will be processed, we don't stop if there are any
       rejections.  In effect we are "taking a poll" of the approvers.

     any
      Approvals are processed concurrently, the first approver to
      respond makes the decision for the group.
    </Description>
  </Variable>
  <Variable initializer="manager, newManager" input="true" name="approvalScheme">
    <Description>
      A String that specifies how approvals should be generated for
      this workflow there are three built-in modes

      none - disabled approvals

      manager - The user's current manager will get approvals

      newManager - The newly assigned manager will get approvals when
                   manager transfers occur. Otherwise the user's manager
                   current manager will be the approver.
    </Description>
  </Variable>
  <Variable initializer="spadmin" input="true" name="fallbackApprover">
    <Description>
      A String that specifies the name of the Identity that will
      be assigned any approvals where the owner of the approver
      can't be resolved. Example if the scheme is "owner" and the
      application doesn't specify and owner.
    </Description>
  </Variable>
  <Variable initializer="LCM Identity Update Approval" input="true" name="approvalEmailTemplate">
    <Description>
     The email template to use for approval notifications.
    </Description>
  </Variable>
  <Variable input="true" name="securityOfficerName">
    <Description>
       The name of the identity that will be sent approvals
       during security officer approvals.
    </Description>
  </Variable>
  <Variable initializer="continue" input="true" name="policyScheme">
    <Description>
      A String that specifies how policy checks effect the overall
      process.

      none - disabled policy checking

      fail -  fail and exit the workflow if any policy violations are found

      continue -  continue if policy violations are found
    </Description>
  </Variable>
  <Variable input="true" name="ticketManagementApplication">
    <Description>
      Name of the application that can handle ticket requests.
      When non-null the Manage Ticket Steps will be visited to open
      tickets during the workflow lifecycle.
    </Description>
  </Variable>
  <Variable name="ticketId">
    <Description>
      The id of the ticket that is generated by the ticketingManagementApplication.
      This is typically generated on the "open" call, and then used in subsequent
      calls.  It is also stored on the IdentityRequest object under the
      externalTicketId variable.
    </Description>
  </Variable>
  <Variable input="true" name="policiesToCheck">
    <Description>
      A List of policies that should be checked. If this list is
      empty all violations will be checked. Used in combination
      with policyScheme.
    </Description>
  </Variable>
  <Variable name="policyViolations">
    <Description>
       List of policy violations that were found during our initial policy scan.
       This list is passed into each work item so the approvers can see
       pending violations.
    </Description>
  </Variable>
  <Variable initializer="LCM" input="true" name="source">
    <Description>
      String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.
    </Description>
  </Variable>
  <Variable name="approvalSet">
    <Description>
       This attributes is set during the "Build Approval Set" step,
       which builds this list by going through the ProvisioningPlan
       to build the line items that need to be approved,

       This variable includes all ApprovalItems that are part of
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
  </Variable>
  <Variable initializer="false" name="trace">
    <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
  </Variable>
  <Variable name="project">
    <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan.
    </Description>
  </Variable>
  <Variable name="approvalForm">
    <Description>
       The form that is generated based on the changes that were made.  This
       form will be sent into the workitem and allow editing of the
       requested values during the approval process. This is generated
       in "Build Approval Form" based on the passed-in plan.
    </Description>
  </Variable>
  <Variable name="identityRequestId" output="true">
    <Description>
       The sequence id of the Identity request object which is stored in
       the name field of the identity request.
    </Description>
  </Variable>
  <Variable input="true" name="approverElectronicSignature">
    <Description>
       The name of the electronic signature object that should be used when workitems
       are completed by the batch approver when performing batch operations.
    </Description>
  </Variable>
  <RuleLibraries>
    <Reference class="sailpoint.object.Rule" name="Approval Library"/>
    <Reference class="sailpoint.object.Rule" name="LCM Workflow Library"/>
  </RuleLibraries>
  <Step icon="Start" name="Start" posX="14" posY="12">
    <Transition to="Build Approval Set"/>
  </Step>
  <Step action="rule:LCM Build Identity ApprovalSet" icon="Task" name="Build Approval Set" posX="98" posY="12" resultVariable="approvalSet">
    <Description>
       The rule will go through the plan and build an approvalItem for each AccountRequest,
       typically there is just one for the IIQ application requests.

       The rule will also annotate the plan with the previousValues so that they
       can be assimilated onto the Form that is build, which is used during the approval
       process for edits.

       Because this has some special handling keep it here in the workflow
       and pass the approval set into the initialization process.
    </Description>
    <Transition to="Initialize"/>
  </Step>
  <Step icon="Task" name="Initialize" posX="183" posY="12">
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="launcher" value="ref:launcher"/>
    <Arg name="optimisticProvisioning" value="false"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="policiesToCheck" value="ref:policiesToCheck"/>
    <Arg name="policyScheme" value="ref:policyScheme"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="batchRequestItemId" value="ref:batchRequestItemId"/>
    <Arg name="endOnProvisioningForms" value="ref:endOnProvisioningForms"/>
    <Arg name="endOnManualWorkItems" value="ref:endOnManualWorkItems"/>
    <Description>
      Call the standard subprocess to initialize the request, this includes
      auditing, building the approvalset, compiling the plan into
      a project and checking policy violations.
    </Description>
    <Return name="policyViolations" to="policyViolations"/>
    <Return name="identityRequestId" to="identityRequestId"/>
    <Return name="project" to="project"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Identity Request Initialize"/>
    </WorkflowRef>
    <Transition to="Exit On Manual Work Items" when="script:(isTrue(endOnManualWorkItems) &amp;&amp; (project.getUnmanagedPlan() != null))"/>
    <Transition to="Exit On Provisioning Form" when="script:(isTrue(endOnProvisioningForms) &amp;&amp; (project.hasQuestions()))"/>
    <Transition to="Exit On Policy Violation" when="script:((size(policyViolations) &gt; 0 ) &amp;&amp; (policyScheme.equals(&quot;fail&quot;)))"/>
    <Transition to="Create Ticket"/>
  </Step>
  <Step condition="script:(ticketManagementApplication != null)" icon="Task" name="Create Ticket" posX="403" posY="8">
    <Arg name="action" value="open"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="ticketDataGenerationRule" value=""/>
    <Arg name="trace" value="ref:trace"/>
    <Description>
      Call a subprocess to create a ticket in the ticketManagementApplication is non-null.
      You can specify a specific 'ticketDataGenerationRule' here or you can also specify
      it on the application.  It'll be read from the argument first and fall back to the '
      application config.
    </Description>
    <Return name="ticketId" to="externalTicketId"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Manage Ticket"/>
    </WorkflowRef>
    <Transition to="Approve"/>
  </Step>
  <Step icon="Task" name="Approve" posX="488" posY="8">
    <Arg name="approvalMode" value="ref:approvalMode"/>
    <Arg name="approvalScheme" value="ref:approvalScheme"/>
    <Arg name="requireCommentsForApproval" value="ref:requireCommentsForApproval"/>
    <Arg name="requireCommentsForDenial" value="ref:requireCommentsForDenial"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="approvalEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Arg name="approverElectronicSignature" value="ref:approverElectronicSignature"/>
    <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
    <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="launcher" value="ref:launcher"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="policyViolations" value="ref:policyViolations"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="workItemComments"/>
    <Description>
      Call the standard subprocess that will handle the built-in
      owner, manager and security officer approval schemes.
    </Description>
    <Return name="approvalSet"/>
    <Return name="plan"/>
    <Return name="workItemComments"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Identity Request Approve Identity Changes"/>
    </WorkflowRef>
    <Transition to="Update Ticket Post Approval"/>
  </Step>
  <Step condition="script:(ticketManagementApplication != null)" icon="Task" name="Update Ticket Post Approval" posX="599" posY="8">
    <Arg name="action" value="postApproval"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="ticketDataGenerationRule" value=""/>
    <Arg name="trace" value="ref:trace"/>
    <Description>
      Call a subprocess to update the ticket in the ticketManagementApplication is non-null.

      You can specify a specific 'ticketDataGenerationRule' here or you can also specify
      it on the application.  It'll be read from the argument first and fall back to the '
      application config.

    </Description>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Manage Ticket"/>
    </WorkflowRef>
    <Transition to="Process Approval Decisions"/>
  </Step>
  <Step action="call:processPlanApprovalDecisions" icon="Task" name="Process Approval Decisions" posX="764" posY="9" resultVariable="plan">
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="disableAudit" value="true"/>
    <Transition to="Notify" when="script:approvalSet.hasRejected()"/>
    <Transition to="Recompile Project"/>
  </Step>
  <Step action="call:recompileProvisioningProject" icon="Task" name="Recompile Project" posX="913" posY="5" resultVariable="project">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="requester" value="ref:launcher"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
    <Description>Recompile the provisioning project with the plan.
      The plan may contain modifications from the original plan if
      it was modified during the approval process.
      If you need to pass in provisioner options like "noFiltering"
      or "noRoleDeprovisioning" you must pass them as explicit
      arguments to the call.

      The evaluation options "requester" and "source" are commonly
      set here.

      You can also pass things into the Template and Field scripts by
      defining Args in this step.</Description>
    <Transition to="Provision"/>
  </Step>
  <Step icon="Task" name="Provision" posX="1014" posY="6">
    <Arg name="approvalScheme" value="ref:approvalScheme"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
    <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
    <Arg name="formTemplate" value="Identity Update"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="launcher" value="ref:launcher"/>
    <Arg name="manualActionsEmailTemplate" value="Pending Manual Changes"/>
    <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="policyViolations" value="ref:policyViolations"/>
    <Arg name="policyScheme" value="ref:policyScheme"/>
    <Arg name="recompile" value="false"/>
    <Arg name="trace" value="ref:trace"/>
    <Description>
      Call the standard subprocess that will process the
      approval decisions and do provisioning.  This
      includes calling any configured provisioning
      connectors and building manual actions.
    </Description>
    <Return name="project" to="project"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Identity Request Provision"/>
    </WorkflowRef>
    <Transition to="Post Provision"/>
  </Step>
  <Step action="script:approvalSet.setAllProvisioned();" icon="Task" name="Post Provision" posX="1110" posY="7">
    <Description>
      Mark all of the items in the approvalset provisioned since these
      are all synchronous activities.
    </Description>
    <Transition to="Update Ticket Post Provision"/>
  </Step>
  <Step condition="script:(ticketManagementApplication != null)" icon="Task" name="Update Ticket Post Provision" posX="1111" posY="115">
    <Arg name="action" value="postProvisioning"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="ticketDataGenerationRule" value=""/>
    <Arg name="trace" value="ref:trace"/>
    <Description>
      Call a subprocess to update the ticket in the ticketManagementApplication is non-null.

      You can specify a specific 'ticketDataGenerationRule' here or you can also specify
      it on the application.  It'll be read from the argument first and fall back to the '
      application config.

    </Description>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Manage Ticket"/>
    </WorkflowRef>
    <Transition to="Refresh Identity"/>
  </Step>
  <Step action="call:refreshIdentity" condition="ref:doRefresh" icon="Task" name="Refresh Identity" posX="954" posY="114">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="correlateEntitlements" value="true"/>
    <Arg name="provision" value="true"/>
    <Arg name="synchronizeAttributes" value="true"/>
    <Description>
      Add arguments as necessary to enable refresh features.  Typically you only want this
      to correlate roles and possibly provision if we notice new assigned roles.
      Note that provisioning will be done in the Identity Refresh workflow so if there
      are any provisioning forms to display we won't feed them directly to the
      current user, they'll have to return to the inbox.
    </Description>
    <Transition to="Notify"/>
  </Step>
  <Step icon="Task" name="Notify" posX="830" posY="114">
    <Arg name="approvalScheme" value="ref:approvalScheme"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="launcher" value="ref:launcher"/>
    <Arg name="notificationScheme" value="ref:notificationScheme"/>
    <Arg name="userEmailTemplate" value="ref:userEmailTemplate"/>
    <Arg name="requesterEmailTemplate" value="ref:requesterEmailTemplate"/>
    <Arg name="managerEmailTemplate" value="ref:managerEmailTemplate"/>
    <Arg name="securityOfficerEmailTemplate" value="ref:securityOfficerEmailTemplate"/>
    <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="policyViolations" value="ref:policyViolations"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="source" value="ref:source"/>
    <Description>
      Call the standard subprocess that will notify the various
      actors based on notification scheme.
    </Description>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Identity Request Notify"/>
    </WorkflowRef>
    <Transition to="end"/>
  </Step>
  <Step action="call:addMessage" name="Exit On Policy Violation" posX="250" posY="225">
    <Arg name="message" value="Failed due to policy violation(s)"/>
    <Arg name="type" value="Error"/>
    <Transition to="end"/>
  </Step>
  <Step action="call:addMessage" name="Exit On Manual Work Items" posX="280" posY="141">
    <Arg name="message" value="Failed due to manual work item(s)"/>
    <Arg name="type" value="Error"/>
    <Transition to="end"/>
  </Step>
  <Step action="call:addMessage" name="Exit On Provisioning Form" posX="361" posY="78">
    <Arg name="message" value="Failed due to provisioning form"/>
    <Arg name="type" value="Error"/>
    <Transition to="end"/>
  </Step>
  <Step catches="complete" icon="Catches" name="Finalize" posX="759" posY="284">
    <Arg name="project" value="ref:project"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="batchRequestItemId" value="ref:batchRequestItemId"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Description>
      Call the standard subprocess that can audit/finalize the request.
    </Description>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Identity Request Finalize"/>
    </WorkflowRef>
  </Step>
  <Step icon="Stop" name="end" posX="830" posY="225"/>
</Workflow>
<Workflow configForm="Provisioning Workflow Config Form" handler="sailpoint.api.StandardWorkflowHandler" libraries="Identity,BatchRequest" name="LCM Registration" taskType="LCM" type="LCMRegistration">
  <Variable initializer="true" name="transient">
    <Description>
      Set to false to cause workflow-related objects, such as approval
      work items, to be saved in the database even if they are only
      viewed by the person registering.
    </Description>
  </Variable>
  <Variable input="true" name="batchRequestItemId">
    <Description>
      Used by the batch interface to record back individual request item status. The specific item id for the individual request in the batch file.  
    </Description>
  </Variable>
  <Variable initializer="Registration" name="flow">
    <Description>
      The name of the LCM flow that launched this workflow.
    </Description>
  </Variable>
  <Variable editable="true" name="optimisticProvisioning">
    <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be 
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
  </Variable>
  <Variable editable="true" initializer="true" name="foregroundProvisioning">
    <Description>
      Normally provisioning is done in a step that uses the "background"
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to
      see the results of the request.
    </Description>
  </Variable>
  <Variable editable="true" name="doRefresh">
    <Description>
      Set to true to cause an identity refresh after the changes in the plan
      have been provisioned.  This is normally off, you might want this on
      if you want modification of identity or link attributes to result in
      an immediate re-evaluation of assigned and detected roles.
    </Description>
  </Variable>
  <Variable initializer="Normal" input="true" name="workItemPriority">
    <Description>
       The String version of a WorkItem.Priority. This variable is 
       used to set the priority on all of the workitems generated 
       as part of this workflow and also set on the IdentityRequest
       object.
    </Description>
  </Variable>
  <Variable initializer="user,manager" input="true" name="notificationScheme">
    <Description>
     A string that specifies who should be notified when the request has been complete.
     The value can be null or a csv of one or more of the following options. 

     none or null
       disable notifications

     user 
       Identity that is registering will be notified.

     manager
       The manager of the Identity that is being updated will be notified.

     securityOfficer
       The identity named in the variable securityOfficerName will be notified.
    </Description>
  </Variable>
  <Variable initializer="LCM Registration User Notification" input="true" name="userEmailTemplate">
    <Description>
     The email template to use for user notification.
    </Description>
  </Variable>
  <Variable initializer="LCM Registration Manager Notification" input="true" name="managerEmailTemplate">
    <Description>
     The email template to use for manager notification.
    </Description>
  </Variable>
  <Variable initializer="LCM Registration Security Officer Notification" input="true" name="securityOfficerEmailTemplate">
    <Description>
     The email template to use for security officer notification.
    </Description>
  </Variable>
  <Variable initializer="serial" input="true" name="approvalMode">
    <Description>
     A string that specifies how we should handle the approvals.  

     By default this is serial since most of these request with
     the exception of manager transfers will have only one approver.

     parallel
       Approvals are processed concurrently and there must be consensus,
       we wait for all approvers to approve.  The first approver that
       rejects terminates the entire approval.
 
     parallelPoll 
       Approvals are processed concurrently but consensus is not required.
       All approvals will be processed, we don't stop if there are any
       rejections.  

     serial
       Approvals are processed one at a time and there must be consensus.
       The first approver that rejects terminates the entire approval.

     serialPoll
       Approvals are processed in order but consensus is not required.
       All approvals will be processed, we don't stop if there are any
       rejections.  In effect we are "taking a poll" of the approvers.

     any
      Approvals are processed concurrently, the first approver to 
      respond makes the decision for the group.
    </Description>
  </Variable>
  <Variable initializer="securityOfficer" input="true" name="approvalScheme">
    <Description>
      A csv string that specifies how approvals should be generated for 
      the incoming request.
 
      The value can be any of the values below, combined together but
      are always processed in this order:
  
      1. manager
      2. securityOfficer

      Any rejected items from previous approvals will be omitted from the  
      next phase of approvers.

      none - disabled approvals

      manager - The manager will get all approvals

      securityOfficer - The identity named in the variable securityOfficerName.
    </Description>
  </Variable>
  <Variable initializer="LCM Registration Approval" input="true" name="approvalEmailTemplate">
    <Description>
     The email template to use for approval notifications.
    </Description>
  </Variable>
  <Variable input="true" name="securityOfficerName">
    <Description>
       The name of the identity that will be sent approvals 
       during security officer approvals.
    </Description>
  </Variable>
  <Variable initializer="spadmin" input="true" name="fallbackApprover">
    <Description>
      A String that specifies the name of the Identity that will 
      be assigned any approvals where the owner of the approver 
      can't be resolved. Example if the scheme is "owner" and the 
      application doesn't specify and owner.
    </Description>
  </Variable>
  <Variable initializer="continue" input="true" name="policyScheme">
    <Description>
      A String that specifies how policy checks effect the overall
      process.

      none - disabled policy checking

      fail -  fail and exit the workflow if any policy violations are found

      continue -  continue if policy violations are found
    </Description>
  </Variable>
  <Variable input="true" name="ticketManagementApplication">
    <Description>
      Name of the application that can handle ticket requests.
      When non-null the Manage Ticket Steps will be visited to open
      tickets during the workflow lifecycle.      
    </Description>
  </Variable>
  <Variable input="true" name="policiesToCheck">
    <Description>
      A List of policies that should be checked. If this list is
      empty all violations will be checked. Used in combination
      with policyScheme.
    </Description>
  </Variable>
  <Variable initializer="LCM" input="true" name="source">
    <Description>
      String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.
    </Description>
  </Variable>
  <Variable initializer="false" name="trace">
    <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
  </Variable>
  <Variable input="true" name="approverElectronicSignature">
    <Description>
       The name of the electronic signature object that should be used when workitems 
       are completed by the approver.
    </Description>
  </Variable>
  <Variable name="identityName">
    <Description>The name of the identity we're creating.</Description>
  </Variable>
  <Variable name="identityDisplayName">
    <Description>
      The displayName of the identity being updated.
    </Description>
  </Variable>
  <Variable name="confirmationForm">
    <Description>
      A form that gets displayed for confirming the registration.
    </Description>
  </Variable>
  <Variable name="plan">
    <Description>
      The ProvisioningPlan that gets generated from the form input.
    </Description>
  </Variable>
  <Variable name="identityModel">
    <Description>
      The identity model that is used to represent the identity being created.
    </Description>
  </Variable>
  <Variable name="ticketId">
    <Description>
      The id of the ticket that is generated by the ticketingManagementApplication.
      This is typically generated on the "open" call, and then used in subsequent 
      calls.  It is also stored on the IdentityRequest object under the 
      externalTicketId variable. 
    </Description>
  </Variable>
  <Variable name="policyViolations">
    <Description> 
       List of policy violations that were found during our initial policy scan.
       This list is passed into each work item so the approvers can see 
       pending violations.
    </Description>
  </Variable>
  <Variable input="true" name="approvingIdentities">
    <Description>
      List of identities and/or workgroups names/ids that should be involved in the approval
      process.
    </Description>
  </Variable>
  <RuleLibraries>
    <Reference class="sailpoint.object.Rule" name="Approval Library"/>
    <Reference class="sailpoint.object.Rule" name="LCM Workflow Library"/>
  </RuleLibraries>
  <Step icon="Start" name="Start" posX="15" posY="12">
    <Transition to="Initialize"/>
  </Step>
  <Step action="call:getIdentityModel" name="Initialize" posX="15" posY="115" resultVariable="identityModel">
    <Description>
       Initialize the data for the identity that we are creating.
    </Description>
    <Transition to="Registration Form"/>
  </Step>
  <Step icon="Approval" name="Registration Form" posX="131" posY="115">
    <Approval mode="serial" owner="ref:launcher" return="identityModel">
      <Arg name="workItemType" value="Form"/>
      <Arg name="workItemDescription" value="Self-service registration form"/>
      <Arg name="workItemForm" value="registerForm"/>
      <Arg name="workItemFormBasePath" value="identityModel"/>
    </Approval>
    <Description>
       Display the registration form to collect information about the registrant.
    </Description>
    <Transition to="Build Confirmation Form"/>
  </Step>
  <Step action="call:buildReadOnlyForm" name="Build Confirmation Form" posX="131" posY="10" resultVariable="confirmationForm">
    <Arg name="form" value="registerForm"/>
    <Arg name="helpText" value="lcm_registration_confirmation_text"/>
    <Arg name="nextButtonLabel" value="label_confirm"/>
    <Description>
       Create the confirmation form to be displayed.
    </Description>
    <Transition to="Confirmation Form"/>
  </Step>
  <Step icon="Approval" name="Confirmation Form" posX="269" posY="10">
    <Approval mode="serial" owner="ref:launcher" return="identityModel">
      <Arg name="workItemType" value="Form"/>
      <Arg name="workItemDescription" value="Confirmation form"/>
      <Arg name="workItemForm" value="ref:confirmationForm"/>
      <Arg name="workItemFormBasePath" value="identityModel"/>
    </Approval>
    <Description>
       Display the confirmation form to the registrant.
    </Description>
    <Transition to="Registration Form" when="!approved"/>
    <Transition to="Verify"/>
  </Step>
  <Step icon="Analysis" name="Verify" posX="403" posY="6">
    <Description>
      This is a place-holder step where verification of the information could
      occur before a creation request is launched.  This could potentially call
      out to an external system to verify some unique information (eg - employeeId)
      before continuing on.
    </Description>
    <Transition to="Set identity name"/>
  </Step>
  <Step name="Set identity name" posX="507" posY="6" resultVariable="identityName">
    <Description>
      Set the identityName workflow variable based on the form input.
    </Description>
    <Script>
      <Source>
        String name = (String)identityModel.get("name");
        if (name != null) {
          name = name.trim();
        }

        return name;
      </Source>
    </Script>
    <Transition to="Build Provisioning Plan"/>
  </Step>
  <Step action="call:buildPlanFromIdentityModel" name="Build Provisioning Plan" posX="646" posY="6" resultVariable="plan">
    <Arg name="identityModel" value="ref:identityModel"/>
    <Description>
      Convert the registration request into a provisioning plan.
    </Description>
    <Transition to="Submit Registration Request"/>
  </Step>
  <Step icon="Task" name="Submit Registration Request" posX="646" posY="110">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
    <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
    <Arg name="doRefresh" value="ref:doRefresh"/>
    <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
    <Arg name="notificationScheme" value="ref:notificationScheme"/>
    <Arg name="approvalMode" value="ref:approvalMode"/>
    <Arg name="approvalScheme" value="ref:approvalScheme"/>
    <Arg name="approvingIdentities" value="ref:approvingIdentities"/>
    <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
    <Arg name="approverElectronicSignature" value="ref:approverElectronicSignature"/>
    <Arg name="approvalEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Arg name="userEmailTemplate" value="ref:userEmailTemplate"/>
    <Arg name="managerEmailTemplate" value="ref:managerEmailTemplate"/>
    <Arg name="securityOfficerEmailTemplate" value="ref:securityOfficerEmailTemplate"/>
    <Arg name="policyScheme" value="ref:policyScheme"/>
    <Arg name="policiesToCheck" value="ref:policiesToCheck"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="trace" value="ref:trace"/>
    <Description>
      Call the LCM Create and Update workflow with the plan that was created.
    </Description>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="LCM Create and Update"/>
    </WorkflowRef>
    <Transition to="end"/>
  </Step>
  <Step icon="Stop" name="end" posX="646" posY="217"/>
</Workflow>
<Workflow configForm="LCM Manage Passwords Config Form" handler="sailpoint.api.StandardWorkflowHandler" libraries="Identity,Role,PolicyViolation,LCM,BatchRequest" name="LCM Manage Passwords" taskType="LCM" type="LCMProvisioning">
  <Variable input="true" name="identityName">
    <Description>The name of the identity being updated.</Description>
  </Variable>
  <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
    <Description>
      The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.
    </Description>
  </Variable>
  <Variable input="true" name="batchRequestItemId">
    <Description>
      Used by the batch interface to record back individual request item status. The specific item id for the individual request in the batch file.
    </Description>
  </Variable>
  <Variable initializer="false" input="true" name="endOnManualWorkItems">
    <Description>Option to skip requests with manual work items.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="endOnProvisioningForms">
    <Description>Option to skip requests with provisioning forms.</Description>
  </Variable>
  <Variable input="true" name="plan">
    <Description>The provisioning plan ready to execute.</Description>
  </Variable>
  <Variable input="true" name="flow">
    <Description>
      The name of the flow that launched this workflow.

      This is one of these three values:

      ForgotPassword
      ExpiredPassword
      PasswordRequest

    </Description>
  </Variable>
  <Variable editable="true" initializer="true" name="foregroundProvisioning">
    <Description>
      Normally provisioning is done in a step that uses the "background"
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to
      see the results of the request.
    </Description>
  </Variable>
  <Variable initializer="user" input="true" name="notificationScheme">
    <Description>
     A string that specifies who should be notified when the request has been complete.
     The value can be null or a csv of one or more of the following options.

     none or null
       disable notifications

     user
       Identity that is being update will be notified.

    </Description>
  </Variable>
  <Variable initializer="LCM" input="true" name="source">
    <Description>
      String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.
    </Description>
  </Variable>
  <Variable input="true" name="ticketManagementApplication">
    <Description>
      Name of the application that can handle ticket requests.
      When non-null the Manage Ticket Steps will be visited to open
      tickets during the workflow lifecycle.
    </Description>
  </Variable>
  <Variable initializer="LCM Password Change Notification" input="true" name="userEmailTemplate">
    <Description>
     The email template to use for user notification.
    </Description>
  </Variable>
  <Variable initializer="LCM Password Change Notification" input="true" name="requesterEmailTemplate">
    <Description>
     The email template to use for requester notification.
    </Description>
  </Variable>
  <Variable initializer="LCM Password Change Notification" input="true" name="managerEmailTemplate">
    <Description>
     The email template to use for manager notification.
    </Description>
  </Variable>
  <Variable name="ticketId">
    <Description>
      The id of the ticket that is generated by the ticketingManagementApplication.
      This is typically generated on the "open" call, and then used in subsequent
      calls.  It is also stored on the IdentityRequest object under the
      externalTicketId variable.
    </Description>
  </Variable>
  <Variable name="approvalSet">
    <Description>
       This attributes is set during the "Build Approval Set" step,
       which builds this list by going through the ProvisioningPlan
       to build the line items that need to be approved,

       This variable includes all ApprovalItems that are part of
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
  </Variable>
  <Variable initializer="false" name="trace">
    <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
  </Variable>
  <Variable name="project">
    <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan.
    </Description>
  </Variable>
  <Variable name="policyViolations">
    <Description>
       List of policy violations that were found during our initial policy scan.
       This list is passed into each work item so the approvers can see
       pending violations.
    </Description>
  </Variable>
  <Variable name="identityRequestId" output="true">
    <Description>
       The sequence id of the Identity request object which is stored in
       the name field of the identity request.
    </Description>
  </Variable>
  <Variable initializer="Normal" input="true" name="workItemPriority">
    <Description>
       The String version of a WorkItem.Priority. This variable is
       used to set the priority on all of the workitems generated
       as part of this workflow and also set on the IdentityRequest
       object.
    </Description>
  </Variable>
  <Variable initializer="false" input="true" name="isProvisioningFailed" output="true">
    <Description>
      This variable will keep track of provisioning errors reported
      in the Identity Request Items within the Identity Request object,
      so that we can prevent from notifying the user about provisioning
      actions status on failure.
    </Description>
  </Variable>
  <RuleLibraries>
    <Reference class="sailpoint.object.Rule" name="LCM Workflow Library"/>
  </RuleLibraries>
  <Step icon="Start" name="Start" posX="28" posY="12">
    <Transition to="Initialize"/>
  </Step>
  <Step icon="Task" name="Initialize" posX="118" posY="11">
    <Arg name="flow" value="ref:flow"/>
    <Arg name="formTemplate" value="Identity Update"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="launcher" value="ref:launcher"/>
    <Arg name="optimisticProvisioning" value="false"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="policiesToCheck" value="ref:policiesToCheck"/>
    <Arg name="policyScheme" value="none"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="batchRequestItemId" value="ref:batchRequestItemId"/>
    <Arg name="endOnProvisioningForms" value="ref:endOnProvisioningForms"/>
    <Arg name="endOnManualWorkItems" value="ref:endOnManualWorkItems"/>
    <Description>
      Call the standard subprocess to initialize the request, this includes
      auditing, building the approvalset, compiling the plan into
      a project and checking policy violations.
    </Description>
    <Return name="project" to="project"/>
    <Return name="approvalSet" to="approvalSet"/>
    <Return name="identityRequestId" to="identityRequestId"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Identity Request Initialize"/>
    </WorkflowRef>
    <Transition to="Exit On Manual Work Items" when="script:(isTrue(endOnManualWorkItems) &amp;&amp; (project.getUnmanagedPlan() != null))"/>
    <Transition to="Exit On Provisioning Form" when="script:(isTrue(endOnProvisioningForms) &amp;&amp; (project.hasQuestions()))"/>
    <Transition to="Create Ticket"/>
  </Step>
  <Step condition="script:(ticketManagementApplication != null)" icon="Task" name="Create Ticket" posX="279" posY="8">
    <Arg name="action" value="openNoApproval"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="ticketDataGenerationRule" value=""/>
    <Arg name="trace" value="ref:trace"/>
    <Description>
      Call a subprocess to create a ticket in the ticketManagementApplication is non-null.
      You can specify a specific 'ticketDataGenerationRule' here or you can also specify
      it on the application.  It'll be read from the argument first and fall back to the '
      application config.
    </Description>
    <Return name="ticketId" to="externalTicketId"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Manage Ticket"/>
    </WorkflowRef>
    <Transition to="Provision"/>
  </Step>
  <Step icon="Task" name="Provision" posX="369" posY="8">
    <Arg name="approvalScheme" value="ref:approvalScheme"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="fallbackApprover" value="spadmin"/>
    <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
    <Arg name="formTemplate" value="Identity Update"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="launcher" value="ref:launcher"/>
    <Arg name="manualActionsEmailTemplate" value="Pending Manual Changes"/>
    <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
    <Arg name="policyViolations" value="ref:policyViolations"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="policyScheme" value="ref:policyScheme"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="trace" value="ref:trace"/>
    <Description>
      Call the standard subprocess that will process the
      approval decisions and do provisioning.  This
      includes calling any configured provisioning
      connectors and building manual actions.
    </Description>
    <Return name="project" to="project"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Identity Request Provision"/>
    </WorkflowRef>
    <Transition to="Post Provision"/>
  </Step>
  <Step icon="Task" name="Post Provision" posX="472" posY="8" resultVariable="isProvisioningFailed">
    <Script>
      <Source>
        import sailpoint.api.ObjectUtil;
        import sailpoint.tools.Util;
        import sailpoint.object.WorkflowCase;
        import sailpoint.object.TaskResult;
        import sailpoint.object.IdentityRequest;
        import sailpoint.object.IdentityRequestItem;
        import sailpoint.object.ProvisioningProject;

        if ( null != identityRequestId ) {
            IdentityRequest ir = wfcontext.getSailPointContext().getObject(IdentityRequest.class, identityRequestId);
            if ( null != ir ) {
                List requestItems = ir.getItems();
                if ( Util.size(requestItems) &gt; 0 ) {
                    for ( IdentityRequestItem item : requestItems ) {
                        if ( item.isProvisioningFailed() ) {
                            isProvisioningFailed = true;
                            return isProvisioningFailed;
                        }
                    }
                }
            }
        }

        if ( approvalSet != null ) {
            // Set state to provisioned and also mark them all approved
            approvalSet.setAllProvisioned();

            List items = approvalSet.getItems();
            if ( Util.size(items) &gt; 0 ) {
                for ( ApprovalItem item : items ) {
                    item.approve();
                }
            }
            if ( Util.otob(trace) ) {
                System.out.println("ApprovalSet:\n" + approvalSet.toXml());
            }
        }

        // mark this verified to prevent the scanner from processing it
        TaskResult result = wfcontext.getTaskResult();
        if ( result != null ) {
            result.setVerified(new Date());
        }
        if ( project != null ) {
            if ( Util.otob(trace) ) {
                // clone and scrub the project so passwords are not visible
                ProvisioningProject clonedProject = project.deepCopy(wfcontext.getSailPointContext());
                ObjectUtil.scrubPasswords(clonedProject);
                System.out.println("Project Executed in lcm:\n" + clonedProject.toXml());
            }
        }
      </Source>
    </Script>
    <Transition to="end" when="ref:isProvisioningFailed"/>
    <Transition to="Update Ticket Post Provision"/>
  </Step>
  <Step condition="script:(ticketManagementApplication != null)" icon="Task" name="Update Ticket Post Provision" posX="604" posY="8">
    <Arg name="action" value="postProvisioning"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="ticketDataGenerationRule" value=""/>
    <Arg name="trace" value="ref:trace"/>
    <Description>
      Call a subprocess to update the ticket in the ticketManagementApplication is non-null.

      You can specify a specific 'ticketDataGenerationRule' here or you can also specify
      it on the application.  It'll be read from the argument first and fall back to the '
      application config.

    </Description>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Manage Ticket"/>
    </WorkflowRef>
    <Transition to="Notify"/>
  </Step>
  <Step icon="Task" name="Notify" posX="719" posY="8">
    <Arg name="approvalScheme" value="ref:approvalScheme"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="launcher" value="ref:launcher"/>
    <Arg name="notificationScheme" value="ref:notificationScheme"/>
    <Arg name="userEmailTemplate" value="ref:userEmailTemplate"/>
    <Arg name="requesterEmailTemplate" value="ref:requesterEmailTemplate"/>
    <Arg name="managerEmailTemplate" value="ref:managerEmailTemplate"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="policyViolations" value="ref:policyViolations"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="trace" value="ref:trace"/>
    <Description>
      Call the standard subprocess that will notify the various
      actors based on notification scheme.
    </Description>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Identity Request Notify"/>
    </WorkflowRef>
    <Transition to="end"/>
  </Step>
  <Step action="call:addMessage" name="Exit On Manual Work Items" posX="185" posY="164">
    <Arg name="message" value="Failed due to manual work item(s)"/>
    <Arg name="type" value="Error"/>
    <Transition to="end"/>
  </Step>
  <Step action="call:addMessage" name="Exit On Provisioning Form" posX="231" posY="81">
    <Arg name="message" value="Failed due to provisioning form"/>
    <Arg name="type" value="Error"/>
    <Transition to="end"/>
  </Step>
  <Step catches="complete" icon="Catches" name="Finalize" posX="666" posY="222">
    <Arg name="project" value="ref:project"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="autoVerifyIdentityRequest" value="true"/>
    <Arg name="batchRequestItemId" value="ref:batchRequestItemId"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Description>
      Call the standard subprocess that can audit/finalize the request.
    </Description>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Identity Request Finalize"/>
    </WorkflowRef>
  </Step>
  <Step icon="Stop" name="end" posX="720" posY="163"/>
</Workflow>
<Workflow explicitTransitions="true" libraries="Identity" name="Lifecycle Event - Joiner" type="IdentityLifecycle">
  <Variable input="true" name="trigger">
    <Description>The IdentityTrigger</Description>
  </Variable>
  <Variable input="true" name="event" transient="true">
    <Description>
      The IdentityChangeEvent.  It can be used to build
      the provisioning plan, but does not need to be
      persisted with the case, so marked as transient.
    </Description>
  </Variable>
  <Variable input="true" name="identityName">
    <Description>The name of the identity.</Description>
  </Variable>
  <Description>Process a new employee.</Description>
  <Step icon="Start" name="Start" posX="28" posY="10">
    <Transition to="Process user"/>
  </Step>
  <Step icon="Message" name="Process user" posX="148" posY="10">
    <Description>Process the user that joined.</Description>
    <Script>
      <Source>
      System.out.println("New user was entered the system: " + event.getObject().getDisplayableName());
      </Source>
    </Script>
    <Transition to="Stop"/>
  </Step>
  <Step icon="Stop" name="Stop" posX="268" posY="10"/>
</Workflow>
<Workflow explicitTransitions="true" libraries="Identity" name="Lifecycle Event - Leaver" type="IdentityLifecycle">
  <Variable input="true" name="trigger">
    <Description>The IdentityTrigger</Description>
  </Variable>
  <Variable input="true" name="event" transient="true">
    <Description>
      The IdentityChangeEvent.  It can be used to build
      the provisioning plan, but does not need to be
      persisted with the case, so marked as transient.
    </Description>
  </Variable>
  <Variable input="true" name="identityName">
    <Description>The name of the identity.</Description>
  </Variable>
  <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
    <Description>
      The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.
    </Description>
  </Variable>
  <Variable name="plan">
    <Description>The provisioning plan, which is built by a service method. </Description>
  </Variable>
  <Variable editable="true" initializer="false" name="optimisticProvisioning">
    <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be 
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
  </Variable>
  <Variable editable="true" initializer="true" name="foregroundProvisioning">
    <Description>
      Normally provisioning is done in a step that uses the "background"
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to 
      see the results of the request.
    </Description>
  </Variable>
  <Variable initializer="spadmin" input="true" name="fallbackApprover">
    <Description>
      A String that specifies the name of the Identity that will 
      be assigned any approvals where the owner of the approver 
      can't be resolved. Example if the scheme is "owner" and the 
      application doesn't specify and owner.
    </Description>
  </Variable>
  <Variable initializer="LCM" input="true" name="source">
    <Description>
      String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.
    </Description>
  </Variable>
  <Variable initializer="false" input="true" name="trace">
    <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
  </Variable>
  <Variable name="project">
    <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan.
    </Description>
  </Variable>
  <Variable name="identityRequestId" output="true">
    <Description>
       The sequence id of the Identity request object which is stored in 
       the name field of the identity request.
    </Description>
  </Variable>
  <Variable name="cart" output="true">
    <Description>
       This variable includes all ApprovalItems that are part of 
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions 
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
  </Variable>
  <Variable initializer="Normal" input="true" name="workItemPriority">
    <Description>
       The String version of a WorkItem.Priority. This variable is 
       used to set the priority on all of the workitems generated 
       as part of this workflow and also set on the IdentityRequest
       object.
    </Description>
  </Variable>
  <Description>Disable all accounts when an employee leaves the company.</Description>
  <RuleLibraries>
    <Reference class="sailpoint.object.Rule" name="LCM Workflow Library"/>
  </RuleLibraries>
  <Step action="call:buildEventPlan" icon="Start" name="Build Provisioning Plan" posX="50" posY="10" resultVariable="plan">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="op" value="Disable"/>
    <Arg name="event" value="ref:event"/>
    <Arg name="trigger" value="ref:trigger"/>
    <Description>Go through all of the user's links and build a plan.</Description>
    <Transition to="Initialize"/>
  </Step>
  <Step icon="Task" name="Initialize" posX="170" posY="10">
    <Arg name="formTemplate" value="Identity Update"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="launcher" value="ref:launcher"/>
    <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="policyScheme" value="none"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="flow" value="Lifecycle"/>
    <Description>
      Call the standard subprocess to initialize the request, this includes
      auditing, building the approvalset, compiling the plan into 
       project and checking policy violations.
    </Description>
    <Return name="project" to="project"/>
    <Return name="approvalSet" to="cart"/>
    <Return name="identityRequestId" to="identityRequestId"/>
    <Return name="policyViolations" to="policyViolations"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Identity Request Initialize"/>
    </WorkflowRef>
    <Transition to="Provision"/>
  </Step>
  <Step condition="script:!((size(policyViolations) &gt; 0 ) &amp;&amp; (policyScheme.equals(&quot;fail&quot;)))" icon="Task" name="Provision" posX="290" posY="10">
    <Arg name="approvalScheme" value="ref:approvalScheme"/>
    <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
    <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
    <Arg name="formTemplate" value="Identity Update"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="launcher" value="ref:launcher"/>
    <Arg name="manualActionsEmailTemplate" value="Pending Manual Changes"/>
    <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="policyScheme" value="none"/>
    <Arg name="noTriggers" value="true"/>
    <Arg name="trace" value="ref:trace"/>
    <Description>
      Call the standard subprocess that will process the 
      approval decisions and do provisioning.  This
      includes calling any configured provisioning 
      connectors and building manual actions.
    </Description>
    <Return name="project" to="project"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Identity Request Provision"/>
    </WorkflowRef>
    <Transition to="Finalize"/>
  </Step>
  <Step catches="complete" condition="script:!((size(policyViolations) &gt; 0 ) &amp;&amp; (policyScheme.equals(&quot;fail&quot;)))" icon="Task" name="Finalize" posX="410" posY="10">
    <Arg name="approvalSet" value="ref:cart"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Description>
      Call the standard subprocess that can audit/finalize the request.
    </Description>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Identity Request Finalize"/>
    </WorkflowRef>
    <Transition to="end"/>
  </Step>
  <Step icon="Stop" name="end" posX="540" posY="10"/>
</Workflow>
<Workflow explicitTransitions="true" libraries="Identity" name="Lifecycle Event - Reinstate" type="IdentityLifecycle">
  <Variable input="true" name="trigger">
    <Description>The IdentityTrigger</Description>
  </Variable>
  <Variable input="true" name="event" transient="true">
    <Description>
      The IdentityChangeEvent.  It can be used to build
      the provisioning plan, but does not need to be
      persisted with the case, so marked as transient.
    </Description>
  </Variable>
  <Variable input="true" name="identityName">
    <Description>The name of the identity.</Description>
  </Variable>
  <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
    <Description>
      The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.
    </Description>
  </Variable>
  <Variable name="plan">
    <Description>The provisioning plan, which is built by a service method. </Description>
  </Variable>
  <Variable editable="true" initializer="false" name="optimisticProvisioning">
    <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be 
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
  </Variable>
  <Variable editable="true" initializer="true" name="foregroundProvisioning">
    <Description>
      Normally provisioning is done in a step that uses the "background"
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to 
      see the results of the request.
    </Description>
  </Variable>
  <Variable initializer="spadmin" input="true" name="fallbackApprover">
    <Description>
      A String that specifies the name of the Identity that will 
      be assigned any approvals where the owner of the approver 
      can't be resolved. Example if the scheme is "owner" and the 
      application doesn't specify and owner.
    </Description>
  </Variable>
  <Variable initializer="LCM" input="true" name="source">
    <Description>
      String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.
    </Description>
  </Variable>
  <Variable initializer="false" input="true" name="trace">
    <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
  </Variable>
  <Variable name="project">
    <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan.
    </Description>
  </Variable>
  <Variable name="identityRequestId" output="true">
    <Description>
       The id of the object that encapsulates the request information
       and status as it goes through the request life cycle. The workflow will create
       and update this object ( through special steps ) as the workflow 
       progresses.
    </Description>
  </Variable>
  <Variable name="cart" output="true">
    <Description>
       This attribute is set during the "Build Approval Set" step,
       which builds this list by going through the ProvisioningPlan
       to build the line items that need to be approved.

       This variable includes all ApprovalItems that are part of 
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions 
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
  </Variable>
  <Variable initializer="Normal" input="true" name="workItemPriority">
    <Description>
       The String version of a WorkItem.Priority. This variable is 
       used to set the priority on all of the workitems generated 
       as part of this workflow and also set on the IdentityRequest
       object.
    </Description>
  </Variable>
  <Description>Enable all accounts when an employee is reinstated.</Description>
  <RuleLibraries>
    <Reference class="sailpoint.object.Rule" name="LCM Workflow Library"/>
  </RuleLibraries>
  <Step action="call:buildEventPlan" name="Build Provisioning Plan" posX="50" posY="10" resultVariable="plan">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="op" value="Enable"/>
    <Arg name="event" value="ref:event"/>
    <Arg name="trigger" value="ref:trigger"/>
    <Description>Go through all of the user's links and build a plan.</Description>
    <Transition to="Initialize"/>
  </Step>
  <Step icon="Task" name="Initialize" posX="170" posY="10">
    <Arg name="formTemplate" value="Identity Update"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="launcher" value="ref:launcher"/>
    <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="policyScheme" value="none"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="flow" value="Lifecycle"/>
    <Description>
      Call the standard subprocess to initialize the request, this includes
      auditing, building the approvalset, compiling the plan into 
       project and checking policy violations.
    </Description>
    <Return name="project" to="project"/>
    <Return name="approvalSet" to="cart"/>
    <Return name="identityRequestId" to="identityRequestId"/>
    <Return name="policyViolations" to="policyViolations"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Identity Request Initialize"/>
    </WorkflowRef>
    <Transition to="Provision"/>
  </Step>
  <Step condition="script:!((size(policyViolations) &gt; 0 ) &amp;&amp; (policyScheme.equals(&quot;fail&quot;)))" icon="Task" name="Provision" posX="290" posY="10">
    <Arg name="approvalScheme" value="ref:approvalScheme"/>
    <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
    <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
    <Arg name="formTemplate" value="Identity Update"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="launcher" value="ref:launcher"/>
    <Arg name="manualActionsEmailTemplate" value="Pending Manual Changes"/>
    <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="policyScheme" value="none"/>
    <Arg name="trace" value="ref:trace"/>
    <Description>
      Call the standard subprocess that will process the 
      approval decisions and do provisioning.  This
      includes calling any configured provisioning
      connectors and building manual actions.
    </Description>
    <Return name="project" to="project"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Identity Request Provision"/>
    </WorkflowRef>
    <Transition to="Finalize"/>
  </Step>
  <Step catches="complete" condition="script:!((size(policyViolations) &gt; 0 ) &amp;&amp; (policyScheme.equals(&quot;fail&quot;)))" icon="Task" name="Finalize" posX="410" posY="10">
    <Arg name="approvalSet" value="ref:cart"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Description>
      Call the standard subprocess that can audit/finalize the request.
    </Description>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Identity Request Finalize"/>
    </WorkflowRef>
    <Transition to="end"/>
  </Step>
  <Step icon="Stop" name="end" posX="530" posY="10"/>
</Workflow>
<Workflow explicitTransitions="true" libraries="Identity" name="Lifecycle Event - Manager Transfer" type="IdentityLifecycle">
  <Variable input="true" name="trigger">
    <Description>The IdentityTrigger</Description>
  </Variable>
  <Variable input="true" name="event" transient="true">
    <Description>
      The IdentityChangeEvent.  It can be used to build
      the provisioning plan, but does not need to be
      persisted with the case, so marked as transient.
    </Description>
  </Variable>
  <Variable input="true" name="identityName">
    <Description>The name of the identity.</Description>
  </Variable>
  <Description>Process a user when they change managers.</Description>
  <Step icon="Start" name="Start" posX="28" posY="10">
    <Transition to="Process user"/>
  </Step>
  <Step icon="Message" name="Process user" posX="148" posY="10">
    <Description>Process the user that transferred managers.</Description>
    <Script>
      <Source>
      
       import sailpoint.object.*;

       String identityFullname = event.getIdentityFullName();
       Identity oldManager = (null != event.getOldObject()) ? event.getOldObject().getManager() : null;
       Identity newManager = (null != event.getObject()) ? event.getObject().getManager() : null;

       String oldManagerName = (null != oldManager) ? oldManager.getDisplayableName() : null;
       String newManagerName = (null != newManager) ? newManager.getDisplayableName() : null;

       System.out.println(identityFullname + " changed managers from " + oldManagerName + " to " + newManagerName);
      
      </Source>
    </Script>
    <Transition to="Stop"/>
  </Step>
  <Step icon="Stop" name="Stop" posX="268" posY="10"/>
</Workflow>
<Workflow explicitTransitions="true" libraries="Identity" name="Lifecycle Event - Email manager for all native changes" type="IdentityLifecycle">
  <Variable input="true" name="trigger">
    <Description>The IdentityTrigger</Description>
  </Variable>
  <Variable input="true" name="event" transient="true">
    <Description>
      The IdentityChangeEvent.  It can be used to build
      the provisioning plan, but does not need to be
      persisted with the case, so marked as transient.
    </Description>
  </Variable>
  <Variable input="true" name="identityName">
    <Description>The name of the identity.</Description>
  </Variable>
  <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
    <Description>
      The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.
    </Description>
  </Variable>
  <Variable name="plan">
    <Description>The provisioning plan, which is built by a service method. </Description>
  </Variable>
  <Variable editable="true" initializer="false" name="optimisticProvisioning">
    <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be 
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
  </Variable>
  <Variable editable="true" initializer="true" name="foregroundProvisioning">
    <Description>
      Normally provisioning is done in a step that uses the "background"
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to 
      see the results of the request.
    </Description>
  </Variable>
  <Variable initializer="spadmin" input="true" name="fallbackApprover">
    <Description>
      A String that specifies the name of the Identity that will 
      be assigned any approvals where the owner of the approver 
      can't be resolved. Example if the scheme is "owner" and the 
      application doesn't specify and owner.
    </Description>
  </Variable>
  <Variable initializer="LCM" input="true" name="source">
    <Description>
      String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.
    </Description>
  </Variable>
  <Variable initializer="false" input="true" name="trace">
    <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
  </Variable>
  <Variable name="project">
    <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan.
    </Description>
  </Variable>
  <Variable name="identityRequestId" output="true">
    <Description>
       The sequence id of the Identity request object which is stored in 
       the name field of the identity request.
    </Description>
  </Variable>
  <Variable name="cart" output="true">
    <Description>
       This variable includes all ApprovalItems that are part of 
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions 
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
  </Variable>
  <Variable initializer="Normal" input="true" name="workItemPriority">
    <Description>
       The String version of a WorkItem.Priority. This variable is 
       used to set the priority on all of the workitems generated 
       as part of this workflow and also set on the IdentityRequest
       object.
    </Description>
  </Variable>
  <Description>
    Send a email to the manager when we notice there are native entitlement
    changes.
  </Description>
  <RuleLibraries>
    <Reference class="sailpoint.object.Rule" name="Approval Library"/>
    <Reference class="sailpoint.object.Rule" name="LCM Workflow Library"/>
  </RuleLibraries>
  <Step name="start" posX="28" posY="10">
    <Script>
      <Source>
        import sailpoint.tools.Util;
        import sailpoint.object.WorkflowCase;
        import sailpoint.object.TaskResult;

       // System.out.println("Event was fired for identity ["+identityName+"]");
       // System.out.println("                    trigger ["+trigger.toXml()+"]");
       // System.out.println("                    event ["+event.toXml()+"]");
      </Source>
    </Script>
    <Transition to="Notify Manager"/>
  </Step>
  <Step action="call:sendEmail" icon="Email" name="Notify Manager" posX="148" posY="10">
    <Arg name="template" value="Native Account Change Manager Notification"/>
    <Arg name="to" value="script:getManagersEmail(identityName)"/>
    <Transition to="end"/>
  </Step>
  <Step icon="Stop" name="end" posX="276" posY="10"/>
</Workflow>
<Workflow explicitTransitions="true" libraries="Identity" name="Lifecycle Event - Manager Approval for all native changes" type="IdentityLifecycle">
  <Variable input="true" name="trigger">
    <Description>The IdentityTrigger</Description>
  </Variable>
  <Variable input="true" name="event" transient="true">
    <Description>
      The IdentityChangeEvent.  It can be used to build
      the provisioning plan, but does not need to be
      persisted with the case, so marked as transient.
    </Description>
  </Variable>
  <Variable input="true" name="identityName">
    <Description>The name of the identity.</Description>
  </Variable>
  <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
    <Description>
      The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.
    </Description>
  </Variable>
  <Variable initializer="NativeChange" name="flow">
    <Description>
      The name of the LCM flow that launched this workflow.

      This is the value "NativeChange" and is used to display special approval
      text when rendering the work item generated for the native change. Do not
      change this value.
    </Description>
  </Variable>
  <Variable name="plan">
    <Description>The provisioning plan, which is built by a service method. </Description>
  </Variable>
  <Variable editable="true" initializer="false" name="optimisticProvisioning">
    <Description>
      Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be 
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.
    </Description>
  </Variable>
  <Variable initializer="script:( Util.otob(getConfiguration(&quot;lcmEnableApprovalRecommendations&quot;)))" input="true" name="enableApprovalRecommendations">
    <Description>
            Flag to determine if recommendations should be gathered for the approvals.
    </Description>
  </Variable>
  <Variable editable="true" initializer="true" name="foregroundProvisioning">
    <Description>
      Normally provisioning is done in a step that uses the "background"
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to 
      see the results of the request.
    </Description>
  </Variable>
  <Variable initializer="spadmin" input="true" name="fallbackApprover">
    <Description>
      A String that specifies the name of the Identity that will 
      be assigned any approvals where the owner of the approver 
      can't be resolved. Example if the scheme is "owner" and the 
      application doesn't specify and owner.
    </Description>
  </Variable>
  <Variable initializer="LCM" input="true" name="source">
    <Description>
      String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.
    </Description>
  </Variable>
  <Variable initializer="false" input="true" name="trace">
    <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
  </Variable>
  <Variable name="project">
    <Description>
      ProvisioningProject which is just a compiled version of the ProvisioningPlan.
    </Description>
  </Variable>
  <Variable name="identityRequestId" output="true">
    <Description>
       The sequence id of the Identity request object which is stored in 
       the name field of the identity request.
    </Description>
  </Variable>
  <Variable name="approvalSet">
    <Description>
       The variable used to hold the approval set generated from the
       native changes on the event.
    </Description>
  </Variable>
  <Variable initializer="true" name="provisionRejectedItems">
    <Description>
        Flag to indicate if actual provisioning to reverse te native
        change should take place OR if it should just print a plan to 
        stdout. Set this variable to true, if you want it to provision
        the rejected items, otherwise it'll just be printed to stdout. 
     </Description>
  </Variable>
  <Variable name="launcher">
    <Description>The name of the identity that launched the workflow. In cases where workflows are launched by the system an alternate launcher name may be passed as as a variable.</Description>
  </Variable>
  <Variable initializer="Modify" name="operations">
    <Description>CSV list of operations that are part of the native change request, default to Modify but this will be recalculated in the "Build OP String" step.</Description>
  </Variable>
  <Variable initializer="Normal" input="true" name="workItemPriority">
    <Description>
       The String version of a WorkItem.Priority. This variable is 
       used to set the priority on all of the workitems generated 
       as part of this workflow and also set on the IdentityRequest
       object.
    </Description>
  </Variable>
  <Description>
  An example workflow that requires manager approval
  for all natively detected changes found by IdentityIQ.
  
  Any items rejected by the manager will be reversed and 
  provisioned.    
  </Description>
  <RuleLibraries>
    <Reference class="sailpoint.object.Rule" name="LCM Workflow Library"/>
  </RuleLibraries>
  <Step icon="Start" name="start" posX="23" posY="129">
    <Script>
      <Source>
        import sailpoint.tools.Util;
        if ( Util.otob(trace) ) { 
            System.out.println("Event was fired for identity ["+identityName+"]");
            System.out.println("                    trigger ["+trigger.toXml()+"]");
            System.out.println("                    event ["+event.toXml()+"]");
        }
      </Source>
    </Script>
    <Transition to="Build Op String"/>
    <Transition to="end" when="script:(Util.size(event.getNativeChanges())==0)"/>
  </Step>
  <Step name="Build Op String" posX="81" posY="20" resultVariable="operations">
    <Script>
      <Source>
        import sailpoint.object.NativeChangeDetection;
        import sailpoint.object.ProvisioningPlan.AccountRequest;
        import sailpoint.tools.Util;
        
        List ops = new ArrayList();
        if ( event != null ) {
            List ncs = event.getNativeChanges();
            if ( ncs != null ) {
                for ( NativeChangeDetection nc : ncs ) {
                    AccountRequest.Operation op = nc.getOperation();
                    if ( op == null ) 
                        opString = "Modify";
                    else
                        opString = op.toString();

                    if ( !ops.contains(opString) ) {
                        ops.add(opString);
                    }
                }
            }
        }
        return Util.listToCsv(ops);
      </Source>
    </Script>
    <Transition to="Build Native Change Approval"/>
  </Step>
  <Step action="call:buildApprovalSetFromNativeChanges" name="Build Native Change Approval" posX="205" posY="20" resultVariable="approvalSet">
    <Arg name="event" value="ref:event"/>
    <Return name="approvalSet" to="approvalSet"/>
    <Transition to="Build Native Change Recommendations"/>
  </Step>
  <Step action="call:populateRecommendationsInApprovalSet" condition="ref:enableApprovalRecommendations" name="Build Native Change Recommendations" posX="373" posY="20" resultVariable="approvalSet">
    <Arg name="identitySource" value="ref:event"/>
    <Return name="approvalSet" to="approvalSet"/>
    <Transition to="Approve Native Change"/>
  </Step>
  <Step name="Approve Native Change" posX="533" posY="20">
    <Approval mode="parallel" owner="script:getManagerName(identityName, launcher, fallbackApprover);" renderer="nativeChangeApprovalRenderer.xhtml" send="identityDisplayName,identityName">
      <AfterScript>
        <Source>
          import sailpoint.workflow.IdentityRequestLibrary;
                    
          if ( item == null ) 
              return;

          assimilateWorkItemApprovalSet(wfcontext, item, approvalSet);          
          auditDecisions(item);
        </Source>
      </AfterScript>
      <Arg name="workItemRequester" value="$(launcher)"/>
      <Arg name="launcher" value="ref:launcher"/>
      <Arg name="approvalSet" value="ref:approvalSet"/>
      <Arg name="operations" value="$(operations)"/>
      <Arg name="workItemDescription" value="Native Account Changes for User: $(identityDisplayName) - Manager Approval"/>
      <Arg name="workItemNotificationTemplate" value="ref:ownerEmailTemplate"/>
      <Arg name="workItemPriority" value="ref:workItemPriority"/>
      <Arg name="flow" value="ref:flow"/>
    </Approval>
    <Transition to="Process Approval Decisions"/>
  </Step>
  <Step action="call:processNativeChangesApprovalDecisions" name="Process Approval Decisions" posX="715" posY="20" resultVariable="plan">
    <Transition to="Provision Native Change Reversal"/>
  </Step>
  <Step condition="script:( Util.otob(provisionRejectedItems) &amp;&amp; plan != null )" icon="Task" name="Provision Native Change Reversal" posX="881" posY="20">
    <Arg name="flow" value="EntitlementsRequest"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="policyScheme" value="none"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="approvalScheme" value="none"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="requireViolationReviewComments" value="false"/>
    <Arg name="allowRequestsWithViolations" value="true"/>
    <Arg name="enableRetryRequest" value="false"/>
    <Arg name="launcher" value="ref:launcher"/>
    <Arg name="doRefresh" value="true"/>
    <Arg name="trace" value="ref:trace"/>
    <Return name="project" to="project"/>
    <Return name="identityRequestId" to="identityRequestId"/>
    <Return merge="true" name="workItemComments" to="workItemComments"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="LCM Provisioning"/>
    </WorkflowRef>
    <Transition to="end"/>
  </Step>
  <Step catches="complete" icon="Catches" name="Complete" posX="658" posY="185">
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Description>
      Call the standard subprocess that can audit/finalize the request if they are in play. 
    </Description>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Identity Request Finalize"/>
    </WorkflowRef>
    <Transition to="end"/>
  </Step>
  <Step icon="Stop" name="end" posX="881" posY="125"/>
</Workflow>
<Workflow configForm="Attribute Sync Workflow Config Form" explicitTransitions="true" name="Attribute Sync" taskType="AttributeSync" type="AttributeSync">
  <Variable input="true" name="plan">
    <Description>The provisioning plan ready to execute. This is passed in to the workflow and will have the identity
      set and a list of account requests that contain attribute requests for all the attributes that
      changed and were configured to synchronize using workflow.</Description>
  </Variable>
  <Variable input="true" name="identityName">
    <Description>The name of the identity being updated.</Description>
  </Variable>
  <Variable initializer="none" input="true" name="approvalScheme">
    <Description>
      A csv string that specifies how approval items should be generated
      for the incoming request.

      The value can be "none", in which case approvals are disabled.

      The value can also be a combination of any of the values below
      in any order, separated by commas. The order in which they are
      specified is the order in which they are processed:

      owner
      The object owner gets the approval item.
      For Role approvals this is the Role object owner.
      For Entitlement approvals this is the Entitlement object owner.

      manager
      The manager gets the approval item.

      securityOfficer
      The identity in the variable securityOfficerName gets the approval item.

      identity
      The identities/workgroups in the variable approvingIdentities get the approval item.
    </Description>
  </Variable>
  <Variable input="true" name="approvalEmailTemplate">
    <Description>
      The email template to use for approval notifications.
    </Description>
  </Variable>
  <Variable initializer="spadmin" input="true" name="fallbackApprover">
    <Description>
      A String that specifies the name of the Identity that will
      be assigned any approvals where the owner of the approver
      can't be resolved. Example if the scheme is "owner" and the
      application doesn't specify and owner.
    </Description>
  </Variable>
  <Variable input="true" name="managerElectronicSignature">
    <Description>
      The name of the electronic signature object that should be used when workitems
      are completed by a manager.
    </Description>
  </Variable>
  <Variable input="true" name="ownerElectronicSignature">
    <Description>
      The name of the electronic signature object that should be used when workitems
      are completed by object owners.
    </Description>
  </Variable>
  <Variable input="true" name="securityOfficerElectronicSignature">
    <Description>
      The name of the electronic signature object that should be used when workitems
      are completed by the security officer.
    </Description>
  </Variable>
  <Variable input="true" name="approvingIdentities">
    <Description>
      List of identities and/or workgroups names/ids that should be involved in the approval
      process.
    </Description>
  </Variable>
  <Variable input="true" name="identityElectronicSignature">
    <Description>
      The name of the electronic signature object that should be used when workitems
      are completed by identities and/or workgroups.
    </Description>
  </Variable>
  <Variable input="true" name="identityEmailTemplate">
    <Description>
      Name of the email template to use when notifying the identities/workgroups of pending approvals.
    </Description>
  </Variable>
  <Variable initializer="none" input="true" name="notificationScheme">
    <Description>
      A string that specifies who should be notified when the request has been complete.
      The value can be null or a csv of one or more of the following options.

      none or null
      disable notifications

      user
      Identity that is being update will be notified.

      manager
      The manager of the Identity that is being updated will be notified.

      requester
      The person that has requested the update will be notified.
    </Description>
  </Variable>
  <Variable input="true" name="userEmailTemplate">
    <Description>
      The email template to use for user notification.
    </Description>
  </Variable>
  <Variable input="true" name="requesterEmailTemplate">
    <Description>
      The email template to use for requester notification.
    </Description>
  </Variable>
  <Variable input="true" name="managerEmailTemplate">
    <Description>
      The email template to use for manager notification.
    </Description>
  </Variable>
  <Variable input="true" name="securityOfficerName">
    <Description>
      The name of the identity that will be sent approvals
      during security officer approvals.
    </Description>
  </Variable>
  <Variable editable="true" name="refreshIdentity">
    <Description>
      Set to true to cause an identity refresh after the changes in the plan
      have been provisioned.  This is normally off, you might want this on
      if you have an application that is both a source and target mapping for
      an Identity Attribute.
    </Description>
  </Variable>
  <Description>This workflow processes attribute synchronization using LCM Provisioning.</Description>
  <Step icon="Start" name="Start" posX="20" posY="22">
    <Transition to="provision"/>
  </Step>
  <Step icon="Task" name="provision" posX="100" posY="100">
    <Arg name="approvalEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Arg name="approvalScheme" value="ref:approvalScheme"/>
    <Arg name="approvingIdentities" value="ref:approvingIdentities"/>
    <Arg name="doRefresh" value="false"/>
    <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
    <Arg name="flow" value="AttributeSync"/>
    <Arg name="foregroundProvisioning" value="false"/>
    <Arg name="identityElectronicSignature" value="ref:identityElectronicSignature"/>
    <Arg name="identityEmailTemplate" value="ref:identityEmailTemplate"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="managerElectronicSignature" value="ref:managerElectronicSignature"/>
    <Arg name="managerEmailTemplate" value="ref:managerEmailTemplate"/>
    <Arg name="notificationScheme" value="ref:notificationScheme"/>
    <Arg name="ownerElectronicSignature" value="ref:ownerElectronicSignature"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="requesterEmailTemplate" value="ref:requesterEmailTemplate"/>
    <Arg name="securityOfficerElectronicSignature" value="ref:securityOfficerElectronicSignature"/>
    <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
    <Arg name="source" value="AttributeSync"/>
    <Arg name="userEmailTemplate" value="ref:userEmailTemplate"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="LCM Provisioning"/>
    </WorkflowRef>
    <Transition to="Refresh Identity"/>
  </Step>
  <Step action="call:refreshIdentity" condition="ref:refreshIdentity" icon="Task" name="Refresh Identity" posX="200" posY="150">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="synchronizeAttributes" value="true"/>
    <Description>
      Add arguments as necessary to enable refresh features.  Typically you only want this
      to sync the attributes again in case an aggregation had changed the value while an
      Attribute Synchronization approval was pending.
      Note that provisioning will be done in the Identity Refresh workflow so if there
      are any provisioning forms to display we won't feed them directly to the
      current user, they'll have to return to the inbox.
    </Description>
    <Transition to="end"/>
  </Step>
  <Step icon="Stop" name="end" posX="420" posY="225"/>
</Workflow>
<Workflow handler="sailpoint.api.StandardWorkflowHandler" libraries="Identity,BatchRequest,IdentityRequest" name="Batch Request Wrapper" taskType="LCM" type="BatchProvisioning">
  <Variable initializer="parallelPoll" input="true" name="approvalMode">
    <Description>
     A string that specifies how we should handle the approvals.

     parallel
       Approvals are processed concurrently and there must be consensus,
       we wait for all approvers to approve.  The first approver that
       rejects terminates the entire approval.
 
     parallelPoll 
       Approvals are processed concurrently but consensus is not required.
       All approvals will be processed, we don't stop if there are any
       rejections.  

     serial
       Approvals are processed one at a time and there must be consensus.
       The first approver that rejects terminates the entire approval.

     serialPoll
       Approvals are processed in order but consensus is not required.
       All approvals will be processed, we don't stop if there are any
       rejections.  In effect we are "taking a poll" of the approvers.

     any
      Approvals are processed concurrently, the first approver to 
      respond makes the decision for the group.
    </Description>
  </Variable>
  <Variable initializer="spadmin" input="true" name="fallbackApprover">
    <Description>
      A String that specifies the name of the Identity that will
      be assigned any approvals where the owner of the approver
      can't be resolved. Example if the scheme is "owner" and the
      application doesn't specify and owner.
    </Description>
  </Variable>
  <Variable initializer="batchRequest" input="true" name="approvalScheme">
    <Description>
      For batch requests you should use the batchRequest scheme.
    </Description>
  </Variable>
  <Variable initializer="false" name="trace">
    <Description>
      Used for debugging this workflow and when set to true trace
      will be sent to stdout.
    </Description>
  </Variable>
  <Variable input="true" name="identityName">
    <Description>The name of the identity being updated.</Description>
  </Variable>
  <Variable initializer="spadmin" input="true" name="batchRequestApprover">
    <Description>The name of the batch request approver.</Description>
  </Variable>
  <Variable name="requireBatchRequestApproval">
    <Description>
       True or false. specifies whether or not we need to worry about the approval step.
    </Description>
  </Variable>
  <Variable input="true" name="batchApproverElectronicSignature">
    <Description>
       The name of the electronic signature object that should be used when workitems 
       are completed by the batch approver when performing batch operations.
    </Description>
  </Variable>
  <Variable name="approvalSet">
    <Description>
       This attributes is set during the "Build Approval Set" step,
       which builds this list by going through the ProvisioningPlan
       to build the line items that need to be approved,

       This variable includes all ApprovalItems that are part of 
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions 
       and comments from the Approvals copy of the ApprovalItem.
    </Description>
  </Variable>
  <RuleLibraries>
    <Reference class="sailpoint.object.Rule" name="Approval Library"/>
    <Reference class="sailpoint.object.Rule" name="LCM Workflow Library"/>
  </RuleLibraries>
  <Step icon="Start" name="Start" posX="25" posY="131">
    <Transition to="Approve" when="script:requireBatchRequestApproval"/>
    <Transition to="Launch Batch Workflows"/>
  </Step>
  <Step icon="Task" name="Approve" posX="83" posY="12">
    <Arg name="workItemComments"/>
    <Arg name="approvalMode" value="ref:approvalMode"/>
    <Arg name="approvalScheme" value="ref:approvalScheme"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="batchRequestId" value="ref:batchRequestId"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="batchRequestApprover" value="ref:batchRequestApprover"/>
    <Arg name="batchApproverElectronicSignature" value="ref:batchApproverElectronicSignature"/>
    <Arg name="batchApproverEmailTemplate" value="Batch Approval"/>
    <Description>
      Call the standard subprocess that will handle the built-in
      owner, manager and security officer approval schemes.
    </Description>
    <Return name="approvalSet" to="approvalSet"/>
    <Return name="workItemComments"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Identity Request Approve"/>
    </WorkflowRef>
    <Transition to="Batch Request Rejected" when="script:approvalSet.hasRejected()"/>
    <Transition to="Launch Batch Workflows"/>
  </Step>
  <Step action="call:launchBatchWorkflows" icon="Task" name="Launch Batch Workflows" posX="285" posY="127">
    <Arg name="batchRequestId" value="ref:batchRequestId"/>
    <Arg name="background" value="ref:requireBatchRequestApproval"/>
    <Description>
      Call library method to launch all the workflows
    </Description>
    <Transition to="end"/>
  </Step>
  <Step action="call:requestRejected" icon="Task" name="Batch Request Rejected" posX="339" posY="8">
    <Arg name="batchRequestId" value="ref:batchRequestId"/>
    <Description>
      Update request with rejected status and result
    </Description>
    <Transition to="end"/>
  </Step>
  <Step icon="Stop" name="end" posX="444" posY="127"/>
</Workflow>
<Workflow explicitTransitions="true" libraries="RapidSetup" name="RapidSetup - Joiner" type="IdentityLifecycle">
  <Variable input="true" name="trigger">
    <Description>The IdentityTrigger</Description>
  </Variable>
  <Variable input="true" name="event" transient="true">
    <Description>
            The IdentityChangeEvent.  It can be used to build
            the provisioning plan, but does not need to be
            persisted with the case, so marked as transient.
        </Description>
  </Variable>
  <Variable input="true" name="identityName">
    <Description>The name of the identity.</Description>
  </Variable>
  <Variable editable="true" input="true" name="requestType"/>
  <Variable initializer="RapidSetup" input="true" name="source">
    <Description>
            String version of sailpoint.object.Source to indicate
            where the request originated.  Defaults to RapidSetup.
        </Description>
  </Variable>
  <Variable initializer="none" input="true" name="policyScheme">
    <Description>
            A String that specifies how policy checks effect the overall
            process.

            none - disabled policy checking

            interactive -  allow requester to remove request items which are causing violations

            continue -  continue if policy violations are found

            fail -  fail and exit the workflow if any policy violations are found
        </Description>
  </Variable>
  <Variable initializer="none" input="true" name="notificationScheme">
    <Description>
            A string that specifies who should be notified via the LCM workflows when the request has been completed.
            The value can be null or a csv of one or more of the following options.

            none or null
            disable notifications

            user
            Identity that is being update will be notified.

            manager
            The manager of the Identity that is being updated will be notified.

            requester
            The person that has requested the update will be notified.
        </Description>
  </Variable>
  <Variable name="birthrightRoles"/>
  <Variable name="plan"/>
  <Variable name="project"/>
  <Variable name="certGenResultName"/>
  <Variable initializer="true" name="saveUnmanagedPlan_WithProjectArgument">
    <Description>
            Set to true because we are passing the project in to save unmanaged plan as an argument.
        </Description>
  </Variable>
  <Variable input="true" name="approvalScheme" output="true"/>
  <Variable initializer="Lifecycle" name="flow"/>
  <Description>Perform Joiner-specific processing for the identity</Description>
  <Step icon="Start" name="Start" posX="19" posY="8">
    <Transition to="Get Request Type"/>
  </Step>
  <Step action="call:getRequestType" name="Get Request Type" posX="492" posY="10" resultVariable="requestType">
    <Arg name="defaultValue" value="joiner"/>
    <Transition to="Mark Joiner"/>
  </Step>
  <Step action="call:updateProcessStatus" name="Mark Joiner" posX="251" posY="82">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="status" value="script:return sailpoint.object.Identity.RAPIDSETUP_PROC_STATE_PROCESSED"/>
    <Transition to="Set Approval Scheme"/>
  </Step>
  <Step action="call:updateApprovalScheme" name="Set Approval Scheme" posX="251" posY="82">
    <Arg name="requestType" value="ref:requestType"/>
    <Transition to="Calculate Birthright Roles"/>
  </Step>
  <Step action="call:calculateBirthrightRoles" name="Calculate Birthright Roles" posX="342" posY="10" resultVariable="birthrightRoles">
    <Arg name="identityName" value="ref:identityName"/>
    <Transition to="Build Plan"/>
  </Step>
  <Step action="call:buildJoinerPlan" name="Build Plan" posX="492" posY="10" resultVariable="plan">
    <Arg name="birthrightRoles" value="ref:birthrightRoles"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Transition to="Execute Joiner Post Rule" when="script:(plan == null)"/>
    <Transition to="Process Plan"/>
  </Step>
  <Step name="Process Plan" posX="803" posY="90">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="noTriggers" value="true"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="approvalScheme" value="ref:approvalScheme"/>
    <Arg name="saveUnmanagedPlan_WithProjectArgument" value="ref:saveUnmanagedPlan_WithProjectArgument"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="policyScheme" value="ref:policyScheme"/>
    <Arg name="notificationScheme" value="ref:notificationScheme"/>
    <Return name="approvalSet" to="approvalSet"/>
    <Return name="project" to="project"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="LCM Provisioning"/>
    </WorkflowRef>
    <Transition to="Notify Manager" when="project != null &amp;&amp; project.getPlans() != null &amp;&amp; project.getPlans().size() &gt; 0"/>
    <Transition to="Stop"/>
  </Step>
  <Step action="sendEmail" icon="Default" name="Notify Manager" posX="1088" posY="164">
    <Arg name="plan" value="ref:plan"/>
    <Arg name="to">
      <Script>
        <Source>
                
                    sailpoint.rapidsetup.tools.EmailTools.getIdentityNameForNotification(context, workflow,
                              identityName, project, true);
                
            </Source>
      </Script>
    </Arg>
    <Arg name="template">
      <Script>
        <Source>
                
                    sailpoint.object.RapidSetupConfigUtils.getString("businessProcesses,joiner,email,joinerCompleted");
                
            </Source>
      </Script>
    </Arg>
    <Arg name="refIdentityDisplayName">
      <Script>
        <Source>
                
                    sailpoint.rapidsetup.tools.EmailTools.getIdentityDisplayName(context, identityName);
                
            </Source>
      </Script>
    </Arg>
    <Arg name="recipientDisplayName">
      <Script>
        <Source>
                
                    sailpoint.rapidsetup.tools.EmailTools.getManagerOrAltIdentityDisplayName(context, identityName);
                
            </Source>
      </Script>
    </Arg>
    <Arg name="disableStaticManagerContent">
      <Script>
        <Source>
                
                    sailpoint.object.RapidSetupConfigUtils.getBoolean("email,disableStaticManagerContent");
                
            </Source>
      </Script>
    </Arg>
    <Arg name="provisioningErrors">
      <Script>
        <Source>
                
                    sailpoint.rapidsetup.tools.EmailTools.getProvisioningErrors(context, project);
                
            </Source>
      </Script>
    </Arg>
    <Arg name="dynamicAppContent">
      <Script>
        <Source>
                
                    sailpoint.rapidsetup.tools.EmailTools.getDynamicTextEmailTemplate(context, project, "email,joinerCompleted", requestType);
                
            </Source>
      </Script>
    </Arg>
    <Transition to="Notify Manager Temporary Password" when="call:isSendTemporaryPasswordEmailEnabled"/>
    <Transition to="Execute Joiner Post Rule"/>
  </Step>
  <Step action="sendEmail" icon="Default" name="Notify Manager Temporary Password" posX="917" posY="10">
    <Arg name="plan" value="ref:plan"/>
    <Arg name="to">
      <Script>
        <Source>
                
                    sailpoint.rapidsetup.tools.EmailTools.getIdentityNameForNotification(context, workflow,
                              identityName, project, true);
                
            </Source>
      </Script>
    </Arg>
    <Arg name="template">
      <Script>
        <Source>
                
                    sailpoint.object.RapidSetupConfigUtils.getString("businessProcesses,joiner,email,joinerSendTemporaryPassword");
                
            </Source>
      </Script>
    </Arg>
    <Arg name="refIdentityDisplayName">
      <Script>
        <Source>
                
                    sailpoint.rapidsetup.tools.EmailTools.getIdentityDisplayName(context, identityName);
                
            </Source>
      </Script>
    </Arg>
    <Arg name="recipientDisplayName">
      <Script>
        <Source>
                
                    sailpoint.rapidsetup.tools.EmailTools.getManagerOrAltIdentityDisplayName(context, identityName);
                
            </Source>
      </Script>
    </Arg>
    <Arg name="requestId">
      <Script>
        <Source>
                
                    sailpoint.rapidsetup.tools.EmailTools.getRequestId(context, plan);
                
            </Source>
      </Script>
    </Arg>
    <Arg name="disableStaticManagerContent">
      <Script>
        <Source>
                
                    sailpoint.object.RapidSetupConfigUtils.getBoolean("email,disableStaticManagerContent");
                
            </Source>
      </Script>
    </Arg>
    <Arg name="provisioningErrors">
      <Script>
        <Source>
                
                    sailpoint.rapidsetup.tools.EmailTools.getProvisioningErrors(context, project);
                
            </Source>
      </Script>
    </Arg>
    <Arg name="dynamicAppContent">
      <Script>
        <Source>
                
                    sailpoint.rapidsetup.tools.EmailTools.getDynamicTextEmailTemplate(context, project, "email,joinerSendTemporaryPassword", requestType);
                
            </Source>
      </Script>
    </Arg>
    <Transition to="Execute Joiner Post Rule"/>
  </Step>
  <Step action="call:executePostJoinerRule" name="Execute Joiner Post Rule" posX="492" posY="10">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="requestType" value="ref:requestType"/>
    <Arg name="project" value="ref:project"/>
    <Transition to="Stop"/>
  </Step>
  <Step icon="Stop" name="Stop" posX="901" posY="289"/>
</Workflow>
<Workflow explicitTransitions="true" libraries="RapidSetup" name="RapidSetup - Leaver" type="IdentityLifecycle">
  <Variable input="true" name="trigger">
    <Description>The IdentityTrigger</Description>
  </Variable>
  <Variable input="true" name="event" transient="true">
    <Description>
            The IdentityChangeEvent.  It can be used to build
            the provisioning plan, but does not need to be
            persisted with the case, so marked as transient.
        </Description>
  </Variable>
  <Variable input="true" name="identityName">
    <Description>The name of the identity.</Description>
  </Variable>
  <Variable initializer="script:Boolean.FALSE" input="true" name="isTerminateIdentity" type="boolean">
    <Description>Set to true if this workflow was launched by terminating an identity</Description>
  </Variable>
  <Variable initializer="script:getIdentityProperty(identityName, &quot;manager.name&quot;)" name="identityManager">
    <Description>
            The Manager of Identity being processed
        </Description>
  </Variable>
  <Variable input="true" name="reasonComments"/>
  <Variable editable="true" input="true" name="requestType"/>
  <Variable input="true" name="approvalScheme" output="true"/>
  <Variable initializer="Lifecycle" name="flow"/>
  <Variable initializer="none" input="true" name="policyScheme">
    <Description>
            A String that specifies how policy checks effect the overall
            process.

            none - disabled policy checking

            interactive -  allow requester to remove request items which are causing violations

            continue -  continue if policy violations are found

            fail -  fail and exit the workflow if any policy violations are found
        </Description>
  </Variable>
  <Variable initializer="none" input="true" name="notificationScheme">
    <Description>
            A string that specifies who should be notified via the LCM workflows when the request has been completed.
            The value can be null or a csv of one or more of the following options.

            none or null
            disable notifications

            user
            Identity that is being update will be notified.

            manager
            The manager of the Identity that is being updated will be notified.

            requester
            The person that has requested the update will be notified.
        </Description>
  </Variable>
  <Variable name="birthrightRoles"/>
  <Variable name="leaverPlanBuilder" transient="true"/>
  <Variable name="immediatePlan" output="true"/>
  <Variable name="deferredPlans" output="true"/>
  <Variable name="project"/>
  <Variable initializer="true" name="saveUnmanagedPlan_WithProjectArgument">
    <Description>
            Set to true because we are passing the project in to save unmanaged plan as an argument.
        </Description>
  </Variable>
  <Variable initializer="RapidSetup" input="true" name="source">
    <Description>
            String version of sailpoint.object.Source to indicate
            where the request originated.  Defaults to RapidSetup.
        </Description>
  </Variable>
  <Description>Perform Leaver-specific processing for the identity</Description>
  <Step icon="Start" name="Start" posX="19" posY="8">
    <Transition to="Get Request Type"/>
  </Step>
  <Step action="call:getRequestType" name="Get Request Type" posX="133" posY="5" resultVariable="requestType">
    <Arg name="defaultValue" value="leaver"/>
    <Transition to="Remove IdentityIQ Artifacts Ownership"/>
  </Step>
  <Step action="call:reassignOwnership" name="Remove IdentityIQ Artifacts Ownership" posX="277" posY="7" resultVariable="ownershipMap">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="plan" value="ref:immediatePlan"/>
    <Transition to="Notify IdentityIQ Artifacts Reassignment" when="!(ownershipMap.isEmpty())"/>
    <Transition to="Remove Identity Ownership"/>
  </Step>
  <Step action="sendEmail" icon="Default" name="Notify IdentityIQ Artifacts Reassignment" posX="453" posY="1">
    <Arg name="plan" value="ref:immediatePlan"/>
    <Arg name="ownershipMap" value="ref:ownershipMap"/>
    <Arg name="emailSubject" value="Workitems/Artifacts"/>
    <Arg name="to" value="ref:identityManager"/>
    <Arg name="template">
      <Script>
        <Source>
                
                    if(isTerminateIdentity) {
                        return sailpoint.object.RapidSetupConfigUtils.getString("businessProcesses,terminate,email,ownershipReassignment");
                    } else {
                        return sailpoint.object.RapidSetupConfigUtils.getString("businessProcesses,leaver,email,ownershipReassignment");
                    }
                
            </Source>
      </Script>
    </Arg>
    <Arg name="refIdentityDisplayName">
      <Script>
        <Source>
                
                    sailpoint.rapidsetup.tools.EmailTools.getIdentityDisplayName(context, identityName);
                
            </Source>
      </Script>
    </Arg>
    <Arg name="recipientDisplayName">
      <Script>
        <Source>
                
                    sailpoint.rapidsetup.tools.EmailTools.getIdentityDisplayName(context, identityManager);
                
            </Source>
      </Script>
    </Arg>
    <Transition to="Remove Identity Ownership"/>
  </Step>
  <Step action="call:executeRemoveIdentityOwnership" name="Remove Identity Ownership" posX="326" posY="108" resultVariable="identityOwnershipMap">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="requestType" value="ref:requestType"/>
    <Arg name="plan" value="ref:immediatePlan"/>
    <Transition to="Notify Identity Owners Reassignment" when="!(identityOwnershipMap.isEmpty())"/>
    <Transition to="Auto Reject Pending Requests"/>
  </Step>
  <Step action="sendEmail" icon="Default" name="Notify Identity Owners Reassignment" posX="556" posY="124">
    <Arg name="plan" value="ref:immediatePlan"/>
    <Arg name="ownershipMap" value="ref:identityOwnershipMap"/>
    <Arg name="emailSubject" value="Identity"/>
    <Arg name="to" value="ref:identityManager"/>
    <Arg name="template">
      <Script>
        <Source>
                
                    if(isTerminateIdentity) {
                        return sailpoint.object.RapidSetupConfigUtils.getString("businessProcesses,terminate,email,ownershipReassignment");
                    } else {
                        return sailpoint.object.RapidSetupConfigUtils.getString("businessProcesses,leaver,email,ownershipReassignment");
                    }
                
            </Source>
      </Script>
    </Arg>
    <Arg name="refIdentityDisplayName">
      <Script>
        <Source>
                
                    sailpoint.rapidsetup.tools.EmailTools.getIdentityDisplayName(context, identityName);
                
            </Source>
      </Script>
    </Arg>
    <Arg name="recipientDisplayName">
      <Script>
        <Source>
                
                    sailpoint.rapidsetup.tools.EmailTools.getIdentityDisplayName(context, identityManager);
                
            </Source>
      </Script>
    </Arg>
    <Transition to="Auto Reject Pending Requests"/>
  </Step>
  <Step action="call:rejectApprovalWorkItems" name="Auto Reject Pending Requests" posX="339" posY="202">
    <Arg name="identityName" value="ref:identityName"/>
    <Transition to="Clear Authentication Questions"/>
  </Step>
  <Step action="call:clearAuthenticationQuestionsAndPassword" name="Clear Authentication Questions" posX="341" posY="322">
    <Arg name="identityName" value="ref:identityName"/>
    <Transition to="Set Approval Scheme"/>
  </Step>
  <Step action="call:updateApprovalScheme" name="Set Approval Scheme" posX="343" posY="415">
    <Arg name="requestType" value="ref:requestType"/>
    <Transition to="Calculate Birthright Roles"/>
  </Step>
  <Step action="call:calculateBirthrightRoles" name="Calculate Birthright Roles" posX="414" posY="483" resultVariable="birthrightRoles">
    <Arg name="identityName" value="ref:identityName"/>
    <Transition to="Get Immediate Plan Builder"/>
  </Step>
  <Step action="call:getLeaverPlanBuilder" name="Get Immediate Plan Builder" posX="565" posY="482" resultVariable="leaverPlanBuilder">
    <Arg name="birthrightRoles" value="ref:birthrightRoles"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="requestType" value="ref:requestType"/>
    <Arg name="reasonComments" value="ref:reasonComments"/>
    <Arg name="isTerminateIdentity" value="ref:isTerminateIdentity"/>
    <Transition to="Build Immediate Plan"/>
  </Step>
  <Step name="Build Immediate Plan" posX="565" posY="380" resultVariable="immediatePlan">
    <Script>
      <Source>
                
                return leaverPlanBuilder.buildPlan();
                
            </Source>
    </Script>
    <Transition to="Extract Pam Plans"/>
  </Step>
  <Step name="Extract Pam Plans" posX="570" posY="257" resultVariable="pamPlans">
    <Arg name="immediatePlan" value="ref:immediatePlan"/>
    <Script>
      <Source>
                
                    return leaverPlanBuilder.extractPamPlans(immediatePlan );
                
            </Source>
    </Script>
    <Transition to="Process Pam Plans"/>
  </Step>
  <Step name="Process Pam Plans" posX="706" posY="207">
    <Arg name="pamPlans" value="ref:pamPlans"/>
    <Script>
      <Source>
                
                    return leaverPlanBuilder.processPamPlans(pamPlans, approvalScheme);
                
            </Source>
    </Script>
    <Transition to="Process Plan" when="script:(immediatePlan != null &amp;&amp; !immediatePlan.isEmpty())"/>
    <Transition to="Get Deferred Plan Builder"/>
  </Step>
  <Step name="Process Plan" posX="773" posY="328">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="plan" value="ref:immediatePlan"/>
    <Arg name="noTriggers" value="true"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="approvalScheme" value="ref:approvalScheme"/>
    <Arg name="saveUnmanagedPlan_WithProjectArgument" value="ref:saveUnmanagedPlan_WithProjectArgument"/>
    <Arg name="policyScheme" value="ref:policyScheme"/>
    <Arg name="notificationScheme" value="ref:notificationScheme"/>
    <Return name="approvalSet" to="approvalSet"/>
    <Return name="project" to="project"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="LCM Provisioning"/>
    </WorkflowRef>
    <Transition to="Notify Manager" when="project != null &amp;&amp; project.getPlans() != null &amp;&amp; project.getPlans().size() &gt; 0"/>
    <Transition to="Get Deferred Plan Builder"/>
  </Step>
  <Step action="sendEmail" icon="Default" name="Notify Manager" posX="829" posY="176">
    <Arg name="plan" value="ref:immediatePlan"/>
    <Arg name="to">
      <Script>
        <Source>
              
                    sailpoint.rapidsetup.tools.EmailTools.getIdentityNameForNotification(context, workflow,
                              identityName, project, true);
                
            </Source>
      </Script>
    </Arg>
    <Arg name="template">
      <Script>
        <Source>
              
                    if(isTerminateIdentity) {
                        return sailpoint.object.RapidSetupConfigUtils.getString("businessProcesses,terminate,email,terminateCompleted");
                    } else {
                        return sailpoint.object.RapidSetupConfigUtils.getString("businessProcesses,leaver,email,leaverCompleted");
                    }
                
            </Source>
      </Script>
    </Arg>
    <Arg name="refIdentityDisplayName">
      <Script>
        <Source>
              
                    sailpoint.rapidsetup.tools.EmailTools.getIdentityDisplayName(context, identityName);
                
            </Source>
      </Script>
    </Arg>
    <Arg name="recipientDisplayName">
      <Script>
        <Source>
              
                    sailpoint.rapidsetup.tools.EmailTools.getManagerOrAltIdentityDisplayName(context, identityName);
                
            </Source>
      </Script>
    </Arg>
    <Arg name="disableStaticManagerContent">
      <Script>
        <Source>
              
                    sailpoint.object.RapidSetupConfigUtils.getBoolean("email,disableStaticManagerContent");
                
            </Source>
      </Script>
    </Arg>
    <Arg name="provisioningErrors">
      <Script>
        <Source>
                
                    sailpoint.rapidsetup.tools.EmailTools.getProvisioningErrors(context, project);
                
            </Source>
      </Script>
    </Arg>
    <Transition to="Refresh Identity Links"/>
  </Step>
  <Step action="call:repairIdentity" name="Refresh Identity Links" posX="983" posY="315">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="plan" value="ref:immediatePlan"/>
    <Transition to="Get Deferred Plan Builder"/>
  </Step>
  <Step action="call:getLeaverPlanBuilder" name="Get Deferred Plan Builder" posX="846" posY="488" resultVariable="deferredLeaverPlanBuilder">
    <Arg name="birthrightRoles" value="ref:birthrightRoles"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="requestType" value="ref:requestType"/>
    <Arg name="reasonComments" value="ref:reasonComments"/>
    <Transition to="Build Deferred Plan"/>
  </Step>
  <Step name="Build Deferred Plan" posX="1020" posY="487" resultVariable="deferredPlans">
    <Script>
      <Source>
                
                return deferredLeaverPlanBuilder.buildDeferredPlans();
                
            </Source>
    </Script>
    <Transition to="Extract Deferred Pam Plans"/>
  </Step>
  <Step name="Extract Deferred Pam Plans" posX="1050" posY="606" resultVariable="deferredPamPlans">
    <Arg name="deferredPlans" value="ref:deferredPlans"/>
    <Script>
      <Source>
                
                    return deferredLeaverPlanBuilder.extractDeferredPamPlans(deferredPlans);
                
            </Source>
    </Script>
    <Transition to="Schedule Deferred Pam Plan"/>
  </Step>
  <Step action="call:executeLeaverPamDeferActions" name="Schedule Deferred Pam Plan" posX="1063" posY="430">
    <Arg name="noTriggers" value="true"/>
    <Arg name="approvalScheme" value="ref:approvalScheme"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="notificationScheme" value="ref:notificationScheme"/>
    <Arg name="workflow" value="PAM Identity Provisioning"/>
    <Arg name="requestType" value="ref:requestType"/>
    <Arg name="isTerminateIdentity" value="ref:isTerminateIdentity"/>
    <Arg name="reasonComments" value="ref:reasonComments"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="policyScheme" value="ref:policyScheme"/>
    <Arg name="appPlans" value="ref:deferredPamPlans"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="deferredPlans" value="ref:deferredPlans"/>
    <Arg name="deferredPamPlans" value="ref:deferredPamPlans"/>
    <Transition to="Schedule Deferred Plan" when="script:(deferredPlans != null &amp;&amp; !deferredPlans.isEmpty())"/>
    <Transition to="Execute Leaver Post Rule"/>
  </Step>
  <Step action="call:executeLeaverDeferActions" name="Schedule Deferred Plan" posX="1293" posY="480">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="appPlans" value="ref:deferredPlans"/>
    <Arg name="noTriggers" value="true"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="workflow" value="LCM Provisioning"/>
    <Arg name="requestType" value="ref:requestType"/>
    <Arg name="reasonComments" value="ref:reasonComments"/>
    <Arg name="approvalScheme" value="ref:approvalScheme"/>
    <Arg name="isTerminateIdentity" value="ref:isTerminateIdentity"/>
    <Arg name="policyScheme" value="ref:policyScheme"/>
    <Arg name="notificationScheme" value="ref:notificationScheme"/>
    <Arg name="source" value="ref:source"/>
    <Transition to="Execute Leaver Post Rule"/>
  </Step>
  <Step action="call:executePostLeaverRule" name="Execute Leaver Post Rule" posX="1340" posY="238">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="requestType" value="ref:requestType"/>
    <Arg name="project" value="ref:project"/>
    <Transition to="Stop"/>
  </Step>
  <Step icon="Stop" name="Stop" posX="1338" posY="118"/>
</Workflow>
<Workflow explicitTransitions="true" libraries="RapidSetup" name="RapidSetup - Mover" type="IdentityLifecycle">
  <Variable input="true" name="trigger">
    <Description>The IdentityTrigger</Description>
  </Variable>
  <Variable input="true" name="event" transient="true">
    <Description>
            The IdentityChangeEvent.  It can be used to build
            the provisioning plan, but does not need to be
            persisted with the case, so marked as transient.
        </Description>
  </Variable>
  <Variable input="true" name="identityName">
    <Description>The name of the identity.</Description>
  </Variable>
  <Variable editable="true" input="true" name="requestType"/>
  <Variable input="true" name="approvalScheme" output="true"/>
  <Variable initializer="Lifecycle" name="flow"/>
  <Variable initializer="RapidSetup" input="true" name="source">
    <Description>
            String version of sailpoint.object.Source to indicate
            where the request originated.  Defaults to RapidSetup.
        </Description>
  </Variable>
  <Variable initializer="none" input="true" name="policyScheme">
    <Description>
            A String that specifies how policy checks effect the overall
            process.

            none - disabled policy checking

            interactive -  allow requester to remove request items which are causing violations

            continue -  continue if policy violations are found

            fail -  fail and exit the workflow if any policy violations are found
        </Description>
  </Variable>
  <Variable initializer="none" input="true" name="notificationScheme">
    <Description>
            A string that specifies who should be notified via the LCM workflows when the request has been completed.
            The value can be null or a csv of one or more of the following options.

            none or null
            disable notifications

            user
            Identity that is being update will be notified.

            manager
            The manager of the Identity that is being updated will be notified.

            requester
            The person that has requested the update will be notified.
        </Description>
  </Variable>
  <Variable name="birthrightRoles"/>
  <Variable name="plan"/>
  <Variable name="project"/>
  <Variable name="isCertGenCompleted"/>
  <Variable initializer="true" name="saveUnmanagedPlan_WithProjectArgument">
    <Description>
            Set to true because we are passing the project in to save unmanaged plan as an argument.
        </Description>
  </Variable>
  <Description>Perform Mover-specific processing for the identity</Description>
  <Step icon="Start" name="Start" posX="28" posY="10">
    <Transition to="Get Request Type"/>
  </Step>
  <Step action="call:getRequestType" name="Get Request Type" posX="98" posY="10" resultVariable="requestType">
    <Arg name="defaultValue" value="mover"/>
    <Transition to="Set Approval Scheme"/>
  </Step>
  <Step action="call:updateApprovalScheme" name="Set Approval Scheme" posX="251" posY="82">
    <Arg name="requestType" value="ref:requestType"/>
    <Transition to="Launch Certification" when="call:isMoverCertificationEnabled"/>
    <Transition to="Calculate Birthright Roles" when="call:isMoverJoinerEnabled"/>
    <Transition to="Execute Mover Post Rule"/>
  </Step>
  <Step action="call:launchCertificationFromTemplate" icon="Default" name="Launch Certification" posX="275" posY="99" resultVariable="isCertGenCompleted">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="templateName" value="CertificationTemplate-RapidSetup-Mover"/>
    <Arg name="certGenMaxWaitSeconds" value="5"/>
    <Arg name="params" value="call:getMoverCertificationConfiguration"/>
    <Transition to="Wait for cert gen" when="script:!isCertGenCompleted"/>
    <Transition to="Calculate Birthright Roles" when="call:isMoverJoinerEnabled"/>
    <Transition to="Execute Mover Post Rule"/>
  </Step>
  <Step action="call:certWaitExpired" name="Wait for cert gen" posX="584" posY="16" wait="script: new Integer(5)">
    <Description>
            Pause the workflow, and wait in the background for the certification
            generation to have long enough to finish.  The wait is 5 minutes,
            unless you change the value of wait param for this step.
        </Description>
    <Transition to="Calculate Birthright Roles" when="call:isMoverJoinerEnabled"/>
    <Transition to="Execute Mover Post Rule"/>
  </Step>
  <Step action="call:calculateBirthrightRoles" name="Calculate Birthright Roles" posX="163" posY="260" resultVariable="birthrightRoles">
    <Arg name="identityName" value="ref:identityName"/>
    <Transition to="Build Plan"/>
  </Step>
  <Step action="call:buildMoverPlan" name="Build Plan" posX="378" posY="260" resultVariable="plan">
    <Arg name="birthrightRoles" value="ref:birthrightRoles"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Transition to="Execute Mover Post Rule" when="script:(plan == null)"/>
    <Transition to="Process Plan"/>
  </Step>
  <Step name="Process Plan" posX="736" posY="260">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="noTriggers" value="true"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="approvalScheme" value="ref:approvalScheme"/>
    <Arg name="saveUnmanagedPlan_WithProjectArgument" value="ref:saveUnmanagedPlan_WithProjectArgument"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="policyScheme" value="ref:policyScheme"/>
    <Arg name="notificationScheme" value="ref:notificationScheme"/>
    <Return name="approvalSet" to="approvalSet"/>
    <Return name="project" to="project"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="LCM Provisioning"/>
    </WorkflowRef>
    <Transition to="Execute Mover Post Rule"/>
  </Step>
  <Step action="call:executePostMoverRule" name="Execute Mover Post Rule" posX="884" posY="10">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="requestType" value="ref:requestType"/>
    <Arg name="project" value="ref:project"/>
    <Transition to="Stop"/>
  </Step>
  <Step icon="Stop" name="Stop" posX="1009" posY="10"/>
</Workflow>
<Workflow explicitTransitions="true" name="Importer" type="">
  <Variable name="result" output="true"/>
  <Variable initializer="true" name="transient"/>
  <Variable input="true" name="resource"/>
  <Variable input="true" name="operation"/>
  <Variable name="payload" output="true" type="java.lang.Object"/>
  <Step icon="Start" name="Start" posX="67" posY="354">
    <Script>
      <Source>
serilog=org.apache.commons.logging.LogFactory.getLog("sailpoint.iiqda.Importer");
serilog.debug("operation="+operation);

	  </Source>
    </Script>
    <Transition to="Import">
      <Script>
        <Source>return "Import".equals(operation);</Source>
      </Script>
    </Transition>
    <Transition to="Get Object Types">
      <Script>
        <Source>return "getObjectTypes".equals(operation);</Source>
      </Script>
    </Transition>
    <Transition to="Get Objects" when="&quot;getObjects&quot;.equals(operation);"/>
    <Transition to="Get Latest Objects" when="&quot;getLatestObjects&quot;.equals(operation);"/>
    <Transition to="Get Object" when="&quot;getObject&quot;.equals(operation);"/>
    <Transition to="Get Jar Size" when="&quot;jarSize&quot;.equals(operation);"/>
    <Transition to="Get Jar Data" when="&quot;jarData&quot;.equals(operation);"/>
    <Transition to="Get Task List" when="&quot;getTaskList&quot;.equals(operation);"/>
    <Transition to="Run Task" when="&quot;runTask&quot;.equals(operation);"/>
    <Transition to="Terminate Task" when="&quot;terminateTask&quot;.equals(operation);"/>
    <Transition to="Get Task Result" when="&quot;getTaskResult&quot;.equals(operation);"/>
    <Transition to="Invalid operation"/>
  </Step>
  <Step icon="Provision" name="Import" posX="352" posY="121" resultVariable="payload">
    <Script>
      <Source>
import sailpoint.server.Importer;
import sailpoint.tools.GeneralException;
import sailpoint.web.system.ImportBean.ImportMonitor;

serilog=org.apache.commons.logging.LogFactory.getLog("sailpoint.iiqda.Importer");
serilog.debug("--");

String fileData = workflow.get("resource");
serilog.debug("fileData="+fileData);

ImportMonitor _monitor = new ImportMonitor();
Importer importer = new Importer(context, _monitor);
serilog.debug("got importer");
try {
    importer.importXml(fileData);
    context.commitTransaction();
    workflow.put("result", "success");
} catch (Exception ex) {
  serilog.error("Exception :"+ex);
  workflow.put("result", "failure");
  if (ex instanceof GeneralException) {
	GeneralException ge = (GeneralException) ex;
	return ge.getMessageInstance();
  } else {
	return ex.getLocalizedMessage();
  }
}
return "";
      </Source>
    </Script>
    <Transition to="Stop"/>
  </Step>
  <Step icon="Default" name="Get Object Types" posX="354" posY="194" resultVariable="payload">
    <Script>
      <Source>
import sailpoint.object.ClassLists;

List l = new ArrayList();

for (Class clazz: ClassLists.MajorClasses) {
  l.add(clazz.getSimpleName());
}
// Add this in, its a special type of Identity
l.add("Workgroup");
Collections.sort(l);

workflow.put("result", "success");
return l;
      </Source>
    </Script>
    <Transition to="Stop"/>
  </Step>
  <Step icon="Default" name="Invalid operation" posX="354" posY="44" resultVariable="payload">
    <Script>
      <Source>
workflow.put("result", "failure");
return "Invalid Operation";
      </Source>
    </Script>
    <Transition to="Stop"/>
  </Step>
  <Step icon="Stop" name="Stop" posX="509" posY="351"/>
  <Step icon="Default" name="Get Objects" posX="355" posY="272" resultVariable="payload">
    <Script>
      <Source>
// objectType is a 'simple' class name (no package)
// look it up in ClassList

import sailpoint.object.ClassLists;
import sailpoint.object.QueryOptions;
import sailpoint.object.Filter;

// Expect: java.lang.String objectType
// Expect: java.lang.String objectName

Class theClass=null;
boolean isWorkgroup=false;

if("Workgroup".equals(objectType)) {
  objectType="Identity";
  isWorkgroup=true;
}

for (Class clazz: ClassLists.MajorClasses) {
  if(clazz.getSimpleName().equals(objectType) ){
    theClass=clazz;
    break;
  }
}

if(theClass==null) {
  workflow.put("result", "failure");
  return "Could not find object type '"+objectType+"'";
}

QueryOptions qo=new QueryOptions();
if (isWorkgroup) {
  qo.addFilter(Filter.eq("workgroup", Boolean.TRUE));
}
String searchField="name";
if ("TaskSchedule".equals(objectType)) {
  searchField="id";
}
Iterator iter=context.search(theClass, qo, searchField);

List objects=new ArrayList();
while(iter.hasNext()) {
  Object[] obj=iter.next();
  objects.add(obj[0]);
}
workflow.put("result", "success");
return objects;
      </Source>
    </Script>
    <Transition to="Stop"/>
  </Step>
  <Step icon="Default" name="Get Task List" posX="355" posY="272" resultVariable="payload">
    <Script>
      <Source>
import sailpoint.object.TaskDefinition;

serilog=org.apache.commons.logging.LogFactory.getLog("sailpoint.iiqda.Importer.GetTaskList");
List tasks=context.getObjects(TaskDefinition.class);
serilog.debug("got "+tasks.size());
List objects=new ArrayList();
for (TaskDefinition td: tasks) {
  if(!td.isHidden() &amp;&amp; !td.isTemplate() ){
    objects.add(td.getName());
  }
}
workflow.put("result", "success");
serilog.debug("returning "+objects.size()+" tasks");
return objects;
      </Source>
    </Script>
    <Transition to="Stop"/>
  </Step>
  <Step icon="Default" name="Run Task" posX="355" posY="272" resultVariable="payload">
    <Script>
      <Source>
import sailpoint.object.TaskDefinition;
import sailpoint.api.TaskManager;
import sailpoint.object.TaskSchedule;
import sailpoint.object.TaskResult;

// Expect: java.lang.String taskName

serilog=org.apache.commons.logging.LogFactory.getLog("sailpoint.iiqda.Importer.RunTask");
serilog.debug("Run Task: "+taskName);

TaskManager tm = new TaskManager(context);
Map args=new HashMap();
TaskDefinition td=context.getObjectByName(TaskDefinition.class, taskName);
if(td==null) {
  workflow.put("result", "failure");
  return "Task '"+taskName+"' not found";
}

TaskSchedule ts=tm.run(td, args);
TaskResult tr=null;
while (tr==null) {
  tr=ts.getLatestResult();
  serilog.debug("task result="+tr);
}

workflow.put("result", "success");
return tr.getId();
      </Source>
    </Script>
    <Transition to="Stop"/>
  </Step>
  <Step icon="Default" name="Terminate Task" posX="355" posY="272" resultVariable="payload">
    <Script>
      <Source>
import sailpoint.api.TaskManager;
import sailpoint.object.TaskResult;

// Expect: java.lang.String taskName
// Expect: java.lang.String taskId

serilog=org.apache.commons.logging.LogFactory.getLog("sailpoint.iiqda.Importer.TerminateTask");
serilog.debug("Terminate Task: "+taskId);

TaskResult tr=context.getObjectById(TaskResult.class, taskId);
if(tr==null) {
  workflow.put("result", "failure");
  return "taskId "+taskId+" not found";
}
TaskManager tm=new TaskManager(context);
tm.terminate(tr);

workflow.put("result", "success");
return tr.getId();
      </Source>
    </Script>
    <Transition to="Stop"/>
  </Step>
  <Step icon="Default" name="Get Task Result" posX="355" posY="272" resultVariable="payload">
    <Script>
      <Source>
import sailpoint.object.Attributes;
import sailpoint.object.TaskResult;
import sailpoint.tools.Internationalizer;
import sailpoint.tools.Message;

// Expect: java.lang.String taskId

serilog=org.apache.commons.logging.LogFactory.getLog("sailpoint.iiqda.Importer.GetTaskResult");
serilog.debug("Get Task Result: "+taskId);

if(taskId==null) {
  workflow.put("result", "failure");
  return "Must specify taskId";
}
TaskResult tr=context.getObjectById(TaskResult.class, taskId);
if(tr==null) {
  workflow.put("result", "failure");
  return "taskId "+taskId+" not found";
}
Map result=new HashMap();
result.put("name", tr.getName());
result.put("description", tr.getDefinition().getDescription().trim());
if (tr.getCompletionStatus()==null) {
  result.put("status", "pending..");
} else {
  String statusKey=tr.getCompletionStatus().getMessageKey();

  result.put("status", Internationalizer.getMessage(statusKey, Locale.ENGLISH));
}
result.put("progress", tr.getProgress());
result.put("started", tr.getLaunched().toString());
if(tr.getCompleted()!=null) {
  result.put("completed", tr.getCompleted().toString());
}
List errors=tr.getMessages();
if (errors!=null) {
  List flatErrors=new ArrayList();
  for (Message message: errors) {
    flatErrors.add(message.getLocalizedMessage());
  }
  result.put("errors", flatErrors);
}
Attributes attrs=tr.getAttributes();
if (attrs!=null) {
  Map flatAttrs=new HashMap();
  for (String key: attrs.getKeys()) {
    flatAttrs.put(key, attrs.getString(key));
  }
  result.put("attributes", flatAttrs);
}

workflow.put("result", "success");
return result;
      </Source>
    </Script>
    <Transition to="Stop"/>
  </Step>
  <Step icon="Default" name="Get Object" posX="353" posY="350" resultVariable="payload">
    <Script>
      <Source>
// objectType is a 'simple' class name (no package)
// look it up in ClassList

import sailpoint.object.ClassLists;
import sailpoint.object.SailPointObject;

// Expect: java.lang.String objectType
// Expect: java.lang.String objectName

serilog=org.apache.commons.logging.LogFactory.getLog("sailpoint.iiqda.Importer.getObject");

serilog.debug("objectType="+objectType);
serilog.debug("objectName="+objectName);

Class theClass=null;
if ("Workgroup".equals(objectType)) {
  objectType="Identity";
}
for (Class clazz: ClassLists.MajorClasses) {
  if(clazz.getSimpleName().equals(objectType) ){
    theClass=clazz;
    break;
  }
}

if(theClass==null) {
  workflow.put("result", "failure");
  return "Could not find object type '"+objectType+"'";
}

SailPointObject obj=context.getObjectByName(theClass, objectName);   
if(obj==null) {
  workflow.put("result", "failure");
  return "Could not find "+objectType+" '"+objectName+"'";
}
   
serilog.debug("obj="+obj);


workflow.put("result", "success");
return obj.toXml();
      </Source>
    </Script>
    <Transition to="Stop"/>
  </Step>
  <Step icon="Default" name="Get Jar Size" posX="356" posY="434" resultVariable="payload">
    <Script>
      <Source>
// jarName is the name of a jar in WEB-INF/lib
// return a JSON string of the binary

import java.io.File;
import java.io.InputStream;

import org.apache.commons.io.IOUtils;
import org.apache.commons.codec.binary.Base64;

import sailpoint.object.ClassLists;
import sailpoint.object.SailPointObject;

serilog=org.apache.commons.logging.LogFactory.getLog("sailpoint.iiqda.Importer.jarSize");

serilog.debug("jar="+jar);

if(jar==null||jar==void) {
  workflow.put("result", "failure");
  return("No JAR Specified");
}

URL url=this.getClass().getResource("/../lib/"+jar);
serilog.debug("url="+url);
if(url==null) {
  workflow.put("result", "failure");
  return("JAR '"+jar+"' not found");
}
serilog.debug("got URL");
File file=new File(url.toURI());

workflow.put("result", "success");
String ret=Long.toString(file.length());
serilog.debug("returning "+ret);
return ret
      </Source>
    </Script>
    <Transition to="Stop"/>
  </Step>
  <Step icon="Default" name="Get Jar Data" posX="356" posY="515" resultVariable="payload">
    <Script>
      <Source>
// jarName is the name of a jar in WEB-INF/lib
// return a JSON string of the binary

import java.io.File;
import java.io.InputStream;

import org.apache.commons.codec.binary.Base64;

import sailpoint.object.ClassLists;
import sailpoint.object.SailPointObject;

serilog=org.apache.commons.logging.LogFactory.getLog("sailpoint.iiqda.Importer.getJarData");

serilog.trace("jar="+jar);
serilog.trace("start="+start);
serilog.trace("length="+length);

iStart=Integer.parseInt(start);
iLength=Integer.parseInt(length);

if(jar==null||jar==void) {
  workflow.put("result", "failure");
  return("No JAR Specified");
}

URL url=this.getClass().getResource("/../lib/"+jar);
serilog.trace("url="+url);
if(url==null) {
  workflow.put("result", "failure");
  return("JAR '"+jar+"' not found");
}
File file=new File(url.toURI());

RandomAccessFile raFile=new RandomAccessFile(file, "r");
serilog.debug("skipping "+iStart+" bytes");
raFile.skipBytes(iStart);

byte[] buffer=new byte[iLength];

int bytesRead=raFile.read(buffer, 0, iLength);
serilog.trace("read "+bytesRead+" bytes");
if(bytesRead&lt;iLength) {
  serilog.debug("eof: found "+bytesRead+" bytes, not "+iLength);
  byte[] buf=new byte[bytesRead];
  System.arraycopy(buffer, 0, buf, 0, bytesRead);
  buffer=buf;
}

String out=Base64.encodeBase64String(buffer);

workflow.put("result", "success");
serilog.trace("returning "+out);
return out;
      </Source>
    </Script>
    <Transition to="Stop"/>
  </Step>
  <Step icon="Default" name="Get Latest Objects" posX="360" posY="599" resultVariable="payload">
    <Script>
      <Source>

import java.text.*;
import sailpoint.object.*;

// Expect: java.lang.String classes
// classes is a CSV list of the selected classes in the UI


// Declare a logger class for us to isolate these messages during aggregation.
serilog=org.apache.commons.logging.LogFactory.getLog("sailpoint.iiqda.importer.getLatestObjects");
// log.setLevel(Level.DEBUG);

// The maximuim number of objects to return back to the querying item.
int maxObjectsToReturn = 100;

// We return back a sorted array list of objects that were recently modified.
// Format of each CSV entry, with exampels below a header line:
//    objectType,  objectName,     modifiedDate
//    Application, AD-CorpDomain,  2014-09-17 14:35:15
//    Rule,        AD-Correlation, 2014-09-16 14:34:46
// etc.
// This workflow passes this list back to the caller.
ArrayList recentlyModifiedCSVStrings = new ArrayList();

// We decalre a TreeSet to store the recently modified records.  This allows
// us to keep track of the "maxObjectsToReturn" most recently modified objects.
TreeSet objStrTreeSet = new TreeSet();


// Certain classes do not contain modified dates, which is yucky.
// Mainually maintain a list of classes here that we know do not have
// modified dates.  We skip these classes from the import/export list.
// Some are missing the 'name' property as well, those get added here too.
ArrayList skipClasses = new ArrayList();
skipClasses.add("ApplicationActivity");
skipClasses.add("ApplicationScorecard");
skipClasses.add("AuditEvent");
skipClasses.add("AuthenticationQuestion");
skipClasses.add("BatchRequest");
skipClasses.add("DatabaseVersion");
skipClasses.add("GroupIndex");
skipClasses.add("Identity");             // We don't want to export each Id.
skipClasses.add("IdentityEntitlement");
skipClasses.add("IdentityHistoryItem");
skipClasses.add("IdentitySnapshot");     // We don't export Identity Snapshots.
skipClasses.add("JasperTemplate");
skipClasses.add("JasperResult");
skipClasses.add("ManagedAttribute");
skipClasses.add("MitigationExpiration");
skipClasses.add("PolicyViolation");      // We don't export Policy Violations.
skipClasses.add("Profile");
skipClasses.add("ProcessLog");
skipClasses.add("ProvisioningRequest");
skipClasses.add("QuickLinkOptions");
skipClasses.add("ResourceEvent");
skipClasses.add("RoleChangeEvent");
skipClasses.add("RoleIndex");
skipClasses.add("RoleMetadata");
skipClasses.add("RoleScorecard");
skipClasses.add("Scorecard");
skipClasses.add("Server");              // Skip the Server objects.
skipClasses.add("SyslogEvent");
skipClasses.add("TargetAssociation");
skipClasses.add("TaskSchedule");        // Included for invalid query options.
skipClasses.add("TaskResult");          // We don't export TaskResult.
skipClasses.add("UIPreferences");


List majClasses = new ArrayList();

if (classes==null) {
  // Ask sailpoint.object.ClassLists for what major classes are defined.
  for (Class clazz: ClassLists.MajorClasses) {  
    String simpleName = clazz.getSimpleName();
    if ( !skipClasses.contains(simpleName) ) {
       majClasses.add(clazz.getSimpleName());   
    }  
  }
  majClasses.add("Workgroup");
} else {
  String[] strClasses=classes.split(",");
  majClasses=Arrays.asList(strClasses);
}

Collections.sort(majClasses);
 



// We now have a list of all the major configurable IdentityIQ classes.
// Next we need to projection query pull back name, created, modified time 
// for each item.

// Use a projection query to initially pull back only the columns we need.
ArrayList resultColumns = new ArrayList();
resultColumns.add("id");
resultColumns.add("name");
resultColumns.add("created");
resultColumns.add("modified");

QueryOptions qo = new QueryOptions();
qo.setResultLimit(maxObjectsToReturn);
ArrayList orderings = new ArrayList();
orderings.add( new QueryOptions.Ordering( "modified", false ) );
orderings.add( new QueryOptions.Ordering( "created",  false ) );
qo.setOrderings(orderings);

for (String className : majClasses) {

    boolean isWorkgroup=false;    
    String fullClassName = "sailpoint.object." + className;
    
    if("Workgroup".equals(className)) {
      isWorkgroup=true;
    }

    serilog.debug("Examining class: " + fullClassName);
    


    Iterator it=null;
   
    if (isWorkgroup) {
      QueryOptions wgQo=new QueryOptions(qo);
      wgQo.addFilter(Filter.eq("workgroup", Boolean.TRUE));
      it = context.search(Identity.class, wgQo, resultColumns);
    } else {
      Class clazz = Class.forName(fullClassName);
      if (null == clazz) {
        serilog.error("could not load class forName: " + fullClassName);
        continue;
      }
      it = context.search(clazz, qo, resultColumns);
    }

   while (it.hasNext()) {
      Object [] result = it.next();
      String id         = (String) result[0];
      String name       = (String) result[1];
      Date createdDate  = (java.util.Date) result[2];
      Date modifiedDate = (java.util.Date) result[3];
      
      // If no modified date substituting 
      if (null == createdDate) {
         createdDate = new Date();
      } 

      // If no modified date substituting 
      if (null == modifiedDate) {
         modifiedDate = createdDate;
      } 
       
      String created  = createdDate.toString();
      String modified = modifiedDate.toString();
      
      // Create a date string sortable by string operations.
      DateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
      String createdSortable  = formatter.format(createdDate);
      String modifiedSortable = formatter.format(modifiedDate);
      
      // We buld a sortable delimited string, with the modified date first so 
      // that the date primarily controls the sorting.  The format of the string:
      //     modifiedDate,className,objectName,objectId
      // Once we have the sortable string we put that in a TreeSet so that
      // we can monitor the size of the tree set and only keep the N most 
      // recently created/modified objects in the tree.
      String sortableString = 
         modifiedSortable + "," + className + "," + name + "," + id;
      
      serilog.debug("object:" + sortableString);
       
      // serilog.debug("Class: " + className + " id:" + id + " modified:" + modifiedSortable + "  name:" + name);
      
      serilog.debug("objStrTreeSet.size(): " + objStrTreeSet.size());
      
      if (objStrTreeSet.size() &lt; maxObjectsToReturn) {
      
         // We have not added the max objects to the tree set, add this one.
         objStrTreeSet.add(sortableString);
               
      } else {
      
         // The tree set has the full number of objects.  If this new
         // object's modified date is older than the oldest in the tree set 
         // then do not add it.   Otherwise, add it to the tree set
         // and then remove the lowest modified date from the tree set.
         
         String leastRecentlyModified = objStrTreeSet.first();
         if ( 0 &gt; sortableString.compareTo(leastRecentlyModified) ) {
            serilog.debug("older than oldest: skipping");
            // The current objects modified date is earlier than the oldest
            // in the tree set.  Do not add the current object to the tree set.
         } else {
         
            serilog.debug("newer than oldest: adding to list");
            // The current object is more recently modified than at least one
            // object in the tree set.  Add the current object to the tree set
            // and remove the lowest object in the tree set.
            objStrTreeSet.add(sortableString);
            objStrTreeSet.remove(leastRecentlyModified);            
         
         }
      
      }
      
   }   

}

// At this point we have a populated TreeSet of objStrTreeSet size.  This
// has the objStrTreeSet most recently modified objects in the IdentityIQ 
// system.  Convert that to an ArrayList of strings and return that to 
// the caller for passing back to Eclipse or other external tooling.
while ( 0 != objStrTreeSet.size() ) {
  String mostRecentlyModified = objStrTreeSet.last();
  recentlyModifiedCSVStrings.add(mostRecentlyModified);
  objStrTreeSet.remove(mostRecentlyModified);  
}

workflow.put("result", "success");
return recentlyModifiedCSVStrings;

      </Source>
    </Script>
    <Transition to="Stop"/>
  </Step>
</Workflow>
<Workflow explicitTransitions="true" name="Preferred_Attribute_Change_Form" type="LCMProvisioning">
  <Variable input="true" name="quickLinkIdentityId"/>
  <Variable name="identityName">
    <Description>The name of the identity will be  update here.</Description>
    <Script>
      <Source>
        
 if(quickLinkIdentityId!=null) {
 Identity identity = context.getObjectById(Identity.class,quickLinkIdentityId);
 return identity.getName();
 }
        
</Source>
    </Script>
  </Variable>
  <Variable name="plan"/>
  <Variable initializer="true" input="true" name="trace"/>
  <Variable input="true" name="requester"/>
  <Variable name="identityModel"/>
  <Step icon="Start" name="Start" posX="20" posY="20">
    <Script>
      <Source>
        
log.error("------------------starting the workflow----------------------");
log.error("Name:------------&gt;"+identityName);
log.error("Requested by:----------&gt;"+requester);
log.error("Id:-----------&gt; "+quickLinkIdentityId);
        
</Source>
    </Script>
    <Transition to="initialize"/>
  </Step>
  <Step action="getIdentityModel" icon="Default" name="initialize" posX="272" posY="16" resultVariable="identityModel">
    <Arg name="identityName" value="ref:identityName"/>
    <Description>Initialize Identity Model.</Description>
    <Transition to="prefferedName"/>
  </Step>
  <Step icon="Default" name="prefferedName" posX="497" posY="194">
    <Approval name="Preferred_Form" owner="spadmin" return="identityModel" send="identityModel">
      <Arg name="workItemFormBasePath" value="identityModel"/>
      <Form name="Preferred_Form">
        <Attributes>
          <Map>
            <entry key="pageTitle" value="Preferred_Form"/>
          </Map>
        </Attributes>
        <Section name="prefferedName">
          <Field displayName="fullName" name="displayName" type="string"/>
          <Field displayName="uid" name="uid" type="string"/>
          <Field displayName="Mail" name="email" type="string"/>
          <Field displayName="postalAddress" name="postalAddress" type="string"/>
          <Field displayName="prefferedName" name="prefferedName" type="string"/>
        </Section>
        <Button action="next" label="Next"/>
        <Button action="cancel" label="Cancel"/>
      </Form>
    </Approval>
    <Transition to="prefferedName_Rule"/>
  </Step>
  <Step name="prefferedName_Rule" posX="657" posY="12" resultVariable="plan">
    <Script>
      <Source>
        
        
import java.util.ArrayList;
import sailpoint.api.Provisioner;
import sailpoint.object.Application;
import sailpoint.object.Identity;
import sailpoint.object.ProvisioningPlan;
import sailpoint.object.ProvisioningPlan.AccountRequest;
import sailpoint.object.ProvisioningPlan.AttributeRequest;
import sailpoint.object.Workflow;



 log.error("identityName:-----------&gt; " + identityName);

 Identity identityName1 = context.getObjectByName(Identity.class, identityName);
        
    log.error("identityName1:-----------&gt;" + identityName1.toXml());
        
 ProvisioningPlan plan = new ProvisioningPlan();
 ArrayList accountRequestList = new ArrayList();



 plan.setIdentity(identityName1);


 AccountRequest adAccountRequest = new AccountRequest();

     adAccountRequest.setApplication("IIQ");
 adAccountRequest.setOperation(AccountRequest.Operation.Modify);
     adAccountRequest.setNativeIdentity(identityName);

 log.error("IdentityModel:================&gt;"+identityModel);
        
        
        
 AttributeRequest prefferedNameReq = new AttributeRequest("prefferedName",identityModel.get("prefferedName"));
        adAccountRequest.add(prefferedNameReq);


 log.error("prefferedNameReq:================&gt;"+ identityModel.get("prefferedName"));


 accountRequestList.add(adAccountRequest);
 plan.setAccountRequests(accountRequestList);



 log.error("executed Plan:===============&gt;" + plan.toXml());
        
        
 return plan;
      </Source>
    </Script>
    <Transition to="LCM Provisioning"/>
  </Step>
  <Step icon="Default" name="LCM Provisioning" posX="891" posY="186">
    <Arg name="identityEmailTemplate"/>
    <Arg name="enableRetryRequest"/>
    <Arg name="securityOfficerElectronicSignature"/>
    <Arg name="fallbackApprover"/>
    <Arg name="endOnManualWorkItems"/>
    <Arg name="userEmailTemplate"/>
    <Arg name="policiesToCheck"/>
    <Arg name="project"/>
    <Arg name="workItemComments"/>
    <Arg name="identityRequestId"/>
    <Arg name="approvalSplitPoint"/>
    <Arg name="source"/>
    <Arg name="identityDisplayName"/>
    <Arg name="foregroundProvisioning"/>
    <Arg name="ownerElectronicSignature"/>
    <Arg name="batchRequestItemId"/>
    <Arg name="saveUnmanagedPlan_WithProjectArgument"/>
    <Arg name="splitPlans"/>
    <Arg name="doRefresh"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="flow"/>
    <Arg name="identityElectronicSignature"/>
    <Arg name="identityName"/>
    <Arg name="approvalSet"/>
    <Arg name="violationReviewDecision"/>
    <Arg name="filterRejects"/>
    <Arg name="splitProjects"/>
    <Arg name="requireCommentsForDenial"/>
    <Arg name="requesterEmailTemplate"/>
    <Arg name="approvalEmailTemplate"/>
    <Arg name="ticketManagementApplication"/>
    <Arg name="securityOfficerName"/>
    <Arg name="approvingIdentities"/>
    <Arg name="managerEmailTemplate"/>
    <Arg name="ticketId"/>
    <Arg name="approvalScheme" value="none"/>
    <Arg name="allowRequestsWithViolations"/>
    <Arg name="workItemPriority"/>
    <Arg name="managerElectronicSignature"/>
    <Arg name="requireViolationReviewComments"/>
    <Arg name="splitApprovalSet"/>
    <Arg name="approvalMode"/>
    <Arg name="trace"/>
    <Arg name="endOnProvisioningForms"/>
    <Arg name="splitWorkItemComments"/>
    <Arg name="requireCommentsForApproval"/>
    <Arg name="notificationScheme"/>
    <Arg name="policyViolations"/>
    <Arg name="policyScheme"/>
    <Arg name="setPreviousApprovalDecisions"/>
    <Arg name="optimisticProvisioning"/>
    <Arg name="securityOfficerEmailTemplate"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="LCM Provisioning"/>
    </WorkflowRef>
    <Transition to="Stop"/>
  </Step>
  <Step icon="Stop" name="Stop" posX="1067" posY="15"/>
</Workflow>
<Workflow configForm="Provisioning Workflow Config Form" explicitTransitions="true" handler="sailpoint.api.StandardWorkflowHandler" libraries="Identity,Role,PolicyViolation,LCM,BatchRequest" name="LCM Provisioning-MOCK" taskType="LCM" type="LCMProvisioning">
  <Variable input="true" name="identityName">
    <Description>The name of the identity being updated.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="endOnManualWorkItems">
    <Description>Option to skip requests with manual work items.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="endOnProvisioningForms">
    <Description>Option to skip requests with provisioning forms.</Description>
  </Variable>
  <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
    <Description>The displayName of the identity being updated.
      Query for this using a projection query and fall back to the name.</Description>
  </Variable>
  <Variable input="true" name="plan">
    <Description>The provisioning plan ready to execute.</Description>
  </Variable>
  <Variable input="true" name="flow">
    <Description>The name of the LCM flow that launched this workflow.

      This is one of these three values:

      AccountsRequest
      EntitlementsRequest
      RolesRequest
      AttributeSync</Description>
  </Variable>
  <Variable editable="true" initializer="false" name="optimisticProvisioning">
    <Description>Set to true to enable optimistic provisioning.  This will cause
      changes to the entitlements compiled from role assignments to be
      applied immediately to the identity cube rather than waiting
      for the next refresh/reaggregation after the provisioning system
      completes the request.</Description>
  </Variable>
  <Variable editable="true" initializer="true" name="foregroundProvisioning">
    <Description>Normally provisioning is done in a step that uses the &amp;quot;background&amp;quot;
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to
      see the results of the request.</Description>
  </Variable>
  <Variable input="true" name="batchRequestItemId">
    <Description>Used by the batch interface to record back individual request item status. The specific item id for the individual request in the batch file.</Description>
  </Variable>
  <Variable editable="true" initializer="true" name="doRefresh">
    <Description>Set to true to cause an identity refresh after the changes in the plan
      have been provisioned.  This is normally off, you might want this on
      if you want modification of identity or link attributes to result in
      an immediate re-evaluation of assigned and detected roles.</Description>
  </Variable>
  <Variable initializer="manager, user" input="true" name="notificationScheme">
    <Description>A string that specifies who should be notified when the request has been complete.
     The value can be null or a csv of one or more of the following options.

     none or null
       disable notifications

     user
       Identity that is being update will be notified.

     manager
       The manager of the Identity that is being updated will be notified.

     requester
       The person that has requested the update will be notified.</Description>
  </Variable>
  <Variable initializer="LCM User Notification" input="true" name="userEmailTemplate">
    <Description>The email template to use for user notification.</Description>
  </Variable>
  <Variable initializer="LCM Requester Notification" input="true" name="requesterEmailTemplate">
    <Description>The email template to use for requester notification.</Description>
  </Variable>
  <Variable initializer="LCM Manager Notification" input="true" name="managerEmailTemplate">
    <Description>The email template to use for manager notification.</Description>
  </Variable>
  <Variable input="true" name="securityOfficerEmailTemplate">
    <Description>The email template to use for security officer notification.</Description>
  </Variable>
  <Variable initializer="serial" input="true" name="approvalMode">
    <Description>A string that specifies how we should handle the approvals.

        By default this is serial since most of these request with
        the exception of manager transfers will have only one approver.

        parallel
        Approvals are processed concurrently and there must be consensus,
        we wait for all approvers to approve.  The first approver that
        rejects terminates the entire approval.

        parallelPoll
        Approvals are processed concurrently but consensus is not required.
        All approvals will be processed, we don&amp;#39;t stop if there are any
        rejections.

        serial
        Approvals are processed one at a time and there must be consensus.
        The first approver that rejects terminates the entire approval.

        serialPoll
        Approvals are processed in order but consensus is not required.
        All approvals will be processed, we don&amp;#39;t stop if there are any
        rejections.  In effect we are &amp;quot;taking a poll&amp;quot; of the approvers.

        any
        Approvals are processed concurrently, the first approver to
        respond makes the decision for the group.</Description>
  </Variable>
  <Variable initializer="manager" input="true" name="approvalScheme">
    <Description>A csv string that specifies how approval items should be generated
      for the incoming request.

      The value can be &amp;quot;none&amp;quot;, in which case approvals are disabled.

      The value can also be a combination of any of the values below
      in any order, separated by commas. The order in which they are
      specified is the order in which they are processed:

      owner
        The object owner gets the approval item.
        For Role approvals this is the Role object owner.
        For Entitlement approvals this is the Entitlement object owner.

      manager
        The manager gets the approval item.

      securityOfficer
        The identity in the variable securityOfficerName gets the approval item.

      identity
        The identities/workgroups in the variable approvingIdentities get the approval item.</Description>
  </Variable>
  <Variable initializer="LCM Identity Update Approval" input="true" name="approvalEmailTemplate">
    <Description>The email template to use for approval notifications.</Description>
  </Variable>
  <Variable initializer="Normal" input="true" name="workItemPriority">
    <Description>The String version of a WorkItem.Priority. This variable is
       used to set the priority on all of the workitems generated
       as part of this workflow and also set on the IdentityRequest
       object.</Description>
  </Variable>
  <Variable input="true" name="securityOfficerName">
    <Description>The name of the identity that will be sent approvals
       during security officer approvals.</Description>
  </Variable>
  <Variable initializer="spadmin" input="true" name="fallbackApprover">
    <Description>A String that specifies the name of the Identity that will
      be assigned any approvals where the owner of the approver
      can&amp;#39;t be resolved. Example if the scheme is &amp;quot;owner&amp;quot; and the
      application doesn&amp;#39;t specify and owner.</Description>
  </Variable>
  <Variable initializer="continue" input="true" name="policyScheme">
    <Description>A String that specifies how policy checks effect the overall
      process.

      none - disabled policy checking

      continue -  continue if policy violations are found

      interactive -  allow requester to remove request items which are causing violations

      fail -  this option will cause the workflow to terminate immediately if any policy violations are found.
              Note that the requester will not be notified that the workflow has terminated.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="enableRetryRequest">
    <Description>When set to true it will disable the workflow retry loop and let the
      Provision step launch requests to handle the retries.  Enabling
      this flag will enable some older functionality.</Description>
  </Variable>
  <Variable input="true" name="policiesToCheck">
    <Description>A List of policies that should be checked. If this list is
      empty all violations will be checked. Used in combination
      with policyScheme.</Description>
  </Variable>
  <Variable initializer="LCM" input="true" name="source">
    <Description>String version of sailpoint.object.Source to indicate
      where the request originated.  Defaults to LCM.</Description>
  </Variable>
  <Variable initializer="true" name="trace">
    <Description>Used for debugging this workflow and when set to true trace
      will be sent to stdout.</Description>
  </Variable>
  <Variable name="approvalSet">
    <Description>This attributes is set during the &amp;quot;Build Approval Set&amp;quot; step,
       which builds this list by going through the ProvisioningPlan
       to build the line items that need to be approved,

       This variable includes all ApprovalItems that are part of
       the request process and is updated during the AfterScript
       of the approval process by assimilating the decisions
       and comments from the Approvals copy of the ApprovalItem.</Description>
  </Variable>
  <Variable initializer="true" name="allowRequestsWithViolations">
    <Description>If this variable is set to true, requesters will be able to proceed past
      the Policy Violation Review form without taking any action on
      policy violations resulting from the request. This is only relevant
      if policyScheme=interactive.</Description>
  </Variable>
  <Variable initializer="true" name="requireViolationReviewComments">
    <Description>If true, requesters will be required to enter in comments if they
      proceed with a request that will result in policy violations. This
      is only relevant if policyScheme=interactive.</Description>
  </Variable>
  <Variable name="project">
    <Description>ProvisioningProject which is just a compiled version of the ProvisioningPlan.</Description>
  </Variable>
  <Variable name="policyViolations">
    <Description>List of policy violations that were found during our initial policy scan.
       This list is passed into each work item so the approvers can see
       pending violations.</Description>
  </Variable>
  <Variable name="identityRequestId" output="true">
    <Description>The sequence id of the Identity request object which is stored in
       the name field of the identity request and auto-incremented.</Description>
  </Variable>
  <Variable name="violationReviewDecision">
    <Description>Decision made by the user in the Policy Violation Review step.
       This may be one of three choices:

       -ignore:   User is ignoring the violations and letting the request continue. If
                   requireViolationReviewComments=true the user will be required to enter
                   comments indicating why they are allowing the violations.

       -remediate: Indicates that the user removed the request items that were causing the
                   violations

       -cancel:   Indicates that the user decided to abandon the request, terminating the workflow.</Description>
  </Variable>
  <Variable name="workItemComments">
    <Description>Global comments accumulated during the workflow which should be shared
      with other approvals. When a new approval is created, the comments in this
      list will be added to the work item.</Description>
  </Variable>
  <Variable input="true" name="ticketManagementApplication">
    <Description>Name of the application that can handle ticket requests.
      When non-null the Manage Ticket Steps will be visited to open
      tickets during the workflow lifecycle.</Description>
  </Variable>
  <Variable name="ticketId">
    <Description>The id of the ticket that is generated by the ticketingManagementApplication.
      This is typically generated on the &amp;quot;open&amp;quot; call, and then used in subsequent
      calls.  It is also stored on the IdentityRequest object under the
      externalTicketId variable.</Description>
  </Variable>
  <Variable input="true" name="managerElectronicSignature">
    <Description>The name of the electronic signature object that should be used when workitems
       are completed by a manager.</Description>
  </Variable>
  <Variable input="true" name="ownerElectronicSignature">
    <Description>The name of the electronic signature object that should be used when workitems
       are completed by object owners.</Description>
  </Variable>
  <Variable input="true" name="securityOfficerElectronicSignature">
    <Description>The name of the electronic signature object that should be used when workitems
       are completed by the security officer.</Description>
  </Variable>
  <Variable input="true" name="approvingIdentities">
    <Description>List of identities and/or workgroups names/ids that should be involved in the approval
      process.</Description>
  </Variable>
  <Variable input="true" name="identityElectronicSignature">
    <Description>The name of the electronic signature object that should be used when workitems
      are completed by identities and/or workgroups.</Description>
  </Variable>
  <Variable input="true" name="identityEmailTemplate">
    <Description>Name of the email template to use when notifying the identities/workgroups of pending approvals.</Description>
  </Variable>
  <Variable initializer="true" input="true" name="filterRejects">
    <Description>True to filter rejected items when running in Serial/SerialPoll mode.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="setPreviousApprovalDecisions">
    <Description>True to pre-populate approval decisions from previous approvals.</Description>
  </Variable>
  <Variable name="approvalSplitPoint">
    <Description>Variable to determine when to split into parallel processing.
          This should map to a configured approvalScheme. We will process all schemes up until
          the approvalSplitPoint in the Pre Split approvals, and the remaining schemes after
          we split the items. If this is not specified, we will not split the Provisioning
          project, and process the entire project as a whole.</Description>
  </Variable>
  <Variable name="splitPlans">
    <Description>List of ProvisioningPlan that is generated from the splitPlans step if approvalSplitPoint is set.</Description>
  </Variable>
  <Variable name="splitProjects">
    <Description>Variable to store the returns if approvalSplitPoint is set. This will contain a List&amp;lt;ProvisioningProject&amp;gt;</Description>
  </Variable>
  <Variable name="splitApprovalSet">
    <Description>Variable to store the list of approvalSets returned from the split subprocess if approvalSplitPoint is set.</Description>
  </Variable>
  <Variable name="splitWorkItemComments">
    <Description>Variable to store the list of WorkItem comments returned from the split subprocess if approvalSplitPoint is set.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="saveUnmanagedPlan_WithProjectArgument">
    <Description>When true we will pass the project in to save unmanaged plan as an argument.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="requireCommentsForApproval">
    <Description>When true we will require comments when an approval item is approved.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="requireCommentsForDenial">
    <Description>When true we will require comments when an approval item is denied.</Description>
  </Variable>
  <RuleLibraries>
    <Reference class="sailpoint.object.Rule" name="LCM Workflow Library"/>
  </RuleLibraries>
  <Step icon="Start" name="Start" posX="25" posY="10">
    <Transition to="Initialize"/>
  </Step>
  <Step icon="Task" name="Initialize" posX="134" posY="10">
    <Arg name="formTemplate" value="Identity Update"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="enableRetryRequest" value="ref:enableRetryRequest"/>
    <Arg name="allowRequestsWithViolations" value="ref:allowRequestsWithViolations"/>
    <Arg name="endOnManualWorkItems" value="ref:endOnManualWorkItems"/>
    <Arg name="policiesToCheck" value="ref:policiesToCheck"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="policyScheme" value="ref:policyScheme"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="requireViolationReviewComments" value="ref:requireViolationReviewComments"/>
    <Arg name="identityRequest"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="batchRequestItemId" value="ref:batchRequestItemId"/>
    <Arg name="enableApprovalRecommendations"/>
    <Arg name="asyncCacheRefresh"/>
    <Arg name="endOnProvisioningForms" value="ref:endOnProvisioningForms"/>
    <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="launcher" value="ref:launcher"/>
    <Description>
      Call the standard subprocess to initialize the request, this includes
      auditing, building the approvalset, compiling the plan into
       project and checking policy violations.
    </Description>
    <Return name="project" to="project"/>
    <Return name="approvalSet" to="approvalSet"/>
    <Return name="policyViolations" to="policyViolations"/>
    <Return name="identityRequestId" to="identityRequestId"/>
    <Return name="violationReviewDecision" to="violationReviewDecision"/>
    <Return merge="true" name="workItemComments" to="workItemComments"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Identity Request Initialize"/>
    </WorkflowRef>
    <Transition to="Exit On Manual Work Items" when="script:(isTrue(endOnManualWorkItems) &amp;&amp; (project.getUnmanagedPlan() != null))"/>
    <Transition to="Exit On Provisioning Form" when="script:(isTrue(endOnProvisioningForms) &amp;&amp; (project.hasQuestions()))"/>
    <Transition to="Exit On Policy Violation">
      <Script>
        <Source>("cancel".equals(violationReviewDecision) || ((size(policyViolations) &gt; 0 ) &amp;&amp; (policyScheme.equals("fail"))))</Source>
      </Script>
    </Transition>
    <Transition to="Create Ticket"/>
  </Step>
  <Step condition="script:(ticketManagementApplication != null)" icon="Task" name="Create Ticket" posX="381" posY="6">
    <Arg name="trace" value="ref:trace"/>
    <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="action" value="open"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="ticketProject"/>
    <Arg name="ticketId" value="ref:ticketId"/>
    <Arg name="ticketDataGenerationRule"/>
    <Arg name="ticketPlan"/>
    <Description>
      Call a subprocess to create a ticket in the ticketManagementApplication is non-null.
      You can specify a specific 'ticketDataGenerationRule' here or you can also specify
      it on the application.  It'll be read from the argument first and fall back to the '
      application config.
    </Description>
    <Return name="ticketId" to="externalTicketId"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Manage Ticket"/>
    </WorkflowRef>
    <Transition to="Pre Split Approve" when="script:(!isNull(approvalSplitPoint) &amp;&amp; csvToList(approvalScheme).contains(approvalSplitPoint))"/>
    <Transition to="Approve and Provision"/>
  </Step>
  <Step condition="script:((flow == null) ||  (!&quot;UnlockAccount&quot;.equals(flow)))" icon="Task" name="Pre Split Approve" posX="518" posY="63">
    <Arg name="approvalScheme">
      <Script>
        <Source>
              import java.util.List;
              import java.util.ArrayList;
              import java.util.Iterator;
              import sailpoint.tools.Util;

              List schemes = Util.csvToList(approvalScheme);
              List preSchemes = new ArrayList&lt;String&gt;();
              for (String s : Util.safeIterable(schemes)) {
                if (s.equals(approvalSplitPoint)) {
                    break;
                } else {
                    preSchemes.add(s);
                }
              }
              return Util.listToCsv(preSchemes);
          </Source>
      </Script>
    </Arg>
    <Arg name="identityEmailTemplate" value="ref:identityEmailTemplate"/>
    <Arg name="securityOfficerElectronicSignature" value="ref:securityOfficerElectronicSignature"/>
    <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
    <Arg name="workItemHoursBetweenReminders"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="workItemComments"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
    <Arg name="managerElectronicSignature" value="ref:managerElectronicSignature"/>
    <Arg name="workItemDescription"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="ownerElectronicSignature" value="ref:ownerElectronicSignature"/>
    <Arg name="approvalMode" value="ref:approvalMode"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="dontUpdatePlan"/>
    <Arg name="workItemEscalationRule"/>
    <Arg name="approvalAssignmentRule"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="requireCommentsForApproval" value="ref:requireCommentsForApproval"/>
    <Arg name="identityElectronicSignature" value="ref:identityElectronicSignature"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="policyViolations" value="ref:policyViolations"/>
    <Arg name="ownerEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Arg name="filterRejects" value="ref:filterRejects"/>
    <Arg name="workItemReminderTemplate"/>
    <Arg name="workItemEscalationTemplate"/>
    <Arg name="setPreviousApprovalDecisions" value="ref:setPreviousApprovalDecisions"/>
    <Arg name="clearApprovalDecisions"/>
    <Arg name="noTriggers"/>
    <Arg name="workItemMaxReminders"/>
    <Arg name="requireCommentsForDenial" value="ref:requireCommentsForDenial"/>
    <Arg name="approvingIdentities" value="ref:approvingIdentities"/>
    <Arg name="securityOfficerEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
    <Arg name="workItemHoursTillEscalation"/>
    <Arg name="managerEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Arg name="launcher" value="ref:launcher"/>
    <Description>
      Call to our standard subprocess to handle the default approvals for
      manager, owner and security officer.
    </Description>
    <Return name="approvalSet"/>
    <Return name="workItemComments"/>
    <Return name="project"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Provisioning Approval Subprocess"/>
    </WorkflowRef>
    <Transition to="Split Plan"/>
  </Step>
  <Step action="call:splitProvisioningPlan" icon="Task" name="Split Plan" posX="618" posY="63" resultVariable="splitPlans">
    <Arg name="project" value="ref:project"/>
    <Description>
          Step to split the provisioning project into individual projects for each item requested.
          This will only run if the approvalSplitPoint is configured.
      </Description>
    <Transition to="Approve and Provision Split"/>
  </Step>
  <Step icon="Task" name="Approve and Provision Split" posX="783" posY="63">
    <Arg name="formTemplate" value="Identity Update"/>
    <Arg name="identityEmailTemplate" value="ref:identityEmailTemplate"/>
    <Arg name="enableRetryRequest" value="ref:enableRetryRequest"/>
    <Arg name="securityOfficerElectronicSignature" value="ref:securityOfficerElectronicSignature"/>
    <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
    <Arg name="endOnManualWorkItems" value="ref:endOnManualWorkItems"/>
    <Arg name="userEmailTemplate" value="ref:userEmailTemplate"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="workItemComments" value="ref:workItemComments"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
    <Arg name="ownerElectronicSignature" value="ref:ownerElectronicSignature"/>
    <Arg name="batchRequestItemId" value="ref:batchRequestItemId"/>
    <Arg name="saveUnmanagedPlan_WithProjectArgument" value="ref:saveUnmanagedPlan_WithProjectArgument"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="identityElectronicSignature" value="ref:identityElectronicSignature"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="filterRejects" value="ref:filterRejects"/>
    <Arg name="ownerEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Arg name="splitProvisioning" value="true"/>
    <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
    <Arg name="clearApprovalDecisions"/>
    <Arg name="noTriggers"/>
    <Arg name="requireCommentsForDenial" value="ref:requireCommentsForDenial"/>
    <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
    <Arg name="requesterEmailTemplate" value="ref:requesterEmailTemplate"/>
    <Arg name="approvalEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
    <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
    <Arg name="approvingIdentities" value="ref:approvingIdentities"/>
    <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
    <Arg name="managerEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Arg name="launcher" value="ref:launcher"/>
    <Arg name="approvalScheme">
      <Script>
        <Source>
              import java.util.List;
              import java.util.Iterator;
              import sailpoint.tools.Util;
              List schemes = Util.csvToList(approvalScheme);
              Iterator it = schemes.iterator();
              while (it.hasNext()) {
                String s = it.next();
                if (!s.equals(approvalSplitPoint)) {
                    it.remove();
                } else {
                    break;
                }
              }
              return Util.listToCsv(schemes);
            </Source>
      </Script>
    </Arg>
    <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="managerElectronicSignature" value="ref:managerElectronicSignature"/>
    <Arg name="approvalMode" value="ref:approvalMode"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
    <Arg name="endOnProvisioningForms" value="ref:endOnProvisioningForms"/>
    <Arg name="approvalAssignmentRule"/>
    <Arg name="requireCommentsForApproval" value="ref:requireCommentsForApproval"/>
    <Arg name="manualActionsEmailTemplate" value="Pending Manual Changes"/>
    <Arg name="policyViolations" value="ref:policyViolations"/>
    <Arg name="policyScheme" value="ref:policyScheme"/>
    <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
    <Arg name="setPreviousApprovalDecisions" value="ref:setPreviousApprovalDecisions"/>
    <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
    <Arg name="securityOfficerEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Description>
          Call the Approve and Provision Subprocess for each Provisioning Project generated in the Split Plan step.
      </Description>
    <Replicator arg="plan" items="splitPlans"/>
    <Return name="project" to="splitProjects"/>
    <Return name="workItemComments" to="splitWorkItemComments"/>
    <Return name="approvalSet" to="splitApprovalSet"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Approve and Provision Subprocess-MOCK"/>
    </WorkflowRef>
    <Transition to="Assimilate Splits"/>
  </Step>
  <Step action="call:joinLCMProvWorkflowSplits" icon="Task" name="Assimilate Splits" posX="914" posY="63">
    <Arg name="splitProjects" value="ref:splitProjects"/>
    <Arg name="splitApprovalSet" value="ref:splitApprovalSet"/>
    <Arg name="splitWorkItemComments" value="ref:splitWorkItemComments"/>
    <Description>
          Assimilate all projects returned from the split into the global project.
      </Description>
    <Transition to="Refresh Identity"/>
  </Step>
  <Step icon="Task" name="Approve and Provision" posX="699" posY="7">
    <Arg name="formTemplate" value="Identity Update"/>
    <Arg name="identityEmailTemplate" value="ref:identityEmailTemplate"/>
    <Arg name="enableRetryRequest" value="ref:enableRetryRequest"/>
    <Arg name="securityOfficerElectronicSignature" value="ref:securityOfficerElectronicSignature"/>
    <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
    <Arg name="endOnManualWorkItems" value="ref:endOnManualWorkItems"/>
    <Arg name="userEmailTemplate" value="ref:userEmailTemplate"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="workItemComments" value="ref:workItemComments"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
    <Arg name="ownerElectronicSignature" value="ref:ownerElectronicSignature"/>
    <Arg name="batchRequestItemId" value="ref:batchRequestItemId"/>
    <Arg name="saveUnmanagedPlan_WithProjectArgument" value="ref:saveUnmanagedPlan_WithProjectArgument"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="identityElectronicSignature" value="ref:identityElectronicSignature"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="filterRejects" value="ref:filterRejects"/>
    <Arg name="ownerEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Arg name="splitProvisioning" value="false"/>
    <Arg name="workItemEscalationTemplate" value="ref:workItemEscalationTemplate"/>
    <Arg name="clearApprovalDecisions"/>
    <Arg name="noTriggers" value="ref:noTriggers"/>
    <Arg name="requireCommentsForDenial" value="ref:requireCommentsForDenial"/>
    <Arg name="workItemMaxReminders" value="ref:workItemMaxReminders"/>
    <Arg name="requesterEmailTemplate" value="ref:requesterEmailTemplate"/>
    <Arg name="approvalEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
    <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
    <Arg name="approvingIdentities" value="ref:approvingIdentities"/>
    <Arg name="workItemHoursTillEscalation" value="ref:workItemHoursTillEscalation"/>
    <Arg name="managerEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Arg name="launcher" value="ref:launcher"/>
    <Arg name="approvalScheme" value="ref:approvalScheme"/>
    <Arg name="workItemHoursBetweenReminders" value="ref:workItemHoursBetweenReminders"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="managerElectronicSignature" value="ref:managerElectronicSignature"/>
    <Arg name="approvalMode" value="ref:approvalMode"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="workItemEscalationRule" value="ref:workItemEscalationRule"/>
    <Arg name="endOnProvisioningForms" value="ref:endOnProvisioningForms"/>
    <Arg name="approvalAssignmentRule"/>
    <Arg name="requireCommentsForApproval" value="ref:requireCommentsForApproval"/>
    <Arg name="manualActionsEmailTemplate" value="Pending Manual Changes"/>
    <Arg name="policyViolations" value="ref:policyViolations"/>
    <Arg name="policyScheme" value="ref:policyScheme"/>
    <Arg name="workItemReminderTemplate" value="ref:workItemReminderTemplate"/>
    <Arg name="setPreviousApprovalDecisions" value="ref:setPreviousApprovalDecisions"/>
    <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
    <Arg name="securityOfficerEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Description>
          Finish any remaining approvals and provision.
      </Description>
    <Return name="project" to="project"/>
    <Return name="approvalSet" to="approvalSet"/>
    <Return name="workItemComments" to="workItemComments"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Approve and Provision Subprocess-MOCK"/>
    </WorkflowRef>
    <Transition to="Refresh Identity"/>
  </Step>
  <Step action="call:refreshIdentity" condition="ref:doRefresh" icon="Task" name="Refresh Identity" posX="1028" posY="7">
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="correlateEntitlements" value="true"/>
    <Description>
      Add arguments as necessary to enable refresh features.  Typically you
      only want this to correlate roles.  Don't ask for provisioning  since that
      can result in provisioning policies that need to be presented and it's
      too late for that.  This is only to get role detection and exception
      entitlements in the cube.
    </Description>
    <Transition to="Notify"/>
  </Step>
  <Step icon="Task" name="Notify" posX="1131" posY="7">
    <Arg name="approvalScheme" value="ref:approvalScheme"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="notificationScheme" value="ref:notificationScheme"/>
    <Arg name="userEmailTemplate" value="ref:userEmailTemplate"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="policyViolations" value="ref:policyViolations"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="requesterEmailTemplate" value="ref:requesterEmailTemplate"/>
    <Arg name="securityOfficerName" value="ref:securityOfficerName"/>
    <Arg name="securityOfficerEmailTemplate" value="ref:securityOfficerEmailTemplate"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="managerEmailTemplate" value="ref:managerEmailTemplate"/>
    <Arg name="launcher" value="ref:launcher"/>
    <Description>
      Call the standard subprocess that will notify the various
      actors based on notification scheme.
    </Description>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Identity Request Notify"/>
    </WorkflowRef>
    <Transition to="end"/>
  </Step>
  <Step action="call:addMessage" name="Exit On Policy Violation" posX="201" posY="253">
    <Arg name="message" value="Failed due to policy violation(s)"/>
    <Arg name="type" value="Error"/>
    <Transition to="end"/>
  </Step>
  <Step action="call:addMessage" name="Exit On Manual Work Items" posX="364" posY="107">
    <Arg name="message" value="Failed due to manual work item(s)"/>
    <Arg name="type" value="Error"/>
    <Transition to="end"/>
  </Step>
  <Step action="call:addMessage" name="Exit On Provisioning Form" posX="280" posY="178">
    <Arg name="message" value="Failed due to provisioning form"/>
    <Arg name="type" value="Error"/>
    <Transition to="end"/>
  </Step>
  <Step catches="complete" icon="Catches" name="Finalize" posX="1058" posY="308">
    <Arg name="trace" value="ref:trace"/>
    <Arg name="batchRequestItemId" value="ref:batchRequestItemId"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="autoVerifyIdentityRequest"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="ticketDataGenerationRule"/>
    <Description>
      Call the standard subprocess that can audit/finalize the request.
    </Description>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Identity Request Finalize"/>
    </WorkflowRef>
    <Transition to="end"/>
  </Step>
  <Step icon="Stop" name="end" posX="1131" posY="253"/>
</Workflow>
<Workflow explicitTransitions="true" name="Approve and Provision Subprocess-MOCK" type="Subprocess">
  <Variable input="true" name="identityName">
    <Description>The name of the identity being updated.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="endOnManualWorkItems">
    <Description>Option to skip requests with manual work items.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="endOnProvisioningForms">
    <Description>Option to skip requests with provisioning forms.</Description>
  </Variable>
  <Variable initializer="script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)" input="true" name="identityDisplayName">
    <Description>The displayName of the identity being updated.
            Query for this using a projection query and fall back to the name.</Description>
  </Variable>
  <Variable input="true" name="plan">
    <Description>The provisioning plan ready to execute.</Description>
  </Variable>
  <Variable input="true" name="noTriggers">
    <Description>If true, then do no attempt to trigger lifecycle events.</Description>
  </Variable>
  <Variable input="true" name="flow">
    <Description>The name of the LCM flow that launched this workflow.

            This is one of these three values:

            AccountsRequest
            EntitlementsRequest
            RolesRequest
            AttributeSync</Description>
  </Variable>
  <Variable editable="true" initializer="false" name="optimisticProvisioning">
    <Description>Set to true to enable optimistic provisioning.  This will cause
            changes to the entitlements compiled from role assignments to be
            applied immediately to the identity cube rather than waiting
            for the next refresh/reaggregation after the provisioning system
            completes the request.</Description>
  </Variable>
  <Variable editable="true" initializer="true" name="foregroundProvisioning">
    <Description>Normally provisioning is done in a step that uses the &amp;quot;background&amp;quot;
            option to force the workflow to be suspend and be resumed in a
            background task thread.  This prevents the browser session from
            hanging since provision can sometimes take a long time.  For demos
            and testing it can be better to do this in the foreground so that
            provisioning will have been performed when control is returned to the
            user.  This prevents having to run the Perform Maintenance task to
            see the results of the request.</Description>
  </Variable>
  <Variable input="true" name="batchRequestItemId">
    <Description>Used by the batch interface to record back individual request item status. The specific item id for the individual request in the batch file.</Description>
  </Variable>
  <Variable initializer="LCM User Notification" input="true" name="userEmailTemplate">
    <Description>The email template to use for user notification.</Description>
  </Variable>
  <Variable initializer="LCM Requester Notification" input="true" name="requesterEmailTemplate">
    <Description>The email template to use for requester notification.</Description>
  </Variable>
  <Variable initializer="LCM Manager Notification" input="true" name="managerEmailTemplate">
    <Description>The email template to use for manager notification.</Description>
  </Variable>
  <Variable input="true" name="securityOfficerEmailTemplate">
    <Description>The email template to use for security officer notification.</Description>
  </Variable>
  <Variable initializer="parallel" input="true" name="approvalMode">
    <Description>A string that specifies how we should handle the approvals.

            By default this is serial since most of these request with
            the exception of manager transfers will have only one approver.

            parallel
            Approvals are processed concurrently and there must be consensus,
            we wait for all approvers to approve.  The first approver that
            rejects terminates the entire approval.

            parallelPoll
            Approvals are processed concurrently but consensus is not required.
            All approvals will be processed, we don&amp;#39;t stop if there are any
            rejections.

            serial
            Approvals are processed one at a time and there must be consensus.
            The first approver that rejects terminates the entire approval.

            serialPoll
            Approvals are processed in order but consensus is not required.
            All approvals will be processed, we don&amp;#39;t stop if there are any
            rejections.  In effect we are &amp;quot;taking a poll&amp;quot; of the approvers.

            any
            Approvals are processed concurrently, the first approver to
            respond makes the decision for the group.</Description>
  </Variable>
  <Variable initializer="owner" input="true" name="approvalScheme">
    <Description>A csv string that specifies how approval items should be generated
            for the incoming request.

            The value can be &amp;quot;none&amp;quot;, in which case approvals are disabled.

            The value can also be a combination of any of the values below
            in any order, separated by commas. The order in which they are
            specified is the order in which they are processed:

            owner
            The object owner gets the approval item.
            For Role approvals this is the Role object owner.
            For Entitlement approvals this is the Entitlement object owner.

            manager
            The manager gets the approval item.

            securityOfficer
            The identity in the variable securityOfficerName gets the approval item.

            identity
            The identities/workgroups in the variable approvingIdentities get the approval item.</Description>
  </Variable>
  <Variable initializer="LCM Identity Update Approval" input="true" name="approvalEmailTemplate">
    <Description>The email template to use for approval notifications.</Description>
  </Variable>
  <Variable initializer="Normal" input="true" name="workItemPriority">
    <Description>The String version of a WorkItem.Priority. This variable is
            used to set the priority on all of the workitems generated
            as part of this workflow and also set on the IdentityRequest
            object.</Description>
  </Variable>
  <Variable input="true" name="securityOfficerName">
    <Description>The name of the identity that will be sent approvals
            during security officer approvals.</Description>
  </Variable>
  <Variable initializer="spadmin" input="true" name="fallbackApprover">
    <Description>A String that specifies the name of the Identity that will
            be assigned any approvals where the owner of the approver
            can&amp;#39;t be resolved. Example if the scheme is &amp;quot;owner&amp;quot; and the
            application doesn&amp;#39;t specify and owner.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="enableRetryRequest">
    <Description>When set to true it will disable the workflow retry loop and let the
            Provision step launch requests to handle the retries.  Enabling
            this flag will enable some older functionality.</Description>
  </Variable>
  <Variable initializer="LCM" input="true" name="source">
    <Description>String version of sailpoint.object.Source to indicate
            where the request originated.  Defaults to LCM.</Description>
  </Variable>
  <Variable initializer="false" name="trace">
    <Description>Used for debugging this workflow and when set to true trace
            will be sent to stdout.</Description>
  </Variable>
  <Variable name="approvalSet">
    <Description>This attributes is set during the &amp;quot;Build Approval Set&amp;quot; step,
            which builds this list by going through the ProvisioningPlan
            to build the line items that need to be approved,

            This variable includes all ApprovalItems that are part of
            the request process and is updated during the AfterScript
            of the approval process by assimilating the decisions
            and comments from the Approvals copy of the ApprovalItem.</Description>
  </Variable>
  <Variable initializer="Approval_Assignment_Rule" input="true" name="approvalAssignmentRule"/>
  <Variable name="project">
    <Description>ProvisioningProject which is just a compiled version of the ProvisioningPlan.</Description>
  </Variable>
  <Variable name="policyViolations">
    <Description>List of policy violations that were found during our initial policy scan.
            This list is passed into each work item so the approvers can see
            pending violations.</Description>
  </Variable>
  <Variable name="identityRequestId" output="true">
    <Description>The sequence id of the Identity request object which is stored in
            the name field of the identity request and auto-incremented.</Description>
  </Variable>
  <Variable name="workItemComments">
    <Description>Global comments accumulated during the workflow which should be shared
            with other approvals. When a new approval is created, the comments in this
            list will be added to the work item.</Description>
  </Variable>
  <Variable input="true" name="ticketManagementApplication">
    <Description>Name of the application that can handle ticket requests.
            When non-null the Manage Ticket Steps will be visited to open
            tickets during the workflow lifecycle.</Description>
  </Variable>
  <Variable input="true" name="managerElectronicSignature">
    <Description>The name of the electronic signature object that should be used when workitems
            are completed by a manager.</Description>
  </Variable>
  <Variable input="true" name="ownerElectronicSignature">
    <Description>The name of the electronic signature object that should be used when workitems
            are completed by object owners.</Description>
  </Variable>
  <Variable input="true" name="securityOfficerElectronicSignature">
    <Description>The name of the electronic signature object that should be used when workitems
            are completed by the security officer.</Description>
  </Variable>
  <Variable initializer="true" input="true" name="filterRejects">
    <Description>True to filter rejected items when running in Serial/SerialPoll mode.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="setPreviousApprovalDecisions">
    <Description>True to pre-populate approval decisions from previous approvals.</Description>
  </Variable>
  <Variable input="true" name="approvalSplitPoint">
    <Description>Approval Scheme to split on.</Description>
  </Variable>
  <Variable input="true" name="clearApprovalDecisions">
    <Description>True to clear any decisions on approvals built with buildCommonApprovals</Description>
  </Variable>
  <Variable input="true" name="approvingIdentities">
    <Description>List of identities and/or workgroups names/ids that should be involved in the approval
            process.</Description>
  </Variable>
  <Variable input="true" name="formTemplate"/>
  <Variable input="true" name="manualActionsEmailTemplate"/>
  <Variable initializer="LCM Identity Update Approval" input="true" name="ownerEmailTemplate">
    <Description>Name of the email template to use when notifying the owner of pending approvals.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="splitProvisioning">
    <Description>True to tell IdentityRequest Provisioning subprocess that this is a subset of the initial provisioning plan</Description>
  </Variable>
  <Variable initializer="false" input="true" name="saveUnmanagedPlan_WithProjectArgument">
    <Description>When true we will pass the project in to save unmanaged plan as an argument.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="requireCommentsForApproval">
    <Description>When true we will require comments when an approval item is approved.</Description>
  </Variable>
  <Variable initializer="false" input="true" name="requireCommentsForDenial">
    <Description>When true we will require comments when an approval item is denied.</Description>
  </Variable>
  <Description>Subprocess to approve and provision immediately. This is used after splitting an ApprovalSet into individual items to run in parallel.</Description>
  <RuleLibraries>
    <Reference class="sailpoint.object.Rule" name="LCM Workflow Library"/>
  </RuleLibraries>
  <Step icon="Start" name="Start" posX="20" posY="20">
    <Transition to="Compile Project"/>
  </Step>
  <Step action="call:compileProvisioningProject" condition="script:(!approvalScheme.equalsIgnoreCase(&quot;none&quot;) &amp;&amp; !isNull(approvalSplitPoint))" icon="Task" name="Compile Project" posX="120" posY="20" resultVariable="project">
    <Arg name="requester" value="ref:launcher"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="noApplicationTemplates">
      <Script>
        <Source>
                    boolean ignoreForms = false;
                    if ("ForgotPassword".equals(flow) || "ExpirePassword".equals(flow)) {
                    ignoreForms = true;
                    }
                    return ignoreForms;
                </Source>
      </Script>
    </Arg>
    <Arg name="source" value="ref:source"/>
    <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="disableRetryRequest" value="!ref:enableRetryRequest"/>
    <Transition to="Build Approval Set"/>
  </Step>
  <Step action="call:buildSplitApprovalSet" condition="script:(!approvalScheme.equalsIgnoreCase(&quot;none&quot;) &amp;&amp; !isNull(approvalSplitPoint))" icon="Task" name="Build Approval Set" posX="220" posY="20" resultVariable="approvalSet">
    <Arg name="plan" value="ref:plan"/>
    <Return name="approvalSet" to="approvalSet"/>
    <Transition to="Approve"/>
  </Step>
  <Step condition="script:((flow == null) ||  (!&quot;UnlockAccount&quot;.equals(flow)))" configForm="Provisioning Approval Step Form" icon="Approval" name="Approve" posX="319" posY="21">
    <Arg name="approvalScheme"/>
    <Arg name="identityEmailTemplate"/>
    <Arg name="securityOfficerElectronicSignature" value="ref:securityOfficerElectronicSignature"/>
    <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
    <Arg name="workItemHoursBetweenReminders" value="72"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="workItemComments"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="approvalSplitPoint" value="ref:approvalSplitPoint"/>
    <Arg name="managerElectronicSignature" value="ref:managerElectronicSignature"/>
    <Arg name="workItemDescription"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="ownerElectronicSignature" value="ref:ownerElectronicSignature"/>
    <Arg name="approvalMode" value="ref:approvalMode"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="dontUpdatePlan"/>
    <Arg name="workItemEscalationRule" value="WorkItem Escalation Rule"/>
    <Arg name="approvalAssignmentRule" value="string:Approval_Assignment_Rule"/>
    <Arg name="plan" value="ref:plan"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="requireCommentsForApproval"/>
    <Arg name="identityElectronicSignature"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="policyViolations" value="ref:policyViolations"/>
    <Arg name="ownerEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Arg name="filterRejects" value="ref:filterRejects"/>
    <Arg name="workItemReminderTemplate" value="Work Item Reminder"/>
    <Arg name="workItemEscalationTemplate" value="Work Item Escalation"/>
    <Arg name="setPreviousApprovalDecisions" value="ref:setPreviousApprovalDecisions"/>
    <Arg name="clearApprovalDecisions" value="script:(!isNull(approvalSplitPoint) &amp;&amp; csvToList(approvalScheme).contains(approvalSplitPoint))"/>
    <Arg name="noTriggers"/>
    <Arg name="workItemMaxReminders" value="2"/>
    <Arg name="requireCommentsForDenial"/>
    <Arg name="approvingIdentities"/>
    <Arg name="securityOfficerEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Arg name="securityOfficerName"/>
    <Arg name="workItemHoursTillEscalation" value="72"/>
    <Arg name="managerEmailTemplate" value="ref:approvalEmailTemplate"/>
    <Arg name="launcher" value="ref:launcher"/>
    <Return name="approvalSet"/>
    <Return name="workItemComments"/>
    <Return name="project"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Provisioning Approval Subprocess"/>
    </WorkflowRef>
    <Transition to="Update Ticket Post Approval"/>
  </Step>
  <Step condition="script:(ticketManagementApplication != null)" icon="Task" name="Update Ticket Post Approval" posX="470" posY="20">
    <Arg name="trace" value="ref:trace"/>
    <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="action" value="postApproval"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="ticketProject"/>
    <Arg name="ticketId"/>
    <Arg name="ticketDataGenerationRule"/>
    <Arg name="ticketPlan"/>
    <Description>
            Call a subprocess to update the ticket in the ticketManagementApplication is non-null.

            You can specify a specific 'ticketDataGenerationRule' here or you can also specify
            it on the application.  It'll be read from the argument first and fall back to the '
            application config.

        </Description>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Manage Ticket"/>
    </WorkflowRef>
    <Transition to="Provision"/>
  </Step>
  <Step icon="Provision" name="Provision" posX="600" posY="20">
    <Arg name="formTemplate" value="Identity Update"/>
    <Arg name="approvalScheme" value="ref:approvalScheme"/>
    <Arg name="identityName" value="ref:identityName"/>
    <Arg name="fallbackApprover" value="ref:fallbackApprover"/>
    <Arg name="approvalSet" value="ref:approvalSet"/>
    <Arg name="manualActionsEmailTemplate" value="Pending Manual Changes"/>
    <Arg name="workItemComments" value="ref:workItemComments"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="policyViolations" value="ref:policyViolations"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="policyScheme" value="ref:policyScheme"/>
    <Arg name="splitProvisioning" value="ref:splitProvisioning"/>
    <Arg name="saveUnmanagedPlan"/>
    <Arg name="foregroundProvisioning" value="ref:foregroundProvisioning"/>
    <Arg name="noTriggers" value="ref:noTriggers"/>
    <Arg name="identityDisplayName" value="ref:identityDisplayName"/>
    <Arg name="trace" value="ref:trace"/>
    <Arg name="saveUnmanagedPlan_WithProjectArgument" value="ref:saveUnmanagedPlan_WithProjectArgument"/>
    <Arg name="recompile"/>
    <Arg name="optimisticProvisioning" value="ref:optimisticProvisioning"/>
    <Arg name="plan"/>
    <Arg name="flow" value="ref:flow"/>
    <Arg name="launcher" value="ref:launcher"/>
    <Description>
            Call the standard subprocess that will process the
            approval decisions and do provisioning.  This
            includes calling any configured provisioning
            connectors and building manual actions.
        </Description>
    <Return name="project" to="project"/>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Identity Request Provision"/>
    </WorkflowRef>
    <Transition to="Update Ticket Post Provision"/>
  </Step>
  <Step condition="script:(ticketManagementApplication != null)" icon="Task" name="Update Ticket Post Provision" posX="700" posY="20">
    <Arg name="trace" value="ref:trace"/>
    <Arg name="ticketManagementApplication" value="ref:ticketManagementApplication"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="action" value="postProvisioning"/>
    <Arg name="workItemPriority" value="ref:workItemPriority"/>
    <Arg name="identityRequestId" value="ref:identityRequestId"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="ticketProject"/>
    <Arg name="ticketId"/>
    <Arg name="ticketDataGenerationRule"/>
    <Arg name="ticketPlan"/>
    <Description>
            Call a subprocess to update the ticket in the ticketManagementApplication is non-null.

            You can specify a specific 'ticketDataGenerationRule' here or you can also specify
            it on the application.  It'll be read from the argument first and fall back to the '
            application config.

        </Description>
    <WorkflowRef>
      <Reference class="sailpoint.object.Workflow" name="Manage Ticket"/>
    </WorkflowRef>
  </Step>
</Workflow>
</sailpoint>
