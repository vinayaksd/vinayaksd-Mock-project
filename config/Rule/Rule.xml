<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sailpoint PUBLIC "sailpoint.dtd" "sailpoint.dtd">
<sailpoint>
<Rule language="beanshell" name="WorkItem Escalation Rule" type="Escalation">
  <Source>
   import sailpoint.object.Identity;
// method returns owner of item (workItem)
Identity owner = item.getNotificationOwner(context);
// if no owner, escalate to spadmin
if (owner == null)
{
 Identity id=context.getObjectByName(Identity.class, "spadmin");
 return id.getName();
 }
else {
 // escalate to ownerâ€™s manager; if manager is inactive, keep
 // escalating until find active manager
 Identity newOwner = owner.getManager();
 while (newOwner != null &amp;&amp; newOwner.isInactive()) {
 newOwner = newOwner.getManager();
 }
}
if (newOwner == null)
 {
    Identity id=context.getObjectByName(Identity.class, "spadmin");
 return id.getName();
 }

    
  </Source>
</Rule>
<Rule language="beanshell" name="No Correlator" type="Correlation"/>
<Rule language="beanshell" name="Clear CustomGlobal">
  <Source>
      
        import sailpoint.object.CustomGlobal;

        List results = new ArrayList();
        results.add("CustomGlobal BEFORE clear had ["+
                    CustomGlobal.size() + "] keys.");
        CustomGlobal.clear();
        results.add("CustomGlobal AFTER clear has [" +
                   CustomGlobal.size()+"] keys.");

        return results;
      
    </Source>
</Rule>
<Rule language="beanshell" name="IdentityNowSAML" type="SAMLCorrelation">
  <Signature>
    <Inputs>
      <Argument name="log">
        <Description>
                    Logger to take care of logging.
                </Description>
      </Argument>
      <Argument name="context">
        <Description>
                    SailPointContext
                </Description>
      </Argument>
      <Argument name="assertionAttributes">
        <Description>
                    Map of attributes taken from the SAML assertion
                </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="ident">
        <Description>
                    Matching identity based on the nameId taken from assertionAttributes
                </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
        
            // Imports
            import sailpoint.object.Identity;

            // Making a BIG assumption here that the nameid-format is unspecified/persitent

            // Get the nameId from the assertionAttributes
            String nameId = (String)assertionAttributes.get("nameId");

            Identity ident;

            if(nameId != null) {
                // Lookup the identity based on nameId
                ident = context.getObject(Identity.class, nameId);
            }

            return ident;

        
    </Source>
</Rule>
<Rule language="beanshell" name="Workflow Library">
  <Source>
    
      import sailpoint.object.Filter;
      import sailpoint.object.Identity;
      import sailpoint.object.ProvisioningPlan;
      import sailpoint.object.ProvisioningPlan.AccountRequest;
      import sailpoint.object.ProvisioningPlan.AttributeRequest;
      import sailpoint.object.QueryOptions;
      import sailpoint.tools.GeneralException;
      import sailpoint.tools.Util;
      import sailpoint.api.ObjectUtil;

      boolean otob(Object o) { return Util.otob(o); }
      boolean isTrue(Object o) {otob(o); } 
      boolean isFalse(Object o) {!otob(o); }
      boolean isNull(Object o) {o == null; } 
      int size(Collection o) { return Util.size(o); }
      String toString(Object o) {(o == null) ? "*null*" : o.toString(); }
      void println(Object o) {System.out.println(o); }
      void print(String str) { System.out.print(str); }
      void printval(String n, Object o) {println(n + " = " + toString(o)); }


      public List csvToList(String csv) {
        return Util.csvToList(csv);
      }

      /** 
       * resolve displayName by doing a projection query.
       */ 
      public String resolveDisplayName(String identityName) {
          String displayName = getIdentityProperty(identityName, "displayName"); 
          if ( displayName == null ) {
              displayName = identityName;
          }
          return displayName;
      }
      
      /** 
       * If the identityDisplayName is null resolve it by doing
       * a projection query.
       */ 
      public String resolveDisplayName(String identityName, String currentDisplayName) {
          // allow it to be passed in to avoid the query
          String displayName = null;
          if ( currentDisplayName != void ) {
              displayName = currentDisplayName;
          }
          if ( displayName == null ) {
              displayName = resolveDisplayName(identityName);
          }
          return displayName;
      }

      /**
       * Given an Identity's name or workgroup, return the email address.
       * First, we try to get the identities email address and if that doesn't exist
       * assume it is a workgroup and get the email addresses accordingly.
       */
      public String getEmail(String name) {
          // Try to get the email address from the identity
          String email = getIdentityProperty(name, "email");

          // If there is no identity email defined try to get workgroup email.
          if (null == email) {
              Identity identity = context.getObject(Identity.class, name);
              if (identity != null) {
                  email = Util.listToCsv(ObjectUtil.getEffectiveEmails(context, identity));
              }
          }

          return email;
      }

      /**
       * Given an Identity's name and a ProvisioningPlan, return the email address.
       * This can be used for user notifications when a request to create an
       * identity was rejected.  In this case there will not be an identity in
       * the database, so we will try to extract the email address from the plan.
       */
      public String getUserEmail(String name, ProvisioningPlan plan) {
          String email = getEmail(name);

          if (null == email) {
              email = getIIQCreateRequestValue(plan, "email");
          }

          return email;
      }

      /**
       * Given an Identity's name, return the manager's email address.
       */
      public String getManagersEmail(String name) {
          return getIdentityProperty(name, "manager.email"); 
      }

      /**
       * Given an Identity's name, return the manager's email address.
       * This can be used for user notifications when a request to create an
       * identity was rejected.  In this case there will not be an identity in
       * the database, so we will try to extract the manager from the plan to
       * lookup the email address.
       */
      public String getManagersEmail(String name, ProvisioningPlan plan) {
          String email = getManagersEmail(name);

          if (null == email) {
              String manager = getIIQCreateRequestValue(plan, "manager");
              if (null != manager) {
                  Identity identity = context.getObject(Identity.class, manager);
                  if (null != identity) {
                      email = identity.getEmail();
                  }
              }
          }

          return email;
      }

      /**
       * Return the value for the requested attribute from the ProvisioningPlan
       * if this is an identity creation request.
       */
      private String getIIQCreateRequestValue(ProvisioningPlan plan, String attr) {
          String value = null;

          if (null != plan) {
              AccountRequest acctReq = plan.getIIQAccountRequest();
              if ((null != acctReq) &amp;&amp;
                  AccountRequest.Operation.Create.equals(acctReq.getOperation())) {
                  AttributeRequest attrReq = acctReq.getAttributeRequest(attr);
                  if (null != attrReq) {
                      value = (String) attrReq.getValue();
                  }
              }
          }

          return value;
      }

      /** 
       * Return a single string property value from an identity.
       */
      public String getIdentityProperty(String identity, String property) {
          QueryOptions ops = new QueryOptions();
          Filter nameFilter = Filter.eq("name", identity);
          ops.add(new Filter[]{nameFilter});

          String val = null; 
          Iterator it = context.search(Identity.class, ops, property);
          while ( it.hasNext() ) {
              Object[] row = (Object[])it.next();
              val = (String)row[0];
              if ( it.hasNext() ) {
                  // shouldn't happen but guard
                  throw new GeneralException("More then one ["+property+"] value returned for ["+identity+"]");
              }
          } 
          return val;
      }

      /**
       * Return the value of a system configuration property.
       * The value is always returned as a string.
       */
      public String getConfiguration(String name) {
          return context.getConfiguration().getString(name);
      }

    
  </Source>
</Rule>
<Rule language="beanshell" name="Approval Library">
  <Source>
    

    import sailpoint.api.ManagedAttributer;
    import sailpoint.object.Application;
    import sailpoint.object.ApprovalSet;
    import sailpoint.object.ApprovalItem;
    import sailpoint.object.AttributeDefinition;
    import sailpoint.object.Attributes;
    import sailpoint.object.Bundle;
    import sailpoint.object.Identity;
    import sailpoint.object.ManagedAttribute;
    import sailpoint.object.ProvisioningPlan;
    import sailpoint.object.ProvisioningPlan.AccountRequest;
    import sailpoint.object.ProvisioningPlan.AttributeRequest;
    import sailpoint.object.ProvisioningPlan.PermissionRequest;
    import sailpoint.object.ProvisioningPlan.GenericRequest;
    import sailpoint.object.ProvisioningProject;
    import sailpoint.object.Scope;
    import sailpoint.object.WorkItem;
    import sailpoint.object.Workflow;
    import sailpoint.object.Workflow.Approval;
    import sailpoint.tools.Util;
    import sailpoint.tools.xml.XMLObjectFactory;
    
    /** 
    * Take a list of AttributeRequests and return a List of Attributes
    * to store on the approval item so that we can get at the attributes of
    * each attribute request in case we need information about that attribute request
    */
    public Attributes getAttributeRequestArguments(List attributeRequests) {
      Attributes attributes = new Attributes();
      for(AttributeRequest attr : attributeRequests) {
        String key = attr.getName()+":"+attr.getValue();
        Attributes arguments = attr.getArguments();
        attributes.put(key, arguments);
      }
      return attributes;
    }

    /**
     * Turn a list of AttributeRequests into simple
     * name = 'value' format. Represent this as a list
     * so we can display it neatly in the ui tier and
     * still not mess with dn strings.
     *
     * A general utility method used both by rules and workflow
     * scripts.  
     */
    public List flattenAttributeRequests(List attributeRequests) {
        List flat = new ArrayList();
        flattenAttributeRequests(attributeRequests, flat);
        return flat;
    }
    
    /**
    *  Bug 15833, ensure requester comments make it into manual actions
    */
    public String getRequesterComments(List requests) {
        String comment = "";
        if(requests != null) {
            for(GenericRequest request : requests) {
                String innerComment = request.getComments();
                if ( Util.getString(innerComment) != null ) {
                    comment += innerComment;
                }
            }
        }
        return comment;
    }
        
    public void flattenAttributeRequests(List attributeRequests, List flat) {
        if ( Util.size(attributeRequests) &gt; 0 ) {
            for (AttributeRequest attr : attributeRequests ) {
                if( !attr.getName().equals(ProvisioningPlan.ATT_IIQ_PASSWORD) &amp;&amp;
                    !attr.getBoolean(ProvisioningPlan.ARG_SECRET) &amp;&amp;
                    !attr.getName().equals(Identity.PRF_USE_BY_DATE)) {
                    if (attr.getDisplayValue() == null) {
                        String displayName = attr.getName();
                        List val = Util.asList(attr.getValue());
                        if ( val != null ) {
                            if ( attr.getName().equals("manager") ) { 
                                String managerName = null;
                                if ( Util.size(val) == 1 ) {
                                    // For manager convert the name into a displayName so it looks 
                                    // reasonable in the ui
                                    managerName = (String)val.get(0);
                                    if ( manager != null ) {
                                        String displayName = getIdentityProperty(managerName, "displayName");
                                        if ( displayName != null ) {
                                            val = Util.csvToList(displayName);
                                        }
                                    }
                                }
                            }
                            
                            String type = (String)attr.get(ProvisioningPlan.ARG_TYPE);
                            if (type!=null &amp;&amp; type.equals(ProvisioningPlan.ARG_TYPE_DATE)) {
                              Object obj = val.get(0);
                              
                              Date date = null;
                              
                              if(obj instanceof java.util.Date) {
                                date = obj;
                              } else {
                                date = new Date((Long)obj);
                              }
                              val = new ArrayList();                         
                              val.add(Util.dateToString(date, "M/d/y"));
                            } else if (AttributeDefinition.TYPE_SCOPE.equals(type)) {
                              val = getScopeNames(val);  
                            }
                            
                        }
                        if ( Util.size(val) &gt; 0 ) 
                            flat.add(displayName+ " = '"+Util.listToCsv(val)+"'");
                    } else {
                        flat.add(attr.getDisplayValue());
                    }
                }
            }
        }
    }
    
    /*
     * Given a list of scope ids it will return a list of 
     * scope names.
     *
     */
    public List getScopeNames(List val) {
        
        if (val == null) {
            return null;
        }

        List scopeNames = new ArrayList();
        for (int i=0; i&lt;val.size(); ++i) {
            scopeNames.add(fetchScopeName((String) val.get(i)));
        }
        
        return scopeNames;
    }

    /**
     * Fetches a scope name from scope id
     *
     */    
    private String fetchScopeName(String id) {
        
        Scope scope =  context.getObjectById(Scope.class, id);
        
        if (scope == null) {
            return null;
        }
        
        return scope.getDisplayableName();
    }

    /**
     * Convert a List&lt;PermissionRequests&gt; into a List&lt;String&gt;
     * with each string formatted as "target='right,right,right'"
     * This is similar to flattenAttributeRequests above but 
     * kept distinct in case we need to change the rendering of permissions.
     * Currently it's ambiguous whether this is an attribute or a permission
     */
    public void flattenPermissionRequests(List permRequests, List flat) {

        if (permRequests != null) {
            for (PermissionRequest perm : permRequests ) {

              // we dont' have display names for targets, do we?
              flat.add(perm.getTarget() + " = '" + perm.getRights() + "'");
            }
        }
    }

    /**
     * Convert a Map&lt;String,ApprovalSet&gt; into Approval objects. 
     * One Approval object for each of the keys in the map.
     *
     * Used only by rules that calculate approval structures such
     * as LCM Build Owner Approvals.
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    public List buildApprovalsFromMap(Map ownerToSet, String identityName, String launcher) {
        List approvals = new ArrayList();
        if ( ownerToSet == null ) 
            return null;

        Iterator keys = null;
        Set keySet = ownerToSet.keySet();
        if ( keySet != null )  
            keys = keySet.iterator();

        if ( keys != null ) {
            while ( keys.hasNext() ) {
                String key = (String)keys.next();
                if ( key == null ) continue;
                ApprovalSet set = ownerToSet.get(key);
                if ( set != null ) {
                    if ( log.isDebugEnabled() ) {
                        log.debug("Owner["+key+"] " + set.toXml());
                    }
                    // djs: check here to make sure this isn't an auto-approved 
                    // item because the approver is the launcher
                    if ( !sailpoint.workflow.IdentityLibrary.isElectronicSignatureEnabled(wfcontext) &amp;&amp; 
                         key.compareTo(launcher) == 0 &amp;&amp; 
                         set.isAllApproved() ) {
                        // self approved continue;
                        continue;
                    } else {
                        Approval newApproval = new Approval();
                        newApproval.setOwner("\"" + key + "\"");  // quote the owner in case the user name has a comma
                        newApproval.setApprovalSet(set);
                        newApproval.addArg(Workflow.ARG_WORK_ITEM_TARGET_CLASS, "sailpoint.object.Identity");
                        newApproval.addArg(Workflow.ARG_WORK_ITEM_TARGET_NAME, identityName);
                        approvals.add(newApproval);
                    } 
                }
            }
        }
        if ( log.isDebugEnabled() ) {
            if ( approvals != null )
                log.debug("Approvals: " + XMLObjectFactory.getInstance().toXml(approvals));
            else
                log.debug("Approvals EMPTY.");
        }
        return approvals;
    }

    /**
     * Build a Map&lt;String,ApprovalSet&gt; each key representing a unique owner.
     * Use a Map here to allow us to easily merge any items for the same owner.
     *
     * Used by rules to build approval structures, normally followed by
     * a call to buildApprovalsFromMap.
     * 
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    public Map buildOwnerMap(String scheme, ApprovalSet approvalSet, 
                             ProvisioningPlan plan, String fallbackApprover, 
                             String identity, boolean autoApprove) {

        // djs: use a LinkedHashMap here to perserve the order of the
        // approvers in the list.  This is important for manager transfer
        // approvals.
        Map ownerToSet = new LinkedHashMap();
        List items = approvalSet.getItems();
        for ( ApprovalItem item : items ) {
            List approvers = getApproverNames(scheme, item, plan, identity);
            if ( approvers != null &amp;&amp; approvers.size() == 0 &amp;&amp; fallbackApprover != null ) {
                if ( log.isDebugEnabled() ) {
                    log.debug("Approver could not be resolved using fallbackApprover '"+fallbackApprover+"'.");
                }
                approvers.add(fallbackApprover);
            }
            //
            // Build an approval set or add an ApprovalItem 
            // to an existing set
            //
            if ( Util.size(approvers) &gt; 0 ) {
                for ( String approver : approvers ) {
                    ApprovalSet set = (ApprovalSet)ownerToSet.get(approver);
                    if ( set == null ) {
                        set = new ApprovalSet();
                    }

                    // Make a copy of the item here so they are independent of the the
                    // cart's item.  
                    ApprovalItem itemCopy = XMLObjectFactory.getInstance().clone(item, context);
                    set.add(itemCopy);
                    ownerToSet.put(approver, set);
                    if ( autoApprove ) {
                        // djs: when we come across the launcher who is also the approver
                        // auto approve the item, this will allow us to audit/report on
                        // the request but not force an approval.  We won't create an 
                        // Approval object if all of the items are acccepted
                        if ( approver.equals(launcher) ) {
                            itemCopy.setState(WorkItem.State.Finished);
                            if ( log.isDebugEnabled() ) {
                                log.debug("Launcher was also approver and was removed.");
                            }
                            // If there is just one approver AND we are marking this 
                            // Auto-Approved also mark the master approvalSets item 
                            // finished
                            if ( approvers.size() == 1 ) {
                                item.setState(WorkItem.State.Finished);
                            }
                        }
                    }
                }
                //
                // Update the "cart" representation
                //
                // set the item's owner so we have an update
                // version in the "registry"
                // Should we store a csv Multiple approvers ?
                item.setOwner(approvers.get(0));
            }
        }
        if ( log.isDebugEnabled() ) {
            if ( ownerToSet != null )
                log.debug("OwnerSetMap: " + XMLObjectFactory.getInstance().toXml(ownerToSet));
            else
                log.debug("OwnerSetMap EMPTY.");
        }
        return ownerToSet;
    }

    /**
     * Return a list of names that represent the names of the Identities that should
     * approve the item.  We need the Plan during manager transfers when we need to figure
     * out what the new value is for the manager attribute.
     *
     * Only time the returned list is null is when we have "none"
     * approval scheme.
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    public List getApproverNames(String scheme, ApprovalItem item, ProvisioningPlan plan, String identity) {
        return getApproverNames(scheme, item, plan, identity, null);
    }

    /**
     * Return a list of names that represent the names of the Identities that should
     * approve the item.  We need the Plan during manager transfers when we need to figure
     * out what the new value is for the manager attribute.
     *
     * Only time the returned list is null is when we have "none"
     * approval scheme.
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    public List getApproverNames(String scheme, ApprovalItem item, ProvisioningPlan plan,
                                 String identity, String securityOfficerName) { 

        List owners = new ArrayList();
        String schemeToUse = scheme;
        if ( schemeToUse == null ) {
            schemeToUse = "manager";
            log.warn("Approval Scheme was not defined defaulting to manager.");
        }
        List schemes = Util.csvToList(schemeToUse);

        // None will short-circuit and cause no approvals.
        if ( schemes.contains("none") ) {
            return null;
        } 

        if ( ( schemes.contains("manager") ) || ( schemes.contains("newManager") ) ) {
            List managers = getManagers(schemes, plan, identity);
            if ( null != managers ) { 
                owners.addAll(managers);
            } 
        }

        if ( schemes.contains("owner") ) {
            String app = item.getApplication(); 
            String op = item.getOperation();
            if ( ProvisioningPlan.APP_IIQ.compareTo(app) == 0 ) { 
                if ( ( ProvisioningPlan.Operation.Add.toString().equals(op) ) || 
                     ( ProvisioningPlan.Operation.Remove.toString().equals(op) ) ) {
                    // this is a role requst, entitlement request or identity update
                    if ( ( ProvisioningPlan.ATT_IIQ_DETECTED_ROLES.equals(item.getName()) ) ||
                         ( ProvisioningPlan.ATT_IIQ_ASSIGNED_ROLES.equals(item.getName()) ) ) {
                        String owner = resolveRoleOwner(item);
                        if ( owner != null ) owners.add(owner);
                    } 
                }
           } else {
               String owner = resolveAppRequestOwner(item);
               if ( owner != null ) 
                  owners.add(owner);
           }
        }

        if ( schemes.contains("securityOfficer") ) {
            if (null == securityOfficerName) {
                log.warn("Security officer approval is configured but securityOfficerName is not defined.");
            }
            else {
                // Only use the security officer if it is a real identity.
                Identity officer = context.getObjectByName(Identity.class, securityOfficerName);
                if (null == officer) {
                    log.warn("Could not find securityOfficer: " + securityOfficerName);
                }
                else {
                    owners.add(securityOfficerName);
                }
            }
        }

        return owners;
    }

    /**
     * Helper for getApproverNames.
     * From the item figure out the owner that should be assigned
     * to this application request.
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    private String resolveAppRequestOwner(ApprovalItem item) {
        String approverName = null;

        String appName = item.getApplication();
        if ( appName == null ) return null;

        Application application = context.getObjectByName(Application.class, appName);
        if ( application == null ) 
            throw new Exception("Couldn't find application ["+appName+"]");

        Identity owner = application.getOwner();
        if ( owner != null ) {
            approverName = owner.getName();
        } else {
            // unable to find owner for application foo...
            log.debug("Unable to find owner for application ["+appName+"]");
        }

        // Check the attributeName and value and check to see if we are dealing with 
        // a ManagedAttribute 
        String attrName = item.getName();
        List vals = item.getValueList();
        if ( ( attrName != null ) &amp;&amp; ( Util.size(vals) &gt; 0 ) ) {
            // there should just be one value in each record... 
            // log something
            String val = (String)vals.get(0);
            String maOwner = getManagedAttributeOwner(application, attrName, val);
            if ( maOwner == null) {
                log.debug("Managed Attribute owner not found.. falling back to app owner.");
            } else {
                approverName = maOwner;
            }
        }
        return approverName;
    }

    /**
     * Helper for resolveAppRequestOwner.
     * Use the ManagedAttributer to find the managed attribute and get the
     * owner from the ManagedAttribute.
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    private String getManagedAttributeOwner(Application app, String name, String value ) {
        String owner = null;
        ManagedAttribute ma = ManagedAttributer.get(context, app.getId(), name, value);
        if ( ma != null ) {
            Identity maOwner = ma.getOwner();
            if ( maOwner != null ) 
                owner = maOwner.getName();
        }
        return owner;
    }

    /**
     * Helper for getApproverNames.
     * If its a role request look up the role by name and get the owner
     * from the Role object.  
     *
     * TODO: should I walk up the hierarchy here if ther isn't 
     * one on the Bundle?
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    private String resolveRoleOwner(ApprovalItem item) {
        String approverName = null;
        List values = item.getValueList();
        if ( Util.size(values) &gt; 0 ) {
            if ( Util.size(values) != 1 ) 
                throw new Exception("More then one value found in an approval item");

            String roleName = (String)values.get(0);
            if ( roleName != null ) {
                Bundle b = context.getObjectByName(Bundle.class, roleName);
                if ( b != null ) {
                    Identity id = b.getOwner();
                    if ( id != null ) {
                        approverName = id.getName();
                    }
                }
            }
        }
        return approverName;
    }

    /**
     * Helper for getApproverNames.
     * Get the value for manager or other by resolving the identity
     * and computing the manager, or validating the value
     * in the approvalScheme variable;
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    private List getManagers(List schemes, ProvisioningPlan plan, String identity) {
        //  
        //  During Identity Creates the Identity object does not exist
        //    In this case we have to look at the plan and see if one is assigned
        //    if not assigned default to the fallbackApprover
        // 
        //  During Updates there could be one or two managers in play
        //    1) Newly assigned manager (which is still in the plan)
        //    2) Currently assigned manager ( assigned to the identity )
        //    
        List approverNames = new ArrayList();

        String currentManager = null;
        // Use the identities manager to resolve the approval
        Identity identityObject = context.getObject(Identity.class, identity);
        if ( identityObject != null ) {
            Identity manager = identityObject.getManager();
            if ( manager != null ) {
                currentManager = manager.getName();
            } else {
                log.debug("Manager not found for ["+identityObject.getName()+"] while computing approval");
            }
        }

        String planManager = resolveManagerFromPlan(plan);
        if ( ( currentManager == null ) &amp;&amp; ( planManager != null ) ) {
            // likely Identity Create case
            approverNames.add(planManager);
        } else
            if ( ( currentManager != null ) &amp;&amp; ( planManager == null ) ) {
                // normal case
                approverNames.add(currentManager);
            } else
                if ( ( currentManager != null ) &amp;&amp; ( planManager != null ) ) {
                    // Manager Transfer
                    if ( schemes.contains("manager") ){
                        approverNames.add(currentManager);
                    }
                    if ( schemes.contains("newManager") ){
                        approverNames.add(planManager);
                    } 
                }
        return ( approverNames.size() &gt; 0 ) ? approverNames : null;
    }

    /**
     * Helper for getManagers.
     * Dig into the plan and find the manager attribute for the IIQ
     * app if present. This is used during manager transfers
     * where we need to know the new manager so they can be 
     * part of the approval process.
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    private String resolveManagerFromPlan(ProvisioningPlan plan )  {
        String managerName = null;
        if ( plan != null ) {
            AccountRequest iiq = plan.getAccountRequest(ProvisioningPlan.APP_IIQ);
            if ( iiq != null ) {
                AttributeRequest manager = iiq.getAttributeRequest("manager");
                if ( manager != null ) {
                    Object obj = manager.getValue();
                    if ( obj != null ) {
                        managerName = Util.getString(obj.toString());
                    }
                }
            }
        }
        return managerName;
    }

    
  </Source>
</Rule>
<Rule language="beanshell" name="Build Manual Action Approvals">
  <ReferencedRules>
    <Reference class="sailpoint.object.Rule" name="Approval Library"/>
  </ReferencedRules>
  <Source>
    
       import sailpoint.object.ApprovalSet;
       import sailpoint.object.ApprovalItem;
       import sailpoint.object.ProvisioningPlan;
       import sailpoint.object.ProvisioningPlan.AccountRequest;
       import sailpoint.service.ProvisioningTransactionService;
       import sailpoint.service.ProvisioningTransactionService.TransactionDetails;
       import sailpoint.workflow.IdentityLibrary;

       //
       // Attributes needed in the rule context: 
       //
       // project - Provisioning Project
       //
       // fallbackApprover - String representing who gets the approval
       //                    if we can't resolve one.  
       //
       // identityName - name of the identity being operated on
       //

       List approvals = null;
       ProvisioningPlan unmanaged = project.getUnmanagedPlan();
       if ( unmanaged != null ) {
           // 
           // Build an ApprovalSet from each of the things in the plan 
           // 
           Identity id = context.getObject(Identity.class, identityName);
           ApprovalSet set = new ApprovalSet();
           for ( AccountRequest acctReq : unmanaged.getAccountRequests() ) {
               ProvisioningTransactionService transService = new ProvisioningTransactionService(context);

               AccountRequest account = new AccountRequest(acctReq.toMap());
               if ( AccountRequest.Operation.Create.equals(account.getOperation()) ) {
                   ApprovalItem item = new ApprovalItem();
                   // need to deal with this 
                   item.setApplication(account.getApplication());
                   item.setInstance(account.getInstance());
                   item.setNativeIdentity(account.getNativeIdentity());
                   AccountRequest.Operation op = account.getOperation();
                   if (op == null) {
                       // shouldn't be here but assume modify
                       op = AccountRequest.Operation.Modify;
                   }
                   item.setOperation(op.toString());
                   
                   //MEH 15833, get those comments transferred to the new approval item!
                   String requesterComments = null;
                   String attrComments = getRequesterComments(account.getAttributeRequests());
                   String permComments = getRequesterComments(account.getPermissionRequests());
                   
                   //only one of these should be set... ideally
                   if(attrComments.length() &gt; 0) {
                      requesterComments = attrComments;
                   }
                   
                   if(permComments.length() &gt; 0) {
                      requesterComments = permComments;
                   }

                   if(requesterComments == null) {
                      if(account.getComments() != null) {
                         requesterComments = account.getComments();
                      }
                   }

                   item.setRequesterComments(requesterComments);

                   List reqs = new ArrayList();
                   
                   flattenAttributeRequests(account.getAttributeRequests(), reqs);
                   flattenPermissionRequests(account.getPermissionRequests(), reqs);

                   item.setValue(reqs);
                   set.add(item);
               } else {
                   // The default ApprovalSet builder creates an ApprovalItem for
                   // every attribute/permission request
                   IdentityLibrary.addApprovalItems(id, account, set);
               }

               TransactionDetails details = new TransactionDetails();
               details.setIdentityName(identityName);
               details.setProject(project);
               details.setRequest(account);
               details.setPartitionedPlan(unmanaged);
               details.setManual(true);

               if (project.getMasterPlan() != null) {
                   details.setSource(project.getMasterPlan().getSource());
               }

               transService.logTransaction(details);
           }
           // 
           // Build a map of owner to ApprovalSet from each of the items
           // in the unmanaged plan 
           // 
           // Default to the owner scheme, but we might need an option 
           // 
           Map ownerMap = buildOwnerMap("owner", set, unmanaged, fallbackApprover, identityName, false);
           if ( ownerMap != null ) {
               approvals = buildApprovalsFromMap(ownerMap, identityName, launcher);
           }
       }
       return approvals;
    
  </Source>
</Rule>
<Rule language="beanshell" name="LCM Workflow Library">
  <Source>
    
      import sailpoint.api.Provisioner;
      import sailpoint.api.SailPointFactory;
      import sailpoint.api.SailPointContext;
      import sailpoint.object.ApprovalSet;
      import sailpoint.object.ApprovalItem;
      import sailpoint.object.AuditEvent;
      import sailpoint.object.Comment;
      import sailpoint.object.Field;
      import sailpoint.object.Form;
      import sailpoint.object.Filter;
      import sailpoint.object.Identity;
      import sailpoint.object.ProvisioningPlan;
      import sailpoint.object.ProvisioningPlan.AccountRequest;
      import sailpoint.object.ProvisioningPlan.AttributeRequest;
      import sailpoint.object.ProvisioningProject;
      import sailpoint.object.QueryOptions;
      import sailpoint.object.SignOffHistory;
      import sailpoint.object.Source;
      import sailpoint.object.Workflow;
      import sailpoint.object.Workflow.Approval;
      import sailpoint.object.WorkItem;
      import sailpoint.object.WorkItem.OwnerHistory;
      import sailpoint.server.Auditor;
      import sailpoint.tools.Util;
      import sailpoint.workflow.IdentityLibrary;
      import sailpoint.workflow.WorkflowContext;

      /**
       * Build an event per forward so there is a record 
       * that the owner changed from the original 
       * owner.
       */
      public void auditWorkItemOwnerHistory(WorkItem item) {
          List ownerHistories = item.getOwnerHistory();
          if ( Util.size(ownerHistories) &gt; 0 ) {
              String action = "Forward";
              if ( Auditor.isEnabled(action) ) {
                  for ( OwnerHistory history : ownerHistories ) {
                      AuditEvent event = new AuditEvent();
                      event.setTrackingId(wfcontext.getWorkflow().getProcessLogId());
                      event.setAction(action);
                      event.setTarget(item.getTargetName());
                      event.setAttribute("workitem", item.getName());
                      String oldOwner = history.getOldOwner();
                      if ( oldOwner != null ) 
                          event.setAttribute("oldOwner", oldOwner);
                      String source = history.getEffectiveSource();
                      event.setSource(source);
                      String comment = history.getComment();
                      if ( comment != null ) 
                          event.setAttribute("comment", comment);
                      String newOwner = history.getNewOwner();
                      if ( newOwner != null ) 
                          event.setAttribute("newOwner", newOwner);

                      // djs: for now set this in both places to avoid needing
                      // to upgrade.  Once we have ui support for "interface"
                      // we can remove the map version
                      event.setAttribute("interface", Source.LCM.toString());
                      event.setInterface(Source.LCM.toString());

                      Auditor.log(event);
                  }
              }
          }
      }

      /**
       * Build a single "comment" event for all of the comments
       * that were entered during a workitems lifecycle.
       */
      public void auditWorkItemComments(WorkItem item) {
          List comments = item.getComments();
          if ( Util.size(comments) &gt; 0 ) {
              String action = "Comment";
              if ( Auditor.isEnabled(action) ) {
                  AuditEvent event = new AuditEvent();
                  event.setTrackingId(wfcontext.getWorkflow().getProcessLogId());
                  event.setAction(action);
                  event.setTarget(item.getTargetName());
                  event.setAttribute("workitem", item.getName());

                  List commentStrings = new ArrayList();
                  for ( Comment comment : comments ) {
                      commentStrings.add(comment.toString());
                  }
                  event.setAttribute("comments", commentStrings);
                  // djs: for now set this in both places to avoid needing
                  // to upgrade.  Once we have ui support for "interface"
                  // we can remove the map version
                  event.setAttribute("interface", Source.LCM.toString());
                  event.setInterface(Source.LCM.toString());
                  Auditor.log(event);
              }
          }
      }

      /**
       * Determine the name to use as the "source" of an LCM work item
       * completion audit.  This should be the name of the identity that
       * closed the item.  This will be different than the item owner if the
       * owner is a work group.
       */
     public String getAuditSource(WorkItem item) {

         String actor = context.getUserName();
         Identity ident = context.getObjectByName(Identity.class, actor);
         if (ident != null)
             actor = ident.getDisplayName();
         else {
             // must be in the background with a pseudo system name
             // fall back to item owner
             ident = item.getOwner();
             if (ident != null)
                 actor = ident.getDisplayName();
             else 
                 actor = launcher;
         }

         return actor;
     }

      public void auditDecisions(WorkItem item) {
          if ( item == null )  return; 

          // there is only one Signoff, duplicated for each approval item
          SignOffHistory signoff = null;
          List signoffs = item.getSignOffs();
          if (signoffs != null &amp;&amp; signoffs.size() &gt; 0)
              signoff = (SignOffHistory)signoffs.get(0);

          ApprovalSet approvalSet = (ApprovalSet)item.get("approvalSet");
          if ( ( approvalSet != null ) &amp;&amp; ( !approvalSet.isEmpty() ) ) {
              for ( ApprovalItem it : approvalSet.getItems() ) {

                  /** Assimilate the form field changes back into the attribute requests before
                  * creating the audit event so that the correct data is stored in the audit event. **/
                  List attrs = it.getIIQAttributes();
                  Form form = (Form)item.get("workItemForm");
                  if(attrs!=null &amp;&amp; form!=null) {
                    for(AttributeRequest attr : attrs) {
                      
                      Field field = form.getField(it.getApplication()+":"+attr.getName());
                      if(field!=null) {
                        attr.setValue(field.getValue());
                      }
                    }
                    it.setValue(flattenAttributeRequests(attrs));                 
                  }
                                    
                  AuditEvent event = new AuditEvent();
                  event.setAction(AuditEvent.ActionApproveLineItem);
                  event.setSource(getAuditSource(item));
                  event.setTarget(identityName);

                  event.setApplication(it.getApplication());
                  event.setAccountName(it.getNativeIdentity());
                  event.setInstance(it.getInstance());
                  event.setAttributeName(it.getName());
                  event.setAttributeValue(it.getCsv());                  
                  
                  // electronic signature
                  if (signoff != null) {
                     String meaning = signoff.getText();
                     if (meaning != null) {
                         event.setAttribute("esignatureSigner", 
                                            signoff.getSignerDisplayableName());
                         event.setAttribute("esignatureText", meaning);
                         // what else, date?
                     }
                 }

                  Date start = it.getStartDate();
                  if ( start != null ) 
                      event.setAttribute("startDate", start);
                  Date end = it.getEndDate();
                  if ( end != null ) 
                      event.setAttribute("endDate", end);

                  event.setAttribute("currentStep", wfcontext.getStep().getName());

                  // group them by a generatedId
                  event.setTrackingId(wfcontext.getWorkflow().getProcessLogId());
                  String interfaceName = wfcontext.getString("interface");
                  if ( interfaceName == null)
                      interfaceName = Source.LCM.toString();

                  // djs: for now set this in both places to avoid needing
                  // to upgrade.  Once we have ui support for "interface"
                  // we can remove the map version
                  event.setAttribute("interface", interfaceName);
                  event.setInterface(interfaceName);

                  event.setAttribute("operation", it.getOperation());
                  event.setAttribute("requester", launcher);

                  List comments = it.getComments();
                  if ( Util.size(comments) &gt; 0 ) {
                      event.setAttribute("completionComments", comments);
                  }

                  String requesterComments = it.getRequesterComments();
                  if ( Util.getString(requesterComments) != null )
                      event.setAttribute("requesterComments", requesterComments);

                  String taskResultId = wfcontext.getString(Workflow.VAR_TASK_RESULT);
                  if ( taskResultId != null ) {
                      event.setAttribute(Workflow.VAR_TASK_RESULT, taskResultId);
                  }

                  if ( !it.isApproved() ) {
                      event.setAction(AuditEvent.ActionRejectLineItem);
                  }

                  if ( Auditor.isEnabled(event.getAction()) ) {
                      Auditor.log(event);
                      wfcontext.getSailPointContext().commitTransaction();
                  }
              }
          }
      }

      public void auditManualAction(WorkItem item) {
          if ( Auditor.isEnabled(AuditEvent.ManualChange) ) {
              ApprovalSet set = (ApprovalSet)item.get("approvalSet");
              if ( set != null ) {
                  List items = set.getItems();
                  if ( Util.size(items) &gt; 0 ) {
                      int num = 0 ;
                      for ( ApprovalItem it : items  ) { 
                          num++;
                          AuditEvent event = IdentityLibrary.buildBaseEvent(wfcontext, it);
                          event.setSource(getAuditSource(item));
                          event.setAction(AuditEvent.ManualChange);
                          event.setAttribute("requester", wfcontext.getString("launcher"));
                          event.setAttribute("op", it.getOperation());
                          List comments = it.getComments();
                          if ( Util.size(comments) &gt; 0 ) {
                              event.setAttribute("completionComments", comments);
                          }
                          Auditor.log(event);
                      }
                      if ( num &gt; 0 ) 
                          wfcontext.getSailPointContext().commitTransaction();
                  }
              } else {
                  throw new GeneralException("ApprovalSet not found in the afterscript.");
              }
          } 
      }

      /**
       * After an approval has been made apply the changes from the workitem back into the
       * cart. (approvalSet)
       */
      public void assimilateWorkItemApprovalSet(WorkflowContext wfcontext, WorkItem item, ApprovalSet approvalSet) {
         if (item == null) {
              // must not be a leaf approval...
              return;
          }
          // Assimilate all of the approvalItem changes into our gloval
          // approval set
          // 
          // Also audit the comments and forwarding thats happend
          ApprovalSet set = (ApprovalSet)item.get("approvalSet");
          if ( set != null ) {
              // Global completion comments will apply to each of the items
              // If there are completion comments append them
              // to any other completion comments, but typically its 
              // one or the other
              String completionComments = item.getCompletionComments();
              String ownerName = null;
              Identity id = item.getOwner();
              if ( id != null ) {
                  ownerName = id.getName();
              }
              approvalSet.assimilate(set, ownerName, completionComments, true);
          } else {
              throw new GeneralException("ApprovalSet not found in the afterscript.");
          }
          auditWorkItemOwnerHistory(item);
          auditWorkItemComments(item);
          wfcontext.getSailPointContext().commitTransaction();
      }

      /**
       * Convert the approvalScheme to csv and check for the approvalType.
       */
      public boolean isApprovalEnabled(String approvalScheme, String approvalType) {
          if ( approvalScheme != null )  {
              List schemes = Util.csvToList(approvalScheme);
              if ( Util.size(schemes) &gt; 0 ) {
                  if ( schemes.contains(approvalType) ) {
                      return true;
                  }
              }
          }
          return false;
      }

      public String getManagerName(String identityName, String launcher, String fallbackApprover) {
          String managerName = getIdentityProperty(identityName, "manager.name");
          if ( managerName != null ) {
              if ( managerName.compareTo(launcher) == 0 ) {
                  managerName = null;
              } 
          } else {
             managerName = fallbackApprover;
          }
          return managerName;
      }

      /**
       * Take an ApprovalSet and allow filtering of rejected items and 
       * allow clearing decisions. If includeRejected is false, only non rejected 
       * items will be copied into the new approvalSet.   If forceDecision is
       * true all of the previous decisions will be cleared forcing the new
       * approver to make a decision on all items.
       */
      public ApprovalSet filterApprovalSet(ApprovalSet masterSet, String includeRejected, 
                                           boolean forceDecision) {
          ApprovalSet filtered = new ApprovalSet();
          if ( masterSet != null ) {
              List items = masterSet.getItems();
              if ( !Util.otob(includeRejected) ) {
                  items = new ArrayList();
                  for ( ApprovalItem item : masterSet.getItems() ) {
                      if ( !item.isRejected() ) {
                          items.add(item);
                      }
                  }
              }
 
              if ( Util.size(items) &gt; 0 )  {
                  for ( ApprovalItem item : items ) {
                      if ( forceDecision ) { 
                          item.setState(null);
                      }
                      filtered.add(item); 
                  } 
              } 
          }
          return filtered;
      }

      //Filter items from the currentSet that are rejected in the masterSet
      public void filterRejectsFromApprovalSet(ApprovalSet masterSet, ApprovalSet currentSet) {
        if (currentSet != null &amp;&amp; !Util.isEmpty(currentSet.getItems())) {
            Iterator it = currentSet.getItems().iterator();
            while(it.hasNext()) {
                ApprovalItem currentItem = (ApprovalItem)it.next();
                //Find the item in the global ApprovalSet
                ApprovalItem globalItem = masterSet.find(currentItem);
                if (globalItem != null &amp;&amp; globalItem.isRejected()) {
                    //remove from the current approval
                    it.remove();
                }
            }
        }

      }

      //Set decisions on the currentSet to those in the masterSet
      public void setPreviousDecisionsOnApprovalSet(ApprovalSet masterSet, ApprovalSet currentSet) {
        if (currentSet != null &amp;&amp; !Util.isEmpty(currentSet.getItems())) {
            Iterator it = currentSet.getItems().iterator();
            while(it.hasNext()) {
                ApprovalItem currentItem = (ApprovalItem)it.next();
                //Find the item in the global ApprovalSet
                ApprovalItem globalItem = masterSet.find(currentItem);
                if (globalItem != null) {
                    currentItem.setState(globalItem.getState());
                }
            }
        }
      }

    
  </Source>
</Rule>
<Rule language="beanshell" name="Check Password Policy" type="FieldValue">
  <Source>
    
       import sailpoint.api.PasswordPolice;
       import sailpoint.object.Application;
       import sailpoint.object.Identity;
       import java.util.List;
       import java.util.ArrayList;
       import sailpoint.api.PasswordPolicyException;
       import sailpoint.tools.Util;
       import sailpoint.tools.Message;
       import sailpoint.tools.GeneralException;

       List msgs = new ArrayList();

       String passVal = (String)value;

       try {
           String appname = field.getApplication();
           if (appname == null) {
              // temporary support old WorkItems
              String fname = field.getName();
              int colon = fname.indexOf(":");
              if (colon &gt; 0)
                 appname = fname.substring(0, colon);
              else
                 log.error("Unable to determine application name from field");
           }
           Application app = context.getObjectByName(Application.class, appname);
          
           PasswordPolice police = new PasswordPolice(context);
           police.checkPassword(app, identity, passVal);
       }
       catch (PasswordPolicyException pe) {
           List messages = pe.getAllMessages();
           for (Message msg : messages) {
               msgs.add(msg.getMessage());
           }
       }
       catch (GeneralException ge) {
           msgs.add(ge.getMessage());
       }

       return ( Util.size(msgs) &gt; 0 ) ? msgs: null;
    
  </Source>
</Rule>
<Rule language="beanshell" name="LCM Build Owner Approvals">
  <ReferencedRules>
    <Reference class="sailpoint.object.Rule" name="Approval Library"/>
  </ReferencedRules>
  <Source>
    
       import sailpoint.object.ApprovalSet;
       import sailpoint.object.ProvisioningPlan;
       import sailpoint.workflow.IdentityLibrary;

       //
       // Attributes needed in the rule context: 
       //
       // plan - ProvisioningPlan object 
       //
       // approvalSet - An ApprovalSet representing the "cart"
       // 
       // fallbackApprover - String representing who gets the approval
       //                    if we can't resolve one.  
       //
       // identityName - name of the identity being operated on
       //
       //
       List approvals = new ArrayList();
       if ( approvalSet != null ) {
           // 
           // Build a map of owner to ApprovalSet from each of the things in the plan 
           // 
           Map ownerMap = buildOwnerMap("owner", approvalSet, plan, fallbackApprover, identityName, !IdentityLibrary.isElectronicSignatureEnabled(wfcontext));
           if ( ownerMap != null) {
               approvals = buildApprovalsFromMap(ownerMap, identityName, launcher);
           } 
       }
       return ( Util.size(approvals) &gt; 0 ) ? approvals : null;
    
  </Source>
</Rule>
<Rule language="beanshell" name="LCM Build Identity Approvers">
  <ReferencedRules>
    <Reference class="sailpoint.object.Rule" name="Approval Library"/>
  </ReferencedRules>
  <Source>
    
       import sailpoint.object.ApprovalSet;
       import sailpoint.object.ProvisioningPlan;
       import sailpoint.object.WorkItem.State;
       import sailpoint.workflow.IdentityLibrary;
       import sailpoint.tools.Util;

       //
       // Attributes needed in the rule context: 
       //
       // plan - ProvisioningPlan object 
       //
       // approvalScheme - String indicating how approvals should be generated
       //   none - disabled
       //   manager - the current manager gets the approval
       //   newManager - the current manager if the manager changd
       //   securityOfficer - the configured security officer
       // 
       // approvalSet - An ApprovalSet representing the "cart"
       //
       // fallbackApprover - String representing who gets the approval
       //                    if we can't resolve one.  
       //
       // identityName - name of the identity being operated on
       //
       // launcher - name of the identity that launched the request
       //
       // securityOfficerName - The name of the securityOfficer to be used
       //                       for approvals.
       //

       // Not all callers pass in securityOfficerName.  If not defined, just set
       // it to null so we don't run into an error when we try to reference it.
       if (void == securityOfficerName) {
           securityOfficerName = null;
       }

       List approvers = new ArrayList();
       if ( approvalSet != null ) {
           List items = approvalSet.getItems();
           // By default there is one item for all of the edits
           ApprovalItem item = null;
           if ( Util.size(items) &gt; 0 ) 
               item = items.get(0); 

           if ( item != null ) {
               approvers = getApproverNames(approvalScheme, item, plan, identityName, securityOfficerName);
               if ( approvers != null &amp;&amp; approvers.size() == 0 &amp;&amp; fallbackApprover != null ) {
                   if ( log.isDebugEnabled() ) { 
                       log.debug("Approver could not be resolved using fallbackApprover '"+fallbackApprover+"'.");
                   }
                   approvers.add(fallbackApprover);
               } 
               // If the launcher is an approver remove them from the list
               if ( approvers != null &amp;&amp; approvers.contains(launcher) ) {
                   Map args = wfcontext.getArguments();
                   String esig = null;
                   if ( args != null ) 
                       esig = (String)args.get("approverElectronicSignature");
 
                   if ( !IdentityLibrary.isElectronicSignatureEnabled(wfcontext) &amp;&amp; Util.isNullOrEmpty(esig) ) {
                       approvers.remove(launcher);
                       // If this is the only approver automaticaly
                       // mark the item approved.
                       if ( Util.size(approvers) == 0 ) {
                           item.setState(WorkItem.State.Finished);
                           item.setOwner(launcher);
                       }
                   }
               }
           }
       }
       return approvers;
    
  </Source>
</Rule>
<Rule language="beanshell" name="LCM Validate Identity Name" type="Validation">
  <Source>
    
      import sailpoint.api.*;
      import sailpoint.object.*;
      import sailpoint.tools.*;
      import sailpoint.api.*;
      import sailpoint.web.messages.MessageKeys;

      List messages = new ArrayList();
      QueryOptions qo = new QueryOptions();
      String trimValue = (value != null) ? ((String)value).trim() : null;
      if (trimValue == null || "".equals(trimValue)) {
          Message msg = new Message();
          msg.setKey(MessageKeys.LCM_CREATE_IDENTITY_NO_NAME_ERROR);
          messages.add(msg);
      } else {
          Filter filter  = Filter.or(Filter.eq("id", trimValue), Filter.ignoreCase(Filter.eq("name", trimValue)));
          qo.add(new Filter[]{filter});
          qo.addFilter(ObjectUtil.buildWorkgroupInclusiveIdentityFilter());
          int count = SailPointFactory.getCurrentContext().countObjects(Identity.class,qo);
          if (count&gt;0) {
              Message msg = new Message();
              msg.setKey(MessageKeys.LCM_CREATE_IDENTITY_NAME_ERROR);
              messages.add(msg);
          }
      }
      return messages;
    
  </Source>
</Rule>
<Rule language="beanshell" name="LCM Validate Password" type="Validation">
  <Source>
    
      import java.util.*;
      import sailpoint.api.PasswordPolice;
      import sailpoint.api.PasswordPolicyException; 
      
      List errors = null;
      
      try {
          PasswordPolice pp = new PasswordPolice(context);
          pp.checkPassword(null, value, false);
      }
      catch (PasswordPolicyException ppe) {
          errors = new ArrayList();
          errors.addAll(ppe.getAllMessages());
      }
      
      return errors;
    
  </Source>
</Rule>
<Rule language="beanshell" name="LCM Build Identity ApprovalSet">
  <ReferencedRules>
    <Reference class="sailpoint.object.Rule" name="Approval Library"/>
  </ReferencedRules>
  <Source>
    
      import sailpoint.object.ProvisioningPlan;
      import sailpoint.object.ProvisioningPlan.AttributeRequest;
      import sailpoint.object.ProvisioningPlan.AccountRequest;
      import sailpoint.object.ApprovalSet;
      import sailpoint.object.ApprovalItem;
      import sailpoint.object.Attributes;
      import sailpoint.tools.Util;

      ApprovalSet set = new ApprovalSet();
      if ( plan != null ) {
          List accountRequests = plan.getAccountRequests();
          for ( AccountRequest request : accountRequests ) {
              ApprovalItem item = new ApprovalItem();
              item.setApplication(request.getApplication());
              item.setInstance(request.getInstance());
              item.setNativeIdentity(request.getNativeIdentity());
              item.setOperation(request.getOperation().toString());
              List attrRequestFlat = flattenAttributeRequests(request.getAttributeRequests());
              if ( attrRequestFlat != null ) {
                  item.setValue(attrRequestFlat);
              } 
              Attributes attributes = getAttributeRequestArguments(request.getAttributeRequests());
              item.setAttributes(attributes);
              
              // for these requests comments come in on the plan
              String comments = plan.getComments();
              if ( Util.getString(comments) != null ) {
                  item.setRequesterComments(comments);
              }
              set.add(item);
          }

          // while we are here lets annotate the plan with previousValues
          if ( flow.equals("IdentityEditRequest") ) {
              AccountRequest iiqRequest = plan.getAccountRequest("IIQ");    
              if ( iiqRequest != null ) {
                  List attributeRequests = iiqRequest.getAttributeRequests();
                  if ( Util.size(attributeRequests) &gt; 0 ) {
                      Identity id = context.getObject(Identity.class, identityName);
                      if ( id != null )  {
                          for ( AttributeRequest req : attributeRequests ) {
                              String name = req.getName();
                              if ( name != null ) {
                                  // We have to be carefull here, if we see manager display
                                  // the displayName
                                  Object prevValue = id.getAttribute(name);
                                  if ( prevValue != null ) {
                                      if (name.equals("manager") ) {
                                          String displayName = getIdentityProperty((String)prevValue, "displayName");
                                          if ( displayName != null ) {
                                              prevValue = displayName;
                                          }
                                      }
                                      else if (prevValue instanceof Identity) {
                                          prevValue = (String)prevValue.getDisplayableName();
                                      }
                                      else  if(prevValue instanceof List) {
                                          /* Thanks to type erasure there is no way for us to write something like
                                           * prevValue instanceof List&lt;Identity&gt; so break it into steps.  Check if
                                           * prevValue is a List.  If it has any elements get the first one. If that
                                           * is an instance of Identity then assume the rest of the elements are too
                                           * and then build a List of displayable names, because that is what we do
                                           * with Identitys. */
                                          List prevValueList = (List) prevValue;
                                          if(prevValueList.size() &gt; 0) {
                                              if(prevValueList.get(0) instanceof Identity) {
                                                  List identityIds = new ArrayList(prevValueList.size());
                                                  for (Object value : prevValueList) {
                                                      Identity identity = (Identity) value;
                                                      identityIds.add(identity.getDisplayableName());
                                                  }
                                                  prevValue = identityIds;
                                              }
                                          }
                                      }
                                      req.put(ProvisioningPlan.ARG_PREVIOUS_VALUE, prevValue);
                                  }
                              }
                          }
                      }
                  }
              }
          }
      }
      return set;
    
  </Source>
</Rule>
<Rule language="beanshell" name="Objects in Requestor's Authorized Scopes" type="RequestObjectSelector">
  <Description>
    This rule returns either a Filter object that will be used to search for objects in the requestor's authorized scopes,
    the boolean value 'true' to indicate that everything should be returned (i.e. no restrictions) 
    or the boolean value 'false' to indicate that no objects are available for this user
  </Description>
  <Signature returnType="sailpoint.object.QueryInfo">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="requestor" type="sailpoint.object.Identity">
        <Description>
          Identity that is making the Life Cycle Manager request.
        </Description>
      </Argument>
      <Argument name="requestee" type="sailpoint.object.Identity">
        <Description>
          Identity on whose behalf the Life Cycle Manager request is being made.  In the case of bulk requests,
          this argument will be set to null when determining the roles that are visible to the requestor.
          It will be provided once a selection has been made in order to determine whether or not the given requestee
          should have access to the selected role.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="filter">
        <Description>
          Either a Filter object that will be used to search for accessible Objects, the boolean value 'true' to indicate that everything should be
          returned (i.e. no restrictions) or the boolean value 'false' to indicate that no objects are available for this population 
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    
      import sailpoint.api.ScopeService;
      
      ScopeService scopeService = new ScopeService(context);
      return scopeService.getControlledScopesQueryInfo(requestor);
    
  </Source>
</Rule>
<Rule language="beanshell" name="Objects in Requestee's Assigned Scope" type="RequestObjectSelector">
  <Description>This rule returns a Filter that restricts objects to those in the requestee's assigned scope</Description>
  <Signature returnType="sailpoint.object.QueryInfo">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="requestor" type="sailpoint.object.Identity">
        <Description>
          Identity that is making the Life Cycle Manager request.
        </Description>
      </Argument>
      <Argument name="requestee" type="sailpoint.object.Identity">
        <Description>
          Identity on whose behalf the Life Cycle Manager request is being made.  In the case of bulk requests,
          this argument will be set to null when determining the objects that are visible to the requestor.
          It will be provided once a selection has been made in order to determine whether or not the given requestee
          should have access to the selected role.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="filter">
        <Description>
          Either a Filter object that will be used to search for accessible Objects, the boolean value 'true' to indicate that everything should be
          returned (i.e. no restrictions) or the boolean value 'false' to indicate that no objects are available for this population 
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    
      import sailpoint.api.ScopeService;
      import sailpoint.object.Identity;
      import sailpoint.object.Scope;
      import sailpoint.object.QueryOptions;
      import sailpoint.object.QueryInfo;

      ScopeService scopeService = new ScopeService(context);
      QueryInfo scopeQueryInfo;
      if (requestee == null) {
          scopeQueryInfo = new QueryInfo(new QueryOptions());
      } else {
          scopeQueryInfo = scopeService.getAssignedScopeQueryInfo(requestee);
      }
      
      return scopeQueryInfo;
    
  </Source>
</Rule>
<Rule language="beanshell" name="Objects in Requestor's Authorized Scopes or Requestee's Assigned Scope" type="RequestObjectSelector">
  <Description>This rule returns a Filter that restricts roles to those in the requestor's authorized scopes or the requestee's assigned scope</Description>
  <Signature returnType="sailpoint.object.QueryInfo">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="requestor" type="sailpoint.object.Identity">
        <Description>
          Identity that is making the Life Cycle Manager request.
        </Description>
      </Argument>
      <Argument name="requestee" type="sailpoint.object.Identity">
        <Description>
          Identity on whose behalf the Life Cycle Manager request is being made.  In the case of bulk requests,
          this argument will be set to null when determining the roles that are visible to the requestor.
          It will be provided once a selection has been made in order to determine whether or not the given requestee
          should have access to the selected role.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="filter">
        <Description>
          A Filter object that will be used to search for accessible objects.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    
        import sailpoint.api.ScopeService;
        import sailpoint.object.Filter;
        import sailpoint.object.Identity;
        import sailpoint.object.QueryInfo;
        import sailpoint.object.QueryOptions;        

        ScopeService scopeService = new ScopeService(context);
        QueryInfo requestorQueryInfo =  scopeService.getControlledScopesQueryInfo(requestor);
        QueryInfo requesteeQueryInfo;
        if (requestee == null) {
            requesteeQueryInfo = null;
        } else {
            requesteeQueryInfo =  scopeService.getAssignedScopeQueryInfo(requestee);
        }

        QueryInfo scopeQueryInfo;
        if (requesteeQueryInfo == null || requesteeQueryInfo.isReturnNone()) {
            // Either no requestee was available or the requestee doesn't have anything in scope.  
            // Only apply the requestor QueryInfo in either case.
            scopeQueryInfo = requestorQueryInfo;
        } else if (requestorQueryInfo != null &amp;&amp; !requestorQueryInfo.isReturnNone()) {
            if (requestorQueryInfo.isReturnAll() || requesteeQueryInfo.isReturnAll()) {
                // If either the requestor or requestee has access to everything create a QueryInfo that grants
                // access to everything
                scopeQueryInfo = new QueryInfo(new QueryOptions());
            } else {
                // Both requestee and requestor filters exist so 'or' them
                scopeQueryInfo = new QueryInfo(Filter.or(requestorQueryInfo.getFilter(), requesteeQueryInfo.getFilter()), false);
            }
        } else {
            // The requestor doesn't have access to anything so only return whatever the requestee has access to
            scopeQueryInfo = requesteeQueryInfo;
        }

        return scopeQueryInfo;
    
  </Source>
</Rule>
<Rule language="beanshell" name="Objects Owned by the Requestor" type="RequestObjectSelector">
  <Description>This rule returns a Filter that restricts objects to those that the requestor or one of their workgroups owns</Description>
  <Signature returnType="sailpoint.object.QueryInfo">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="requestor" type="sailpoint.object.Identity">
        <Description>
          Identity that is making the Life Cycle Manager request.
        </Description>
      </Argument>
      <Argument name="requestee" type="sailpoint.object.Identity">
        <Description>
          Identity on whose behalf the Life Cycle Manager request is being made.  In the case of bulk requests,
          this argument will be set to null when determining the objects that are visible to the requestor.
          It will be provided once a selection has been made in order to determine whether or not the given requestee
          should have access to the selected object.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="filter">
        <Description>
          A Filter object that will be used to search for accessible Objects.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    
      import sailpoint.object.Filter;
      import sailpoint.object.Identity;
      import sailpoint.object.QueryOptions;
      import sailpoint.object.QueryInfo; 
      return new QueryInfo(QueryOptions.getOwnerScopeFilterUsingSubqueries(requestor, "owner"), false);
    
  </Source>
</Rule>
<Rule language="beanshell" name="All Objects" type="RequestObjectSelector">
  <Description>Allows all objects to be selected (no filtering)</Description>
  <Signature returnType="sailpoint.object.Filter">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="requestor" type="sailpoint.object.Identity">
        <Description>
          Identity that is making the Life Cycle Manager request.
        </Description>
      </Argument>
      <Argument name="requestee" type="sailpoint.object.Identity">
        <Description>
          Identity on whose behalf the Life Cycle Manager request is being made.  In the case of bulk requests,
          this argument will be set to null when determining the roles that are visible to the requestor.
          It will be provided once a selection has been made in order to determine whether or not the given requestee
          should have access to the selected role.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="filter">
        <Description>
          A Filter object that will be used to search for accessible request objects.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import sailpoint.object.QueryInfo;

return new QueryInfo(null, false);</Source>
</Rule>
<Rule language="beanshell" name="Identity Report Form Customizer" type="ReportCustomizer">
  <Description>
    This rule populates a form with fields for the standard and extended identity attributes.
  </Description>
  <Signature returnType="Map">
    <Inputs>
      <Argument name="locale">
        <Description>
          The current user's locale
        </Description>
      </Argument>
      <Argument name="report">
        <Description>
          The base report
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
       
        import sailpoint.object.*;
        import sailpoint.reporting.ReportingLibrary;

        ObjectConfig identityConfig = ObjectConfig.getObjectConfig(Identity.class);
        List standardAttributes = new ArrayList();
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("firstname"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("lastname"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("displayName"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("email"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("manager"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("inactive"));

        ReportingLibrary.addAttributes(context, report, Identity.class, standardAttributes, null,
          "Identity Attributes", locale, "id");

        List extendedAttrs = new ArrayList();
        for(ObjectAttribute att : identityConfig.getSearchableAttributes()){
          if (!att.isStandard())
            extendedAttrs.add(att);
        }

        for(ObjectAttribute att : identityConfig.getMultiAttributeList()){
            extendedAttrs.add(att);
        }

        ReportingLibrary.addAttributes(context, report, Identity.class, extendedAttrs, null,
          "Identity Extended Attributes", locale, "id");


       
</Source>
</Rule>
<Rule language="beanshell" name="Identity Entitlement Identity Report Form Customizer" type="ReportCustomizer">
  <Description>
    This rule populates a form with fields for the standard and extended identity attributes accessed through an identity entitlement.
  </Description>
  <Signature returnType="Map">
    <Inputs>
      <Argument name="locale">
        <Description>
          The current user's locale
        </Description>
      </Argument>
      <Argument name="report">
        <Description>
          The base report
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
       
        import sailpoint.object.*;
        import sailpoint.reporting.ReportingLibrary;

        ObjectConfig identityConfig = ObjectConfig.getObjectConfig(Identity.class);
        List standardAttributes = new ArrayList();
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("firstname"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("lastname"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("displayName"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("email"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("manager"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("inactive"));

        ReportingLibrary.addAttributes(context, report, IdentityEntitlement.class, standardAttributes, "identity",
          "Identity Attributes", locale, "id");


        List extendedAttrs = new ArrayList();
        for(ObjectAttribute att : identityConfig.getSearchableAttributes()){
          if (!att.isStandard())
            extendedAttrs.add(att);
        }

        for(ObjectAttribute att : identityConfig.getMultiAttributeList()){
            extendedAttrs.add(att);
        }

        ReportingLibrary.addAttributes(context, report, IdentityEntitlement.class, extendedAttrs, "identity",
          "Identity Extended Attributes", locale, "id");


       
</Source>
</Rule>
<Rule language="beanshell" name="Account Report Form Customizer" type="ReportCustomizer">
  <Description>
    This rule populates a form with fields for all searchable account fields.
  </Description>
  <Signature returnType="Map">
    <Inputs>
      <Argument name="locale">
        <Description>
          The current user's locale
        </Description>
      </Argument>
      <Argument name="report">
        <Description>
          The base report
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
       
        import sailpoint.object.*;
        import sailpoint.reporting.ReportingLibrary;

        ObjectConfig linkConfig = ObjectConfig.getObjectConfig(Link.class);
        ReportingLibrary.addAttributes(context, report, Link.class, linkConfig.getSearchableAttributes(), null,
          "Account Properties", locale);
       
</Source>
</Rule>
<Rule language="beanshell" name="Certification Report Customizer" type="ReportCustomizer">
  <Source>
       
        import sailpoint.object.*;
        import sailpoint.tools.Util;
        import sailpoint.web.messages.MessageKeys;
        if (Util.otob(taskDefinition.getArgument("exclusions"))){
          report.setDisablePreview(true);
          report.setDisablePreviewMessage(MessageKeys.REPT_CERT_PREVIEW_DISABLED_EXCLUSIONS);
        } else {
          report.setDisablePreview(false);
          report.setDisablePreviewMessage(null);
        }

       
</Source>
</Rule>
<Rule language="beanshell" name="Privileged Access Report Customizer" type="ReportCustomizer">
  <Description>
    This rule populates a form with fields for the standard and extended identity attributes as well as
    a form for defining the 'privileged' identity attribute.
  </Description>
  <Signature returnType="Map">
    <Inputs>
      <Argument name="locale">
        <Description>
          The current user's locale
        </Description>
      </Argument>
      <Argument name="report">
        <Description>
          The base report
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
       
        import sailpoint.object.*;
        import sailpoint.reporting.ReportingLibrary;

        ObjectConfig linkConfig = ObjectConfig.getObjectConfig(Link.class);
        ReportingLibrary.addAttributes(context, report, Link.class, linkConfig.getSearchableAttributes(), null,
          "Privileged Account Attributes", locale, "id");


        ObjectConfig identityConfig = ObjectConfig.getObjectConfig(Identity.class);
        List standardAttributes = new ArrayList();
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("firstname"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("lastname"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("displayName"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("email"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("manager"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("inactive"));

        ReportingLibrary.addAttributes(context, report, Identity.class, standardAttributes, "identity",
          "Identity Properties", locale, "id");

        List extendedAttrs = new ArrayList();
        for(ObjectAttribute att : identityConfig.getSearchableAttributes()){
          if (!att.isStandard())
            extendedAttrs.add(att);
        }

        for(ObjectAttribute att : identityConfig.getMultiAttributeList()){
            extendedAttrs.add(att);
        }

        ReportingLibrary.addAttributes(context, report, Identity.class, extendedAttrs, "identity",
          "Identity Extended Properties", locale, "id");
       
</Source>
</Rule>
<Rule language="beanshell" name="Privileged Access Report Validation Rule" type="ReportValidator">
  <Description>
      This rule validates the Privileged Access Report Form
    </Description>
  <Signature returnType="java.util.List">
    <Inputs>
      <Argument name="context">
        <Description>
            A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
          </Description>
      </Argument>
      <Argument name="report">
        <Description>
            The report object
          </Description>
      </Argument>
      <Argument name="form">
        <Description>
            The submitted sailpoint Form object.
          </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="messages">
        <Description>
            A list of error messages.
          </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
      
       import java.util.*;
       import sailpoint.object.*;
       import sailpoint.tools.Message;
       List messages = new ArrayList();

       Form.Section section = form.getSection("Privileged Account Attributes");
       if (section != null) {
         boolean found = false;
         for(FormItem item : section.getItems()){
           Field field = (Field)item;
           if(field.getValue() != null &amp;&amp; !field.getValue().equals("") &amp;&amp; !field.getValue().equals("null")) {
             found = true;
           }
         }

         if (!found) {
           messages.add(Message.localize("rept_priv_access_err_no_attr"));
         }
       } else {
         messages.add(Message.localize("rept_priv_attr_setup_needed"));
       }

       return messages;
      
  </Source>
</Rule>
<Rule language="beanshell" name="WindowsActivityRuleLibrary">
  <Source>
    
      import java.util.HashMap;
      import java.util.ArrayList;
      import java.util.List;
      import sailpoint.object.ApplicationActivity;
      import sailpoint.object.ApplicationActivity.Action;
      import sailpoint.tools.xml.*;

      public static String ACCESSES = "Accesses";
      public static String PRIVS = "Privileges";

      /**
       * Build a name,value Map pairing of the data found
       * in the Message field of the windows event.
       * Most of the low-level data is usually stored 
       * there using a "name : value \n" format, so parse
       * out those values so we can use them when 
       * building our activity.
       */
      public HashMap buildMapFromMessage(String message) {
  
          HashMap attributeMap = new HashMap();
          if ( message == null ) return attributeMap;

          StringTokenizer st = new StringTokenizer(message, "\n");
          int tokenNum = 0;
          while ( st.hasMoreTokens() ) {
              tokenNum++;
              String token = st.nextToken();
//System.out.println("token :" + token);
              String[] values = token.split(":");
              if ( values == null ) continue;
              if ( values.length == 2 ) {
                  String name = values[0];
                  String value = values[1];
                  if ( ( name != null ) &amp;&amp; ( value != null ) ) {
//System.out.println("name: " + name.trim() + " value: " + value.trim());
                      attributeMap.put(name.trim(), value.trim());
                  }
              } else 
              if ( (values.length == 1) &amp;&amp; (tokenNum == 1) ) {
                  String name = values[0];
                  attributeMap.put("action", name.trim());
              }
          }
          // Parse out privs 
          addPrivileges(attributeMap, message); 

          return attributeMap;
      }

      /** 
       * Some events, mostly Object Access events contain
       * Accesses, Privleges that need to be parsed further.
       * This is called, when we build a Map if the Message.
       */
      public void addPrivileges(HashMap extraInfo, String message) {

          if ( message== null ) return;
          int i = message.indexOf(ACCESSES);
          if ( i == -1 ) {
//System.out.println(ACCESSES + " not found");
              return;
          }
          int j = message.indexOf(PRIVS);
          if ( j == -1 ) {
//System.out.println(PRIVS + " not found");
              return;
          }

          List accesses = new ArrayList();
          String lastBlock = message.substring(i+ACCESSES.length(), j-1);
          if ( lastBlock != null ) {
//System.out.println("***lastBlock: " + lastBlock);
              StringTokenizer st = new StringTokenizer(lastBlock, "\n");
              while ( st.hasMoreTokens() ) {
                  String access = st.nextToken();
                  if ( access != null ) {
                      String trimed = access.trim();
                      if ( trimed.length() &gt; 0 ) {
//System.out.println("access: '" + trimed + "'");
                          accesses.add(trimed);
                      }
                  }
              }
          }

          if ( accesses.size() &gt; 0 ) {
              extraInfo.put(ACCESSES, accesses);
          }
      }

      /**
       * Given the eventCode from the native windows event
       * map it to our Action.
       */
      public Action resolveAction(Integer eventCode, HashMap extraInfo) {
          Action action = null;

          if ( eventCode == null ) {
              return;
          }

          try {
              switch(eventCode) {
                  case 538:
                      // logout
                      action = Action.Logout;
                      break;
                  case 528:
                  case 540:
                      // login
                      action = Action.Login;
                      break;
                  case 564:
                      // object delted
                      action = Action.Delete;
                      break;
                  case 560:
                      // object open
                      // Very generic must dig in an check permissions
                      if (containsAccess("WriteAttributes", extraInfo))
                          action = Action.Update;
                      else
                      if ( containsAccess("DELETE", extraInfo) ) 
                          action = Action.Delete;
                      else 
                          action = Action.Read;
                      break;
                  default: 
                      // not sure we should even have a default case?
                      action = Action.Read;
                      break;
              }
          } catch(Exception e) {
              action = null;
          }
          return action;
      }

      /** 
       * Using the resolved action, use the data in the extraInfo
       * map to come up with a target. ( the thing that was acted upon)
       */
      public String resolveTarget(Action action, HashMap extraInfo) {

          String target = null;    
          if ( ( action == null ) || ( extraInfo == null )  ) {
              return target;
          }

          if ( ( action.equals(Action.Login) ) ||
               ( action.equals(Action.Logout) ) ) {
              target = (String)extraInfo.get("Domain");
          } else {
              target = (String)extraInfo.get("Object Name");
          }

          if ( target == null ) target = "unResolved";
          return target;
      }


      /** 
       * Dig into the extra info and see if the event has referece to 
       * the past in access. 
       */
      private boolean containsAccess(String access, HashMap extraInfo) {

          boolean contains = false;
          if ( extraInfo == null ) return contains;

          ArrayList accesses = (ArrayList)extraInfo.get(ACCESSES); 
          if ( accesses != null ) {
              for ( String access: accesses ) {
                  if ( access != null ) {
                      if ( access.compareTo(access) == 0 ) {
                          return true;
                      }
                  }
              }        
          }
          return contains;
      }
    
  </Source>
</Rule>
<Rule language="beanshell" name="System Configured Locale Rule" type="FieldValue">
  <Description>
    This rule returns the locales configured in the System Configuration.
  </Description>
  <Signature returnType="java.util.List">
    <Inputs>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="locales">
        <Description>
          A list containing the locales found in the System Configuration.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
      import java.util.*;
     Map sysConfig = context.getConfiguration().getAttributes();
     List locales = sysConfig.get("supportedLanguages");
     return locales;
</Source>
</Rule>
<Rule language="beanshell" name="Report Completion Notification" type="TaskEventRule">
  <Description>
    This rule sends a notification email when a report is completed.
  </Description>
  <Signature returnType="Map">
    <Inputs>
      <Argument name="taskResult">
        <Description>
          The TaskResult object
        </Description>
      </Argument>
      <Argument name="event">
        <Description>
          The TaskEvent object
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="taskResult">
        <Description>The resulting task result object, or null if no update is required.</Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
      
        import sailpoint.object.*;
        import java.util.*;

        String identity = (String)event.getAttribute(TaskEvent.ATTR_EMAIL_RECIP);

        if (identity != null){

          Identity identity = context.getObjectByName(Identity.class, identity);
          if (identity == null)
            return result;

          List emailAddresses = new ArrayList();
          emailAddresses.add(identity.getEmail());
          EmailOptions options = new EmailOptions(emailAddresses, null);
          options.setSendImmediate(true);

          Map emailVars = new HashMap();
          emailVars.put("reportName", taskResult.getName());
          options.setVariables(emailVars);

          String templateName = (String)context.getConfiguration().get(Configuration.REPORT_COMPLETION_EMAIL_TEMPLATE);
          EmailTemplate et = context.getObjectByName(EmailTemplate.class, templateName);

          context.sendEmailNotification(et, options);
        }

        return null;
      
</Source>
</Rule>
<Rule language="beanshell" name="Report Scorecard Value Renderer">
  <Description>
      This rule renders report columns which pull values from a Scorecard object.
    </Description>
  <Source>
      
       import java.util.*;
       import sailpoint.object.*;

       Integer score = null;
       if(value!=null) {
					score = value.getScore(column.getField());
			 }

       return score != null ? score.toString() : null;
      
  </Source>
</Rule>
<Rule language="beanshell" name="Task Completion Email Rule" type="TaskCompletion">
  <Description>
      Example rule to perform Post Action after Task Completion
    </Description>
  <Signature>
    <Inputs>
      <Argument name="context">
        <Description>
            A sailpoint.api.SailPointContext object 
          </Description>
      </Argument>
      <Argument name="log">
        <Description>
            The log object associated with the SailPointContext.
          </Description>
      </Argument>
      <Argument name="result">
        <Description>
            result of task.
          </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
      
          import java.util.*;
          import sailpoint.tools.Util;
          import sailpoint.tools.GeneralException;
          import sailpoint.object.Configuration;
          import sailpoint.object.EmailOptions;
          import sailpoint.object.EmailTemplate;
          import sailpoint.object.TaskResult;
          import sailpoint.object.Identity;
          import sailpoint.object.TaskDefinition;
          import sailpoint.api.MessageRepository;
          import sailpoint.api.Emailer;
          import sailpoint.api.BasicMessageRepository;
          import sailpoint.api.ObjectUtil;
          import sailpoint.api.SailPointContext;
          import sailpoint.api.Notifier;

          MessageRepository _errorHandler;

          /**
           * Method to send email and Teams notification
          */
          private void sendNotificationOnTaskCompletion(String emailTemplate, ArrayList recipients, TaskResult result, SailPointContext context) {
              String message = "";
              String status = "";
              TaskDefinition def;
              Configuration sysConfig;

              def = result.getDefinition();
              EmailTemplate notifyEmail =  context.getObjectByName(EmailTemplate.class, emailTemplate);
              if (null == notifyEmail) {
                  log.error ("From Task Completion Email Rule: ERROR: could not find email template [ " + emailTemplate + "]");
                  return;
              }
              notifyEmail = (EmailTemplate) notifyEmail.deepCopy(context);
              if (null == notifyEmail) {
                  log.error ("From Task Completion Email Rule: ERROR: failed to deepCopy template [ " + emailTemplate + "]");
                  return;
              }
              // For now, we'll just use a map with a few pre-selected properties.
              Map mArgs = new HashMap();
 
              mArgs.put("taskResult", result);
              mArgs.put("taskName", def.getName());
              mArgs.put("taskDesc", def.getDescription());
              if (result.isError()) {
                  status = "Error";
              }
              else  if (result.isWarning()) {
                  status = "Warning";
              }
              else if (result.isSuccess()) {
                  status = "Success";
              }
 
              mArgs.put("taskStartTime", result.getLaunched() );
              mArgs.put("taskEndTime", result.getCompleted() );
              mArgs.put("status", status);
              if (result.getMessages() != null) {
                  mArgs.put("message", result.getMessages());
              }
              mArgs.put ("resultId", result.getId());

              EmailOptions ops = new EmailOptions(recipients, mArgs);
              try {
                  // send notifications to Teams
                  Notifier notifier = new Notifier(context);
                  notifier.sendNotification(notifyEmail, ops);
              }
              catch(Exception e) {
                  log.warn("Exception while sending Teams notification. " + e);
              }
              new Emailer(context, _errorHandler).sendEmailNotification(notifyEmail , ops);
          }

          private boolean isEmailNotificationEnabled(TaskResult result, Configuration sysConfig) {
              boolean sendEmail = false;
              String notifyStr = null;

              TaskDefinition def = result.getDefinition();
              notifyStr = (String) def.getString(Configuration.TASK_COMPLETION_EMAIL_NOTIFY);

              if (notifyStr == null || notifyStr.equals("Disabled")) {
                  // if Disabled in TaskDef, defer to System Config
                  notifyStr = sysConfig.getString(Configuration.TASK_COMPLETION_EMAIL_NOTIFY);
              }

              if (notifyStr != null) {
                  if (notifyStr.equals("Always") ||
                      ((notifyStr.equals("Failure")) &amp;&amp; result.isError()) || 
                      ((notifyStr.equals("Warning")) &amp;&amp;
                       (result.isWarning() || result.isError()))) {
                      sendEmail = true;
                  }
              }
                      
              return sendEmail;
          }

          private Object getIdentityNames(TaskResult result, Configuration sysConfig) {
              
              TaskDefinition def = result.getDefinition();
              Object identityNames = def.getArgument(Configuration.TASK_COMPLETION_RECIPIENTS);
              if (identityNames == null) {
                  identityNames = sysConfig.get(Configuration.TASK_COMPLETION_RECIPIENTS);
              }
              return identityNames;
          }

          private String getEmailTemplate(TaskResult result, Configuration sysConfig) {
              TaskDefinition def = result.getDefinition();
              String emailTemplate = def.getString(Configuration.TASK_COMPLETION_EMAIL_TEMPLATE);
              if (emailTemplate == null) {
                  emailTemplate = sysConfig.getString(Configuration.TASK_COMPLETION_EMAIL_TEMPLATE);
                  if (emailTemplate == null)
                      emailTemplate = Configuration.DEFAULT_TASK_COMPLETION_EMAIL_TEMPLATE;
              }
              return emailTemplate;
          }

          private List getEmailAddress (String identityName, SailPointContext context) {
              Identity identity = context.getObjectByName(Identity.class, identityName);
              if (identity != null) 
              {
                  List addresses = ObjectUtil.getEffectiveEmails(context, identity);
                  if (!Util.isEmpty(addresses)) {
                      return(addresses);
                  }
                  else
                  {
                     if(log.isWarnEnabled()) {
                         log.warn("From Task Completion Email Rule: Missing Email Address for Email Recipient: " + identityName );
                     }
                  }
              }
              return (null);
          }

          private ArrayList getEmailRecipient (Object identityNames, SailPointContext context) {
              List recipients;
              String val = null;
              StringTokenizer st = null;
              if (identityNames != null) {
                  recipients = new ArrayList ();
                  // From Task definition, single identity
                  if (identityNames instanceof String  &amp;&amp; !identityNames.contains(",")) {
                      List addresses = getEmailAddress (identityNames.toString(), context);
                      if (addresses != null) {
                         recipients.addAll (addresses);
                      }
                  }
                  // From Task definition, multiple identities
                  else if (identityNames instanceof String  &amp;&amp; identityNames.contains(",") == true) {
                      List nameList = Util.csvToList(identityNames);
                      for (String identityName : nameList) {
                          List addresses = getEmailAddress (identityName, context);
                          if (addresses != null) {
                              recipients.addAll (addresses);
                          }
                      }  
                  } 
                  // From system configuration single or multiple identities it comes as list
                  else if (identityNames instanceof List) {
                      for (String identityName : identityNames) {
                          List addresses = getEmailAddress (identityName, context);
                          if (addresses != null) {
                              recipients.addAll(getEmailAddress (identityName, context));
                          }
                      }
                  }
              }
              return (recipients);
          }

          // Main
          Configuration sysConfig = context.getConfiguration();
          boolean sendEmailNotify = isEmailNotificationEnabled(result, sysConfig);
    
          if (sendEmailNotify) {
              // jsl - why consturct this here, just make it in
              // sendNotificationOnTaskCompletion where it is used?
              // why do this at all since no one consumes it?
              _errorHandler = new BasicMessageRepository();

              Object identityNames = getIdentityNames(result, sysConfig);
              String emailTemplate = getEmailTemplate(result, sysConfig);
              List recipients = getEmailRecipient(identityNames, context);

              if (recipients != null &amp;&amp; !Util.isEmpty(recipients)) {
                    // Send Email and Teams notification
                   sendNotificationOnTaskCompletion(emailTemplate, recipients, result, context);
              }
              else {
                  if(log.isWarnEnabled()) {
                      log.warn("From Task Completion Email Rule: Cannot send task completion email Notification. Reason : Missing Email Address for Email Recipients");
                  }
              }
          }
    
    </Source>
</Rule>
<Rule language="beanshell" name="CEFTransformRule" type="ActivityTransformer">
  <Description>ActivityTransformation Rules are used by the LogFileCollector to transform fields parsed from a text file into our ApplicationActivity model.</Description>
  <Signature returnType="String">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="action">
        <Description>
          The field named action, which is the raw parsed.
          action field.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="mappedAction">
        <Description>
          A normalized ApplicationActivity.Action object.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import sailpoint.object.ApplicationActivity.Action;
import sailpoint.object.ApplicationActivity.Result;
import java.text.SimpleDateFormat;
import java.io;
import sailpoint.object.Configuration;
import java.util.List;

activity.setAction(Action.Grant);
activity.setResult(Result.Success);

//Dump out all params from CEF log entry to console
//System.out.println("CEFTransformRule: In rule");        
//System.out.println("CEFTransformRule: Timestamp=" +cef_timestamp);
//System.out.println("CEFTransformRule: Host=" +cef_host);
//System.out.println("CEFTransformRule: CEFVersion=" + cef_cefversion);
//System.out.println("CEFTransformRule: Vendor=" + cef_vendor);
//System.out.println("CEFTransformRule: Product=" + cef_product);
//System.out.println("CEFTransformRule: Version=" + cef_version);
//System.out.println("CEFTransformRule: Signature=" + cef_signature);
//System.out.println("CEFTransformRule: Name=" + cef_name);
//System.out.println("CEFTransformRule: Severity=" + cef_severity);
//System.out.println("CEFTransformRule: Explanation=" + cef_explanation);

//Find the user parameter in CEF Explanation field
//System.out.println("CEFTransformRule: Breaking down the parameter list.....:");

Object o= Configuration.getSystemConfig().getList(Configuration.ATT_CEF_USER_NAME);
List cefUserNames = null;
if (o instanceof List) {
            cefUserNames = (List)o;
}

for (String paramPair: cef_explanation.split("\\s(?=\\S*(?&lt;!\\\\)=)", 0)){
//	System.out.println("CEFTransformRule: Parameter pair found " + paramPair);
    for(String cefUser: cefUserNames){
        String cefUserParam = cefUser.concat("=.*");
        if (paramPair.matches(cefUserParam)) {
            cef_user = paramPair.split("=",2)[1];
//            System.out.println("CEFTransformRule: duser parameter found! " + cef_user);
        }
    }   
}

// Set activity values
activity.setUser(cef_user);
activity.setAction(Action.Login);
activity.setResult(Result.Success);
activity.setInfo("vendor=" + cef_vendor + " host=" + cef_host + " " + cef_explanation + " severity=" + cef_severity + " product=" + cef_product);
activity.setTarget(cef_name);

// Set timestamp from CEF header, but add current year as this is not supplied
SimpleDateFormat f = new SimpleDateFormat("MMM dd hh:mm:ss yyyy");
defaultYear = Calendar.getInstance().get(Calendar.YEAR);
Date date = date = f.parse(cef_timestamp + " " + defaultYear);
activity.setTimeStamp(date);

return activity;</Source>
</Rule>
<Rule language="beanshell" name="CEFActivityCorrelation" type="ActivityCorrelation">
  <Description>Rule to show how an CEF activity might be correlated back to an identity. In most cases, this rule will be providing enought information to the correlator so that it can find the Application link. In some cases, it might also be desireable to return something that points back to an Identity, which is also supported.</Description>
  <Signature returnType="Map">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="application">
        <Description>
          The application where the activity was generated.
          An application may have more then one data source.
        </Description>
      </Argument>
      <Argument name="datasource">
        <Description>
          The data source that returned the activity.
        </Description>
      </Argument>
      <Argument name="activity">
        <Description>
          The activity object that was normalized by
          the data source and that we are trying to
          correlate back to one of our Identities.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="linkIdentity">
        <Description>
          A string that represents the link's identity attribute.
        </Description>
      </Argument>
      <Argument name="linkName">
        <Description>
          A string that represents the link's displayName attribute.
        </Description>
      </Argument>
      <Argument name="linkAttributeName">
        <Description>
          A string that represents the NAME of an attribute that
          can be used to find the Link that maps back to this
          activity.  This attribute must also be supplied
          with the linkAttributeValue variable.
        </Description>
      </Argument>
      <Argument name="linkAttributeValue">
        <Description>
          A string that represents the VALUE of an attribute that
          can be used to find the Link that maps back to this
          activity. This attribute must also be supplied
          with the linkAttributeName variable.
        </Description>
      </Argument>
      <Argument name="identityName">
        <Description>
          The name of an Identity object.
        </Description>
      </Argument>
      <Argument name="identity">
        <Description>
          A fully resolved Identity object in case the rule wants
          to do its own queries to locate the identity.
        </Description>
      </Argument>
      <Argument name="identityAttributeName">
        <Description>
          The name of the extended attribute that can be used
          to locate an existing identity.
        </Description>
      </Argument>
      <Argument name="identityAttributeValue">
        <Description>
          The value of the named extended attribute that can be used
          to locate an existing identity. This attribute is used
          together with the identityAttributeName argument.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import sailpoint.object.ApplicationActivity;
  import sailpoint.object.Configuration;
	
//  System.out.println("CEFActivityCorrelation: In Correlation Rule");

    Map returnMap = new HashMap();
    String user = activity.getUser();
	String cefLinkAttributeName = Configuration.getSystemConfig().getString(Configuration.ATT_CEF_LINK_ATTRIBUTE_NAME);
	
    if ( user != null ) {
//		System.out.println("CEFActivityCorrelation: Matching for user " + user);
        returnMap.put("linkAttributeName", cefLinkAttributeName);
        returnMap.put("linkAttributeValue", user);
//        System.out.println("returnMap " + returnMap);
    }

    return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Application Builder">
  <Description>
    A rule to build and manipulate IdentityIQ application in a bulk.
    All duties are mentioned below.
    1. When create mode is selected, then it creates multiple application in a bulk by parsing csv file.
    2. When update mode is selected, then it updates the attribute map of existing application by parsing input csv file.
    3. When read mode is selected, then it reads all existing IdentityIQ application and export them to csv file.
       Exports considers only attributes of the application.
  </Description>
  <Signature returnType="TaskResult">
    <Inputs>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to
          query the database to save application object and task definitions.
        </Description>
      </Argument>
      <Argument name="log">
        <Description>
          The log object for logging.
        </Description>
      </Argument>
      <Argument name="inputParams">
        <Description>
          The input params object is map of attributes received from Task UI.
        </Description>
      </Argument>
      <Argument name="taskResult">
        <Description>
          The task result object required for updating the result.
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
    
      import java.io.BufferedReader;
      import java.io.FileNotFoundException;
      import java.io.FileReader;
      import java.io.FileWriter;
      import java.io.IOException;
      import java.util.ArrayList;
      import java.util.Date;
      import java.util.HashMap;
      import java.util.LinkedHashMap;
      import java.util.List;
      import java.util.Map;
      import java.util.Set;
      import java.util.Iterator;
      import java.util.LinkedHashMap;
      import java.util.LinkedHashSet;
      import sailpoint.api.SailPointContext;
      import sailpoint.api.TaskManager;
      import sailpoint.connector.Connector;
      import sailpoint.connector.ConnectorFactory;
      import sailpoint.connector.DefaultApplicationFactory;
      import sailpoint.object.Application;
      import sailpoint.object.Attributes;
      import sailpoint.object.Identity;
      import sailpoint.object.Rule;
      import sailpoint.object.TaskDefinition;
      import sailpoint.object.TaskItemDefinition;
      import sailpoint.object.TaskSchedule;
      import sailpoint.object.TaskResult;
      import sailpoint.object.Filter;
      import sailpoint.object.QueryOptions;
      import sailpoint.object.Attributes;
      import sailpoint.object.AttributeDefinition;
      import sailpoint.object.Attributes;
      import sailpoint.object.Field;
      import sailpoint.object.Form;
      import sailpoint.object.Form.Section;
      import sailpoint.object.FormItem;
      import sailpoint.object.Schema;
      import sailpoint.tools.GeneralException;
      import sailpoint.tools.Message;
      import sailpoint.tools.Util;
      import sailpoint.tools.RFC4180LineIterator;
      import sailpoint.tools.RFC4180LineParser;
      import sailpoint.tools.Rfc4180CsvBuilder;
      import sailpoint.tools.Util;
      import sailpoint.tools.xml.XMLObjectFactory;

      // Private member variables
      private int applicationsCreated = 0;
      private int applicationsUpdated = 0;
      private int applicationsScanned = 0;
      private List applicationsExists = new ArrayList();
      private List applicationsNotFound = new ArrayList();
      private List applicationsFailed = new ArrayList();
      private List applicationObjects = new ArrayList();
      Map applicationMap = new LinkedHashMap();
      Set uniqueHeaders = new LinkedHashSet();

      // Private Input parameters
      private String filePath;
      private String applicationType;
      private String operation;
      private boolean triggerAccountAggregation;
      private boolean triggerGroupAggregation;
      private boolean skipTestConnection;
      private String launcher;
      private int applicationsPerAggregation = 10;

      // Public member variables
      /**
      * List of secret attributes used in different connector's application attribute.
      */
      Set secreteAttributes = new LinkedHashSet();
      String rowSeparator = "\n";
      private String docTypeHeader = "&lt;?xml version='1.0' encoding='UTF-8'?&gt;" +
                             "\n&lt;!DOCTYPE Application PUBLIC \"sailpoint.dtd\" \"sailpoint.dtd\"&gt;" +
                             "\n&lt;Application&gt;\n";
      private String docTypeFooter = "\n&lt;/Application&gt;";
      private String schemasHeader = "Schemas";
      private String provisioningFormsHeader = "ProvisioningForms";
      private String create = "create";
      private String update = "update";
      private String read = "read";

      /////////// public methods for processing IdentityIQ applications. ///////////
      //////////////////////////////////////////////////////////////////////////////

      /**
       * Parse the input CSV file based on fix format.
       * and convert it to the attribute map for further processing.
       */
      public void parseInputFile() {
          log.debug("Entering parseInputFile()...");

          BufferedReader br = null;

          try {

              List fileHeaders = new ArrayList();
              Map attributeMap = null;
              br = new BufferedReader(new FileReader(filePath));

              RFC4180LineParser parser = new RFC4180LineParser(",");
              RFC4180LineIterator iterator = new RFC4180LineIterator(br);

              String fileRow = iterator.readLine();

              // Parse file headers
              if (Util.isNotNullOrEmpty(fileRow)) {
                  log.debug("File headers: " + fileRow);

                  fileHeaders = Util.csvToList(fileRow);
              } else {
                  throw new GeneralException("Headers not found. File's first line should be headers.");
              }
              // Parse CSV file data
              while ((fileRow = iterator.readLine()) != null) {
                  List fileRowList = Util.csvToList(fileRow);
                  attributeMap = new HashMap();
                  boolean isApplicationName = true;
                  String applicationName = "";

                  if (fileRowList != null) {
                      if (fileRowList.size() &gt; fileHeaders.size()) {
                          throw new GeneralException("Mismach in row data and headers length. Affected row: " + fileRow);
                      }
                      // Attribute Map received from input file
                      for (int i = 0; i &lt; fileRowList.size(); i++) {
                          String fileRowData = (String)fileRowList.get(i);
                          if (Util.isNotNullOrEmpty(fileRowData)) {
                              if (isApplicationName) {
                                   applicationName = fileRowData;
                                   isApplicationName = false;
                              } else {
                                  if (fileRowData.equalsIgnoreCase("true") || fileRowData.equalsIgnoreCase("false")) {
                                      attributeMap.put(fileHeaders.get(i), Boolean.parseBoolean(fileRowData));
                                  } else {
                                      attributeMap.put(fileHeaders.get(i), fileRowData);
                                  }
                              }
                          }
                      }

                      if (Util.isNotNullOrEmpty(applicationName)) {
                         applicationMap.put(applicationName, attributeMap);
                      }
                  }
              }
          } catch (FileNotFoundException e) {
              throw new GeneralException("File parsing failed. " + e.getMessage(), e);
          } catch (IOException e) {
              throw new GeneralException("File parsing failed. " + e.getMessage(), e);
          } finally {
              try {
                  if (br != null) {
                      br.close();
                  }
              } catch (Exception ex) {
                  log.warn("Error while closing BufferedReader object. " + ex.getMessage);
              }
          }

          log.debug("Exiting parseInputFile()...");
      }

      /**
       * Create multiple IdentityIQ applications based on input application data.
       */
      private void createApplications() {
          log.debug("Entering createApplications()...");

          List aggregationappList = new ArrayList();

          for (Map.Entry entry : applicationMap.entrySet()) {
              String applicationName = (String) entry.getKey();
              Application application = context.getObjectByName(Application.class, applicationName);
              if (application != null) {
                  log.warn("The application '" + applicationName +"' already exists on the IdentityIQ server.");

                  applicationsExists.add(applicationName);
                  continue;
              }

              // Create new IdentityIQ application
              log.debug("Creating the application: " + applicationName);

              application = DefaultApplicationFactory.getDefaultApplicationByTemplate(applicationType);
              application.setCreated(new Date());
              application.setModified(new Date());
              application.setName(entry.getKey());
              application.setAuthoritative(false);
              application.setCaseInsensitive(true);
              application.setIcon("enterpriseIcon");
              application.setOwner(context.getObjectByName(Identity.class, launcher));

              try {
                  createOrUpdateApplications(entry, application, aggregationappList);
              } catch (Exception ex) {
                  applicationsFailed.add(application.getName());
                  log.error("Failed to create the application '" + applicationName + "'. " + ex.getMessage(), ex);

                  continue;
              }
          }

          // Perform account and group aggregation for remianing applications
          if (!aggregationappList.isEmpty()) {
              triggerAggregation(aggregationappList);
          }

          updateTaskResult();

          log.debug("Exiting createApplications()...");
      }

      /**
       * Update multiple IdentityIQ applications based on input application data.
       */
      private void updateApplications() {
          log.debug("Entering updateApplications()...");

          List aggregationappList = new ArrayList();

          for (Map.Entry entry : applicationMap.entrySet()) {
              String applicationName = (String) entry.getKey();
              Application application = context.getObjectByName(Application.class, applicationName);
              if (application == null) {
                  log.warn("The application '" + applicationName + "' is not found.");

                  applicationsNotFound.add(applicationName);
                  continue;
              }

              // Update existing IdentityIQ application
              log.debug("Updating the application: " + applicationName);

              try {
                  createOrUpdateApplications(entry, application, aggregationappList);
              } catch (Exception ex) {
                  applicationsFailed.add(application.getName());
                  log.error("Failed to update the application '" + applicationName + "'. " + ex.getMessage(), ex);

                  continue;
              }
          }

          // Perform account and group aggregation for remianing applications
          if (!aggregationappList.isEmpty()) {
              triggerAggregation(aggregationappList);
          }

          updateTaskResult();

          log.debug("Exiting updateApplications()...");
      }

      /**
       * Retriving the application object from IdentityIQ database for given application type and
       * updating the applicationMap which will be exported to csv file.
       */
      public void updateAttributesMap() {
          log.debug("Entering updateAttributesMap()...");

          Map attributeMap = null;
          boolean encryptedAttrFound = false;

          // Query filter to get list of applications for the specified application type
          Filter filter = Filter.eq("type", applicationType);

          // List of application objects
          List applicationsObjectList = context.getObjects(Application.class, new QueryOptions().addFilter(filter));

          log.debug("Total number of applications of type '" + applicationType + "' are: " + applicationsObjectList.size());

          for (Application application : applicationsObjectList) {
              try {
                  log.debug("Application name: " + application.getName());

                  uniqueHeaders.add("Name");
                  attributeMap = new HashMap();
                  applicationMap.put(application.getName(), attributeMap);
                  attributeMap.put("Name", application.getName());
                  Attributes attrMap = application.getAttributes();

                  // Update encrypted attribute
                  if (!encryptedAttrFound) {
                      if (attrMap.get("encrypted") != null) {
                          List encryptedAttrs = Util.csvToList(attrMap.get("encrypted").toString());
                          secreteAttributes.addAll(encryptedAttrs);
                          encryptedAttrFound = true;
                      }
                  }

                  for (Map.Entry entry : attrMap.entrySet()) {
                      if (entry.getValue() != null) {
                          if (entry.getValue() instanceof String || entry.getValue() instanceof Boolean) {

                              // Update attribute map with key and value
                              attributeMap.put(entry.getKey().toString(), entry.getValue());

                              // Update header set
                              uniqueHeaders.add(entry.getKey().toString());
                          }
                      }
                  }

                  String appXML = application.toXml(false);

                  String schemasHeaderTag = "&lt;Schemas&gt;";
                  String schemasFooterTag = "&lt;/Schemas&gt;";
                  if (appXML.indexOf(schemasHeaderTag) &gt; 0) {
                      String schema = appXML.substring(appXML.indexOf(schemasHeaderTag), appXML.indexOf(schemasFooterTag) + 10);
                      uniqueHeaders.add(schemasHeader);
                      attributeMap.put(schemasHeader, schema);
                  }

                  String provisioningFormsHeaderTag = "&lt;ProvisioningForms&gt;";
                  String provisioningFormsFooterTag = "&lt;/ProvisioningForms&gt;";
                  if (appXML.indexOf(provisioningFormsHeaderTag) &gt; 0) {
                      String forms = appXML.substring(appXML.indexOf(provisioningFormsHeaderTag), appXML.indexOf(provisioningFormsFooterTag) + 20);
                      uniqueHeaders.add(provisioningFormsHeader);
                      attributeMap.put(provisioningFormsHeader, forms);
                  }
              } catch (Exception e) {
                  log.warn("Failed to read application: " + application.getName() + ". " + e.getMessage(), e);
              }
          }

          log.debug("Exiting updateAttributesMap()...");
      }

      /**
      * Export Applications attribute map in csv format.
      */
      public void exportApplications() {
          log.debug("Entering exportApplications()...");

          FileWriter fileWriter = null;

          if (Util.isEmpty(applicationMap)) {
              log.warn("Application '" + applicationType + "' not found on the IdentityIQ server.");

              taskResult.setCompletionStatus(TaskResult.CompletionStatus.Success);
              taskResult.setAttribute("applicationsScanned", applicationMap.size());
          } else {
              // Perform the file operation when application map is non empty.
              try {
                  log.debug("Application map size: " + applicationMap.size());

                  Rfc4180CsvBuilder csvBuilder = new Rfc4180CsvBuilder();
                  List headers = new ArrayList(uniqueHeaders);

                  // Make sure Schemas column and/or ProvisioningForms placed after configuration attributes
                  if (headers.contains(schemasHeader)) {
                     headers.remove(schemasHeader);
                     headers.add(schemasHeader);
                  }

                  if (headers.contains(provisioningFormsHeader)) {
                     headers.remove(provisioningFormsHeader);
                     headers.add(provisioningFormsHeader);
                  }

                  fileWriter = new FileWriter(filePath);
                  fileWriter.append(Util.listToCsv(headers));
                  fileWriter.append(rowSeparator);

                  for (Map.Entry entry : applicationMap.entrySet()) {
                      StringBuffer attributeRow = new StringBuffer();
                      Map innerAttrMap = (Map) entry.getValue();
                      for (String headerName : headers) {
                          String attrValue = (innerAttrMap.get(headerName) != null) ? innerAttrMap.get(headerName).toString() : "";

                          if (secreteAttributes.contains(headerName)) {
                              attrValue = "";
                          }

                          csvBuilder.addValue(attrValue);
                      }

                      // Update File Row
                      fileWriter.append(csvBuilder.build());

                      fileWriter.append(rowSeparator);
                      csvBuilder.flush();
                  }
              } catch (Exception e) {
                  throw new GeneralException("Failed to export the application attributes map to a file. " + e.getMessage(), e);
              } finally {
                  try {
                      if (fileWriter != null) {
                          fileWriter.flush();
                          fileWriter.close();
                      }
                  } catch (Exception ex) {
                      log.warn("Error while closing fileWriter object. " + ex.getMessage);
                  }
              }

              updateTaskResult();
          }

          log.debug("Exiting exportApplications()...");
       }

      /**
       * Run Account aggregation task for the multiple IdentityIQ applications
       * @param applicationNames comma saperated application names
       *
       */
      private void executeAccountAggregation(String applicationNames) throws GeneralException {
          log.debug("Entering executeAccountAggregation()...");

          TaskManager tm = new TaskManager(context);
          HashMap taskArgs = new HashMap();
          TaskDefinition taskDefinition = new TaskDefinition();
          taskDefinition.setName(applicationType + " Account Aggregation " + new Date() + " - " + Util.rand(1, 10000));
          taskDefinition.setDescription("Account Aggregation task for " + applicationType);
          taskDefinition.setType(TaskItemDefinition.Type.AccountAggregation);
          taskDefinition.setResultAction(TaskDefinition.ResultAction.Delete);
          taskDefinition.setFormPath("/monitor/tasks/accountAggregationTask.xhtml");
          taskDefinition.setArgument("applications", applicationNames);
          taskDefinition.setArgument("checkDeleted", "true");
          taskDefinition.setArgument("promoteManagedAttributes", "true");
          taskDefinition.setArgument("logAllowedActions", null);
          taskDefinition.setOwner(context.getObjectByName(Identity.class, launcher));
          taskDefinition.setParent(context.getObject(TaskDefinition.class, "Account Aggregation"));
          context.saveObject(taskDefinition);
          context.commitTransaction();
          tm.run(taskDefinition, taskArgs);

          log.debug("Account aggregation task is executed for the application '" + applicationNames + "'.");
          log.debug("Exiting executeAccountAggregation()...");
      }

      /**
       * Run Group aggregation task for the multiple IdentityIQ applications
       * applicationNames comma saperated application names
      */
      private void executeGroupAggregation(String applicationNames) throws GeneralException {
          log.debug("Entering executeGroupAggregation()...");

          TaskManager tm = new TaskManager(context);
          HashMap taskArgs = new HashMap();
          TaskDefinition taskDefinition = new TaskDefinition();
          taskDefinition.setName(applicationType + " Group Aggregation " + new Date() + " - " + Util.rand(1, 10000));
          taskDefinition.setDescription("Group Aggregation task for " + applicationType);
          taskDefinition.setType(TaskItemDefinition.Type.AccountGroupAggregation);
          taskDefinition.setArgument("aggregationType", "group");
          taskDefinition.setFormPath("/monitor/tasks/accountGroupAggregationTask.xhtml");
          taskDefinition.setArgument("applications", applicationNames);
          taskDefinition.setArgument("checkDeleted", "true");
          taskDefinition.setOwner(context.getObjectByName(Identity.class, launcher));
          taskDefinition.setExecutor("sailpoint.task.ResourceIdentityScan");
          taskDefinition.setResultRenderer("accountGroupAggregationResult.xhtml");
          taskDefinition.setParent(context.getObject(TaskDefinition.class, "Account Group Aggregation"));
          context.saveObject(taskDefinition);
          context.commitTransaction();
          tm.run(taskDefinition, taskArgs);

          log.debug("Group aggregation task is executed for the application '" + applicationNames + "'.");
          log.debug("Exiting executeGroupAggregation()...");

      }

      /**
       * Create/Update multiple IdentityIQ application from the provided csv file.
       * Also ability to trigger test connection and aggregation based on user input.
       * User can provide schema and provisioning form while create and/or update.
       * The schema merge can be partial or full update.
       * The provisioning forms is full update. i.e it will set whatever forms provided in csv file. 
       */
      private void createOrUpdateApplications(Map.Entry entry, Application application, List aggregationappList) {
          log.debug("Entering createOrUpdateApplications()...");

          Map innerMap = (Map) entry.getValue();
          String applicationName = application.getName();

          for (Map.Entry entryMap : innerMap.entrySet()) {
              String key = (String)entryMap.getKey();
              Object value = entryMap.getValue();

              if (key != null &amp;&amp; !applicationObjects.contains(key) &amp;&amp; value != null) {
                  application.setAttribute((String)entryMap.getKey(), entryMap.getValue());
              }

              if (applicationObjects.contains(key) &amp;&amp; schemasHeader.equals(key)) {
                  mergeSchemas(application, value.toString());
              }

              if (applicationObjects.contains(key) &amp;&amp; provisioningFormsHeader.equals(key)) {
                  setProvisioningForms(application, value.toString());
              }
          }

          // Skip the test connection if the flag is true
          if (!skipTestConnection) {
                Connector conn = ConnectorFactory.getConnector(application, null);
                conn.testConfiguration();
                log.debug("Test connection is successful for the application: " + applicationName);
          } else {
             log.debug("Skipping Test connection for the application: " + applicationName);
          }

          context.saveObject(application);
          context.commitTransaction();

          if (create.equals(operation)) {
              applicationsCreated++;
              log.debug("Created the application: " + applicationName);
          } else if (update.equals(operation)) {
              applicationsUpdated++;
              log.debug("Updated the application: " + applicationName);
          }

          aggregationappList.add(application.getName());

          // Perform account and group aggregation task for configured applications per aggregation
          if (aggregationappList.size() &gt;= applicationsPerAggregation) {
                triggerAggregation(aggregationappList);

                // clear the list for the next chunk of aggregations
                aggregationappList.clear();
          }

          log.debug("Exiting createOrUpdateApplications()...");
      }

      /**
       * Merge schema attribute definitions to specific schema.
       */
      private void mergeSchemas(Application app, String value) {
          log.debug("Entering mergeSchemas() for: " + app.getName());

          if (value != null) {
              String schemas = docTypeHeader + value + docTypeFooter;

              try {
                  Application tempApp = (Application)XMLObjectFactory.getInstance().parseXml(context, schemas, true);
                  List tempAppSchemas = tempApp.getSchemas();
    
                  for (Schema tempSchema : tempAppSchemas) {
                      Schema orgAppSchema = app.getSchema(tempSchema.getObjectType());
    
                      // Found schema, add the new attribute
                      if (orgAppSchema != null) {
                          List tempAttributes = tempSchema.getAttributes();
                          List orgAttributes = orgAppSchema.getAttributes();
                          List orgAttributesNames = orgAppSchema.getAttributeNames();

                          if (tempSchema.getIdentityAttribute() != null) {
                              orgAppSchema.setIdentityAttribute(tempSchema.getIdentityAttribute());
                          }

                          if (tempSchema.getDisplayAttribute() != null) {
                              orgAppSchema.setDisplayAttribute(tempSchema.getDisplayAttribute());
                          }

                          if (tempSchema.getInstanceAttribute() != null) {
                              orgAppSchema.setInstanceAttribute(tempSchema.getInstanceAttribute());
                          }
    
                          for (AttributeDefinition tempAttribute : tempAttributes) {
                              if (orgAttributesNames.contains(tempAttribute.getName())) {
                                  log.debug("Found Schema attribute: '" + tempAttribute.getName() + "'.");

                                  // Attribute Definition found, remove it first.
                                  int index = orgAttributesNames.indexOf(tempAttribute.getName());
                                  orgAttributes.remove(orgAttributesNames.indexOf(tempAttribute.getName()));
                                  log.debug("Removed Schema attribute: '" + tempAttribute.getName() + "'.");

                                  // Add attribute to specific index
                                  orgAttributes.add(index, tempAttribute);
                                  log.debug("Added Schema attribute: '" + tempAttribute.getName() + "'.");
                              } else {
                                  // Add attribute, as it not present in original schema
                                  orgAttributes.add(tempAttribute);
                                  log.debug("Added Schema attribute: '" + tempAttribute.getName() + "'.");
                              }
                          }
                      } else { 
                          // add new schema
                          // cleaning id, created, modified schema attributes for the new schema if they exists.
                          // ideally new schema should not have those attributes.
                          if (tempSchema.getId() != null) {
                              tempSchema.setId(null);
                          }
                          if (tempSchema.getId() != null) {
                              tempSchema.setId(null);
                          }
                          if (tempSchema.getCreated() != null) {
                              tempSchema.setCreated(null);
                          }
                          if (tempSchema.getModified() != null) {
                              tempSchema.setModified(null);
                          }

                          app.setSchema(tempSchema);
                      }
                  }
              } catch (Exception e) {
                  String message = "Failed to merge Schema for the application: '" + app.getName() + "'.";
                  log.error(message, e);
                  throw new GeneralException(message, e);
              }
          }

          log.debug("Exiting mergeSchemas()...");
      }

      /**
       * Sets Provisioning forms to the application based on user input.
       * It is full update. i.e Application will set provisioning forms defined in the csv file.
       */
      private void setProvisioningForms(Application app, String value) {
          log.debug("Entering setProvisioningForms() for: " + app.getName());

          if (value != null) {
              String provisioningForms = docTypeHeader + value + docTypeFooter;
              try {
                  Application tempApp = (Application)XMLObjectFactory.getInstance().parseXml(context, provisioningForms, true);
                  List tempAppProvisioningForms = tempApp.getProvisioningForms();
    
                  if (tempAppProvisioningForms != null) {
                      app.setProvisioningForms(tempAppProvisioningForms);
                  }
              } catch (Exception e) {
                  String message = "Failed to set Provisioning Forms for the application: '" + app.getName() + "'.";
                  log.error(message, e);
                  throw new GeneralException(message, e);
              }
          }

          log.debug("Exiting setProvisioningForms()...");
      }

      /**
       * Trigger aggregation.
       */
      private void triggerAggregation(List aggregationappList) {
          String appsToaggregate = Util.listToCsv(aggregationappList);
          // Trigger account aggregation
          if (triggerAccountAggregation) {
              executeAccountAggregation(appsToaggregate);
          }

          // Trigger group aggregation
          if (triggerGroupAggregation) {
              executeGroupAggregation(appsToaggregate);
          }
      }

      /**
       * Update task result of Create/Update Applications.
       */
      private void updateTaskResult() {
          log.debug("Entering updateTaskResult()...");

          if (applicationsFailed.size() &gt; 0) {
              taskResult.setCompletionStatus(TaskResult.CompletionStatus.Error);
              if (create.equals(operation)) {
                  taskResult.addMessage(Message.error("application_builder_create_failed_error", applicationsFailed.size()));
              } else if (update.equals(operation)) {
                  taskResult.addMessage(Message.error("application_builder_update_failed_error", applicationsFailed.size()));
              }
          } else if (applicationsExists.size() &gt; 0) {
              taskResult.setCompletionStatus(TaskResult.CompletionStatus.Warning);
              taskResult.addMessage(Message.warn("application_builder_create_warning_msg", filePath));
          } else if (applicationsNotFound.size() &gt; 0) {
              taskResult.setCompletionStatus(TaskResult.CompletionStatus.Warning);
              taskResult.addMessage(Message.warn("application_builder_update_warning_msg", filePath));
          } else {
              taskResult.setCompletionStatus(TaskResult.CompletionStatus.Success);
          }

          if (create.equals(operation)) {
              taskResult.setInt("applicationsCreated", applicationsCreated);
              taskResult.setAttribute("applicationsExists", Util.listToCsv(applicationsExists));
          } else if (update.equals(operation)) {
              taskResult.setInt("applicationsUpdated", applicationsUpdated);
              taskResult.setAttribute("applicationsNotFound", Util.listToCsv(applicationsNotFound));
          } else if (read.equals(operation)) {
              taskResult.setCompletionStatus(TaskResult.CompletionStatus.Success);
              taskResult.setAttribute("applicationsScanned", applicationMap.size());
              taskResult.setAttribute("exportFilePath", filePath);
          }

          taskResult.setAttribute("applicationsFailed", Util.listToCsv(applicationsFailed));
          log.debug("Exiting updateTaskResult()...");
      }

      /////////////////// MAIN START /////////////////
      ////////////////////////////////////////////////


      log.debug("Application Builder Rule execution start...");

      try {
          // Retriving input parameters
          filePath = inputParams.get("filePath");
          applicationType = inputParams.get("applicationType");
          operation = inputParams.get("operation");
          triggerAccountAggregation = inputParams.get("triggerAccountAggregation");
          triggerGroupAggregation = inputParams.get("triggerGroupAggregation");
          launcher = inputParams.get("launcher");
          skipTestConnection = inputParams.get("skipTestConnection");

          if (!(filePath.trim().endsWith(".csv") || filePath.trim().endsWith(".CSV"))) {
              throw new GeneralException("Invalid input file format '" + filePath + "'. Only CSV format is supported.");
          }

          if (inputParams.get("applicationsPerAggregation") != null) {
              try {
                  if (Integer.parseInt(inputParams.get("applicationsPerAggregation")) &gt; 0) {
                      applicationsPerAggregation = Integer.parseInt(inputParams.get("applicationsPerAggregation"));
                  }
              } catch (NumberFormatException e) {
                  log.warn("Invalid value for the attribute 'applicationsPerAggregation'. " + e.getMessage() + ". Considering default value " + applicationsPerAggregation , e);
              }
          }

          // Update Secrete attribute list as per sailpoint.object.Application
          secreteAttributes.add("password");
          secreteAttributes.add("cmdClientPassword");
          secreteAttributes.add("adminPassword");
          secreteAttributes.add("apikey");
          secreteAttributes.add("kid");
          secreteAttributes.add("secret");
          secreteAttributes.add("keystorePwd");
          secreteAttributes.add("token");
          secreteAttributes.add("transportUserPassword");
          secreteAttributes.add("group.password");
          secreteAttributes.add("accountId");
          secreteAttributes.add("keystorepassword");
          secreteAttributes.add("pkeypassword");
          secreteAttributes.add("admin_password");
          secreteAttributes.add("SudoUserPassword");
          secreteAttributes.add("PassphraseForPrivateKey");
          secreteAttributes.add("passwd");

          // Add application objects to list, special handling for merge is required.
          applicationObjects.add(schemasHeader);
          applicationObjects.add(provisioningFormsHeader);

          // Perform Task based on operation type
          switch (operation) {
              case create:
                  parseInputFile();
                  createApplications();
                  break;
              case update:
                  parseInputFile();
                  updateApplications();
                  break;
              case read:
                  updateAttributesMap();
                  exportApplications();
                  break;
              default:
                  log.debug("Invalid Operation.");
                  break;
          }
      } catch (GeneralException e) {
          log.error(Message.error("application_builder_task_error", e.getMessage()), e);

          // Update taskResult object with error details
          taskResult.setCompletionStatus(TaskResult.CompletionStatus.Error);
          taskResult.addMessage(Message.error("application_builder_task_error", e.getMessage()));
      } catch (Exception e) {
          GeneralException ex = new GeneralException(Message.error("application_builder_task_error", e.getMessage()), e);
          log.error(ex.getMessage(), ex);

          // Update taskResult object with error details
          taskResult.setCompletionStatus(TaskResult.CompletionStatus.Error);
          taskResult.addMessage(Message.error("application_builder_task_error", e.getMessage()));
      }

      return taskResult;
    
  </Source>
</Rule>
<Rule language="beanshell" name="Rule_AuditEvents_01" type="FieldValue">
  <Source>
  
import sailpoint.api.SailPointContext;
import sailpoint.object.AuditEvent;
import sailpoint.server.Auditor;
import sailpoint.tools.GeneralException;
import org.apache.commons.logging.Log;;
 
 
		  log.debug("Rule starting...."); 
	 	  
		    AuditEvent event=new AuditEvent();
		    event.setAction("Email Sent");
        event.setAction("Email Failure");
		   
		   
	     	   Auditor.log(event);
		      context.saveObject(event);
		     context.commitTransaction();
		   
		   log.debug("Rule ending...");
 
    
    
  </Source>
</Rule>
<Rule language="beanshell" name="Rule-Create_Email" type="JDBCBuildMap">
  <Description>This rule is used by the JDBC connector to build a map representation of the Resultset.</Description>
  <Signature returnType="Map">
    <Inputs>
      <Argument name="log" type="org.apache.commons.logging.Log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context" type="sailpoint.api.SailPointContext">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="application">
        <Description>
                The application whose data file is being processed.
                </Description>
      </Argument>
      <Argument name="schema">
        <Description>
                The Schema currently in use.
                </Description>
      </Argument>
      <Argument name="state">
        <Description>
                A Map containing state information.
                </Description>
      </Argument>
      <Argument name="result">
        <Description>
                The ResultSet from database.
                </Description>
      </Argument>
      <Argument name="connection">
        <Description>
                A connection object to connect to database.
                </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="map">
        <Description>
                A Map of the resource object assembled from the data.
                </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import sailpoint.object.Permission;
import sailpoint.connector.*;



System.out.println("--------&gt;&gt; Starting Rule &lt;&lt;-------------");
		
	Map connect=JDBCConnector.buildMapFromResultSet(result,schema);
		
		String fn=connect.get("emp_firstname");
		String ls=connect.get("emp_lastname");
		
		String combine=fn+"."+ls+"@sailpoint.com";
		connect.put("email",combine);
		
		
System.out.println("--------&gt;&gt; Ending Rule &lt;&lt;-------------");


return connect;</Source>
</Rule>
<Rule language="beanshell" name="Rule-onepassword" type="JDBCBuildMap">
  <Source>
  


import sailpoint.object.*;
import sailpoint.tools.GeneralException;Â 
import java.util.*;
Â import sailpoint.api.SailPointContext;
import sailpoint.api.Terminator;Â 
 import sailpoint.object.SailPointObject;

Â 




Â Â Â Â Â  Identity identity = context.getObjectByName(Identity.class, "2");



Â // return "\n"+"password: "+identity.getPassword()+"\n"+"decrepted password: "+context.decrypt(identity.getPassword());
  
  Â  return "\n"+"password: "+identity.getPassword()+"\n"+"decrepted password: "+context.decrypt("1:ACP:xWMj+k0IEyqr9Tt6f4I4TTWZnN6EAvLCR0uVM6PZlRw=");
  
  
  
  1:ACP:xWMj+k0IEyqr9Tt6f4I4TTWZnN6EAvLCR0uVM6PZlRw=



  
  
  
  
  
</Source>
</Rule>
<Rule language="beanshell" name="Rule-Password" type="JDBCBuildMap">
  <Source>
  
  
  
  import sailpoint.api.PasswordGenerator;
import sailpoint.object.PasswordPolicy;
import sailpoint.object.Identity;
import sailpoint.object.Capability;
import sailpoint.object.ResourceObject;

  
      String mypolicy = "PassCredentials";

		  PasswordPolicy policy = context.getObjectByName(PasswordPolicy.class, mypolicy);

		  String password = new PasswordGenerator(context).generatePassword(policy);
		  
		  identity.setPassword(password);
  
  
  
  
  
  
</Source>
</Rule>
<Rule language="beanshell" name="Rule-Provisioning_Delete" type="JDBCOperationProvisioning">
  <Description>This rule is used by the JDBC connector to do provisioning of the data .</Description>
  <Signature returnType="ProvisioningResult">
    <Inputs>
      <Argument name="log" type="org.apache.commons.logging.Log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context" type="sailpoint.api.SailPointContext">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="application">
        <Description>The application whose data file is being processed.</Description>
      </Argument>
      <Argument name="schema">
        <Description>The Schema currently in use.</Description>
      </Argument>
      <Argument name="connection">
        <Description>A connection object to connect to database.</Description>
      </Argument>
      <Argument name="plan">
        <Description>The ProvisioningPlan created against the JDBC application.</Description>
      </Argument>
      <Argument name="request">
        <Description>The ProvisioningRequest created against the JDBC application.</Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="result">
        <Description>A Provisioning Result object is desirable to return the status.IT can be a new object or part of  Provisioning Plan</Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import java.sql.Connection;
import java.sql.PreparedStatement;
import java.util.List;
import sailpoint.object.ProvisioningPlan;
import sailpoint.object.ProvisioningPlan.AccountRequest;
import sailpoint.object.ProvisioningResult;

Â log.error("calling delete for HR self service");

Â Â Â Â Â Â Â  ProvisioningResult result=new ProvisioningResult();
Â Â Â Â Â Â Â  List accountRequest=plan.getAccountRequests();
Â Â Â Â Â Â Â  log.error(plan.toXml());
Â Â Â Â Â Â Â  for(ProvisioningPlan.AccountRequest acct:accountRequest)
Â Â Â Â Â Â Â  {
Â Â Â Â Â Â Â Â Â Â Â  if(AccountRequest.Operation.Delete.equals(acct.getOperation()))
Â Â Â Â Â Â Â Â Â Â Â  {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  log.error(acct.getOperation());
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  PreparedStatement statement=connection.prepareStatement("update ohrm_user set deleted='1' where emp_number=?");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  statement.setString(1, acct.getNativeIdentity());
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  statement.executeUpdate();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  result.setStatus(ProvisioningResult.STATUS_COMMITTED);
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â  elseÂ 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  result.setStatus(ProvisioningResult.STATUS_FAILED);
Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â  return result;</Source>
</Rule>
<Rule language="beanshell" name="Rule-Provisioning_Disable" type="JDBCOperationProvisioning">
  <Description>This rule is used by the JDBC connector to do provisioning of the data .</Description>
  <Signature returnType="ProvisioningResult"/>
  <Source>import java.sql.Connection;
import java.sql.PreparedStatement;
import java.util.List;
import sailpoint.object.ProvisioningPlan;
import sailpoint.object.ProvisioningPlan.AccountRequest;
import sailpoint.object.ProvisioningResult;

Â log.error("calling leaver for HR self service");

Â Â Â Â Â Â Â  ProvisioningResult result=new ProvisioningResult();
Â Â Â Â Â Â Â  List accountRequest=plan.getAccountRequests();
Â Â Â Â Â Â Â  log.error(plan.toXml());
Â Â Â Â Â Â Â  for(ProvisioningPlan.AccountRequest acct:accountRequest)
Â Â Â Â Â Â Â  {
Â Â Â Â Â Â Â Â Â Â Â  if(AccountRequest.Operation.Disable.equals(acct.getOperation()))
Â Â Â Â Â Â Â Â Â Â Â  {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  log.error(acct.getOperation());
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  PreparedStatement statement=connection.prepareStatement("update ohrm_user set status='0' where emp_number=?");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  statement.setString(1, acct.getNativeIdentity());
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  statement.executeUpdate();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  result.setStatus(ProvisioningResult.STATUS_COMMITTED);
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â  elseÂ 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  result.setStatus(ProvisioningResult.STATUS_FAILED);
Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â  return result;</Source>
</Rule>
<Rule language="beanshell" name="Terminated_OU" type="JDBCOperationProvisioning">
  <Description>This rule is used by the JDBC connector to do provisioning of the data .</Description>
  <Signature returnType="ProvisioningResult">
    <Inputs>
      <Argument name="log" type="org.apache.commons.logging.Log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context" type="sailpoint.api.SailPointContext">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="application">
        <Description>The application whose data file is being processed.</Description>
      </Argument>
      <Argument name="schema">
        <Description>The Schema currently in use.</Description>
      </Argument>
      <Argument name="connection">
        <Description>A connection object to connect to database.</Description>
      </Argument>
      <Argument name="plan">
        <Description>The ProvisioningPlan created against the JDBC application.</Description>
      </Argument>
      <Argument name="request">
        <Description>The ProvisioningRequest created against the JDBC application.</Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="result">
        <Description>A Provisioning Result object is desirable to return the status.IT can be a new object or part of  Provisioning Plan</Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import sailpoint.object.Application;
import sailpoint.object.Identity;
import java.util.ArrayList;
import sailpoint.api.Provisioner;
import sailpoint.api.SailPointContext;
import sailpoint.object.Application;
import sailpoint.object.Identity;
import sailpoint.object.ProvisioningPlan;
import sailpoint.object.ProvisioningPlan.AccountRequest;
import  sailpoint.object.ProvisioningPlan.AttributeRequest;


String identityName = "Muneer.Ahmed";
		Identity identity = context.getObject(Identity.class, identityName);

		ProvisioningPlan plan = new ProvisioningPlan();
		ArrayList&lt;AccountRequest&gt; accountRequestList = new ArrayList&lt;&gt;();
		plan.setIdentity(identity);
           log.error("----------------&gt;&gt;&gt;&gt;&gt;Working&lt;&lt;&lt;&lt;-----------");
		// Get the LDAP application
		Application ldapApplication = context.getObject(Application.class, "HR Self Service");

		// Create an account modification request for the disabled user
		AccountRequest ldapAccountRequest = new AccountRequest();
		ldapAccountRequest.setApplication(ldapApplication.getName());
		ldapAccountRequest.setOperation(AccountRequest.Operation.Modify);
	 log.error("----------------&gt;&gt;&gt;&gt;&gt;Working--2&lt;&lt;&lt;&lt;-------);
ldapAccountRequest.setNativeIdentity("cn=Muneer.Ahmed,cn=Terminated,dc=sailpoint,dc=sp");

		// Set the new OU for the user
		AttributeRequest ouAttributeRequest = new AttributeRequest("ou", ProvisioningPlan.Operation.Set, "Terminated");
		ldapAccountRequest.add(ouAttributeRequest);

		// Check if the user is disabled
		if (identity.isDisabled()) {
		    accountRequestList.add(ldapAccountRequest);
		}
	 log.error("----------------&gt;&gt;&gt;&gt;&gt;Working--3&lt;&lt;&lt;&lt;-------);
		plan.setAccountRequests(accountRequestList);
		System.out.println("Plan ----&gt;" + plan.toXml());

		// Execute the provisioning plan
		Provisioner p = new Provisioner(context);
		p.compile(plan);
		p.execute();</Source>
</Rule>
<Rule language="beanshell" name="Rule-Provisioning_Create" type="JDBCOperationProvisioning">
  <Description>This rule is used by the JDBC connector to do provisioning of the data .</Description>
  <Signature returnType="ProvisioningResult">
    <Inputs>
      <Argument name="log" type="org.apache.commons.logging.Log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context" type="sailpoint.api.SailPointContext">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="application">
        <Description>The application whose data file is being processed.</Description>
      </Argument>
      <Argument name="schema">
        <Description>The Schema currently in use.</Description>
      </Argument>
      <Argument name="connection">
        <Description>A connection object to connect to database.</Description>
      </Argument>
      <Argument name="plan">
        <Description>The ProvisioningPlan created against the JDBC application.</Description>
      </Argument>
      <Argument name="request">
        <Description>The ProvisioningRequest created against the JDBC application.</Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="result">
        <Description>A Provisioning Result object is desirable to return the status.IT can be a new object or part of  Provisioning Plan</Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import sailpoint.object.ProvisioningResult;
import sailpoint.object.ProvisioningPlan;
import sailpoint.object.ProvisioningPlan.AccountRequest;
import sailpoint.object.ProvisioningPlan.AttributeRequest;
//import sailpoint.object.Filter;
import sailpoint.object.ManagedAttribute;
import sailpoint.object.Link;
import sailpoint.tools.Util;
import sailpoint.api.IdentityService;
import java.util.List;
import java.util.HashMap;
import java.sql.PreparedStatement;Â 



public String getAttributeRequestValue(AccountRequest acctReq, String attribute)
{
if (acctReq != null )Â 
{

AttributeRequest attrReq = acctReq.getAttributeRequest(attribute);

if ( attrReq != null )
{

System.out.println("========= attribute =======:"+attribute);

System.out.println("========= attrReqvalue =======:"+attrReq.getValue());

return attrReq.getValue();
}

}
return null;
}
System.out.println("========= attribute =======:");
System.out.println("========= attribute =======:");
Â ProvisioningResult result = new ProvisioningResult();

System.out.println("========= attribute =======:");Â Â AccountRequest acctRequest=(AccountRequest) request;Â Â System.out.println("========= attribute =======:");
try
{
String operation=acctRequest.getOperation().toString();

//if ("Create".equals(operation))

//{

System.out.println("========= inSide create =======");Â 
PreparedStatement statement = connection.prepareStatement("insert into orangehrm.ohrm_user(id,user_role_id, emp_number, user_name, user_password) values (?,?,?,?,?)");Â statement.setInt(3, Integer.parseInt(acctRequest.getNativeIdentity()));

Â 

System.out.println("========= inSide create======="+Integer.parseInt(acctRequest.getNativeIdentity()));Â 

Â 

statement.setString(1, getAttributeRequestValue(acctRequest, "id"));

Â 

statement.setString(2, getAttributeRequestValue(acctRequest, "user_role_id"));

Â 

//statement.setString(2, getAttributeRequestValue(acctRequest, "emp_number"));

Â 

statement.setString(4, getAttributeRequestValue(acctRequest,"user_name"));

Â 

statement.setString(5, getAttributeRequestValue(acctRequest, "user_password"));Â statement.executeUpdate();

Â 

result.setStatus(ProvisioningResult.STATUS_COMMITTED);

Â 

}

Â 

//}

Â 

catch (Exception e) {

Â 

System.out.println("==================5");

Â 

System.out.println(e.getMessage());

Â 

e.printStackTrace();

Â 

result.setStatus(ProvisioningResult.STATUS_FAILED);

Â 

throw new Exception(e.getMessage());

Â 

}

Â 

return result;</Source>
</Rule>
<Rule language="beanshell" name="Rule-Inactive" type="IdentityAttribute">
  <Description>Identity attribute rules are used when the value is not simply a copy of an application account attribute value.  A transformation may be necessary on the account attribute, or several account attributes may need to be combined to produce the identity attribute.

This rule can be called in two ways: as a global mapping rule and an application mapping rule.  A global mapping rule is called whenever the identity is refreshed.  The rule can look at any account attributes.  An application mapping rule is called only when the identity contains an account link for that application, this link is passed in the "link" argument which is not passed in global mapping rules.</Description>
  <Signature returnType="String">
    <Inputs>
      <Argument name="log" type="org.apache.commons.logging.Log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context" type="sailpoint.api.SailPointContext">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="environment" type="Map">
        <Description>
           Arguments passed to the aggregation or refresh task.
        </Description>
      </Argument>
      <Argument name="identity">
        <Description>
           The Identity object that represents the user
           that is being aggregated.
        </Description>
      </Argument>
      <Argument name="attributeDefinition">
        <Description>
           The AttributeDefinition object for this attribute.
        </Description>
      </Argument>
      <Argument name="link">
        <Description>
           The Link object from the Identity, if this is an application
           mapping rule.  For global mapping rules this will be void.
        </Description>
      </Argument>
      <Argument name="attributeSource">
        <Description>
          The AttributeSource object.
        </Description>
      </Argument>
      <Argument name="oldValue">
        <Description>
          The original value of the application account attribute.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="attributeValue">
        <Description>
          The value of the attribute that should be populated.
          The rule should return this value.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>String status= identity.getAttribute("emp_status");

if(status!=null){

if(status.equalsIgnoreCase("Terminated"))
{
Â Â Â Â  identity.setInactive(true);
//return true;
}

}
//return false;</Source>
</Rule>
<Rule language="beanshell" name="Rule-IIQDisabled" type="ResourceObjectCustomization">
  <Description>This rule is configured on the application and is called after the connector has build a ResourceObject from the native application data.

Initially designed for non-rule based connectors to add SPPrivileged flag to an object, but could be used to do any transformations.</Description>
  <Signature returnType="ResourceObject">
    <Inputs>
      <Argument name="log" type="org.apache.commons.logging.Log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context" type="sailpoint.api.SailPointContext">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="object">
        <Description>
          The ResourceObject built by the connector.
        </Description>
      </Argument>
      <Argument name="application">
        <Description>
          Application that references the connector.
        </Description>
      </Argument>
      <Argument name="connector">
        <Description>
          The connector object.
        </Description>
      </Argument>
      <Argument name="state">
        <Description>
          A Map containing state information.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="resourceObject">
        <Description>
          The updated resource object.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>log.error("--------------IIQDisabled Rule is Starting------------------------");
log.error("object: "+object.toXml());
log.error("status: "+object.getStringAttribute("emp_status"));
String status_emp=object.getStringAttribute("emp_status");

if(status_emp!=null &amp;&amp; status_emp.equalsIgnoreCase("Terminated"))
{
	log.error("sttaus is terminated");
Â Â Â  object.put("IIQDisabled", true);
}

log.error("customization rule is ending");
return object;</Source>
</Rule>
<Rule language="beanshell" name="Rule-Exclusion_Rule" type="CertificationExclusion">
  <Description>This rule is an example Certification Exclusion rule that removes all of the certifiable items from a certification if the identity being certified is marked as inactive.</Description>
  <Signature returnType="String">
    <Inputs>
      <Argument name="log" type="org.apache.commons.logging.Log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context" type="sailpoint.api.SailPointContext">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="entity" type="AbstractCertifiableEntity">
        <Description>
          The AbstractCertifiableEntity that is part of the certification.
          Currently, this is either an Identity, ManagedAttribute, or Bundle.
        </Description>
      </Argument>
      <Argument name="certification" type="Certification">
        <Description>
          The certification that this identity is part of.
        </Description>
      </Argument>
      <Argument name="certContext" type="CertificationContext">
        <Description>
          The CertificationContext that is being used to generate the
          certification.
        </Description>
      </Argument>
      <Argument name="items" type="List">
        <Description>
          List of Certifiable items that are currently part of the
          certification for this identity.  Any items that should be excluded
          from the certification should be deleted from this list and added
          to the itemsToExclude list.
        </Description>
      </Argument>
      <Argument name="itemsToExclude" type="List">
        <Description>
          A List of Certifiable items that should not be included in the
          certification.  This list will be empty when the rule is executed
          and any items that should not be part of the certification should
          be moved from the items list to the itemsToExclude list.
        </Description>
      </Argument>
      <Argument name="state">
        <Description>
          A Map containing state information.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="explanation" type="String">
        <Description>
          An optional explanation describing why the items were excluded.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
  
  import java.util.Arrays;
Â Â Â  import java.util.Iterator;
Â Â Â  import java.util.List;
Â Â Â  import sailpoint.object.Certifiable;
Â Â Â  import sailpoint.object.Bundle;
Â Â Â  import sailpoint.object.EntitlementGroup;
Â Â Â  import sailpoint.object.Filter;
Â Â Â  import sailpoint.object.QueryOptions;
Â Â Â  import sailpoint.tools.GeneralException;
Â Â Â Â Â Â Â Â  import sailpoint.object.*;



Â Â Â Â Â Â Â  Iterator iter=items.iterator();
Â Â Â Â Â Â Â  while(iter.hasNext()) {
Â Â Â Â Â Â Â Â Â Â Â  sailpoint.object.Certifiable item=(sailpoint.object.Certifiable)iter.next();
Â Â Â Â Â Â Â Â Â Â Â  if(item instanceof sailpoint.object.Bundle) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  Bundle bun=(Bundle)item;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  String rType=bun.getType();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if(rType.equalsIgnoreCase("rapidSetupBirthright")) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  iter.remove();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  itemsToExclude.add(item);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â  }

Â Â Â 
Â </Source>
</Rule>
<Rule language="beanshell" name="Rule-Sign Off Approval" type="CertificationSignOffApprover">
  <Description>This rule is run when the certification is signed off to determine who (if anyone) needs to approve the certification decisions.  If this returns a non-null identity, the certification is forwarded to the returned identity.</Description>
  <Signature returnType="Map">
    <Inputs>
      <Argument name="log" type="org.apache.commons.logging.Log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context" type="sailpoint.api.SailPointContext">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="certification">
        <Description>
          The sailpoint.object.Certification that was signed.
        </Description>
      </Argument>
      <Argument name="certifier">
        <Description>
          The sailpoint.object.Identity that signed the certification.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="identityName">
        <Description>
        The name of the Identity that should approve the certification.  Either
        this or 'identity' should be non-null if certification sign off approval
        is desired.
        </Description>
      </Argument>
      <Argument name="identity">
        <Description>
        The Identity that should approve the certification.  Either this or
        'identityName' should be non-null if certification sign off approval
        is desired.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import sailpoint.object.Certification;
import sailpoint.object.Identity;Â 
Â List history = certification.getSignOffHistory();
if (history.size() == 1)
{
Â Identity identity = context.getObjectByName(Identity.class, "CISOâ€™s-Group");
Â Map results = new HashMap();Â 
results.put("identityName", identity);
Â return results;
}
else
return null;
}</Source>
</Rule>
<Rule language="beanshell" name="Approval_Assignment_Rule" type="ApprovalAssignment">
  <Signature returnType="null">
    <Inputs>
      <Argument type="log">
        <Description>

The log object associated with the SailPointContext.

</Description>
      </Argument>
      <Argument type="context">
        <Description>

A sailpoint.api.SailPointContext object that can be used to query the database if necessary.

</Description>
      </Argument>
      <Argument type="approvals">
        <Description>

List of approvals generated by the approvalScheme, maybe null if there were no

          approvals enabled.

</Description>
      </Argument>
      <Argument type="approvalSet">
        <Description>

Representation of the cart, also found on the approvals generated by the

          default schemes.

</Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument type="newApprovals">
        <Description>

Return a lIst of Workflow.Approval objects that should be included

           during the approval process.

</Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>



import sailpoint.object.Workflow;

Â Â import sailpoint.object.Filter;

import sailpoint.object.Workflow.Approval;

Â 

import sailpoint.object.Identity;

Â 

import org.apache.commons.logging.Log;

Â 

import org.apache.commons.logging.LogFactory;

Â 

import sailpoint.object.Application;

Â 

import sailpoint.api.IdentityService;

import sailpoint.object.Link;

import sailpoint.api.ManagedAttributer;

import sailpoint.object.ApprovalItem;

import sailpoint.object.ManagedAttribute;

import sailpoint.tools.Util;

import sailpoint.object.ApprovalSet;

import sailpoint.tools.xml.XMLObjectFactory;

import sailpoint.object.Workflow.Arg;

import sailpoint.object.*;

import java.util.ArrayList;

import java.util.List;

import sailpoint.workflow.IdentityApprovalGenerator;

import java.util.*;
import sailpoint.object.ManagedAttribute;
import sailpoint.api.ManagedAttributer;
import sailpoint.object.ProvisioningPlan.ObjectRequest;



Â 
List entLists = new ArrayList();
List finalApproval = new ArrayList();
entLists.add("cn=cad-user_app,ou=groups,dc=sailpoint,dc=sp");
entLists.add("cn=cck-user_app,ou=groups,dc=sailpoint,dc=sp");
entLists.add("Admin");

Â 
log.error("************* ENTERING THE SampleRule **************");
List approvals = new ArrayList(); // use generics for type safety

Â 

try {
 
Â Â Â  Identity id = context.getObjectByName(Identity.class, identityName);
String identityDisplayName = id.getDisplayName();
Â Â Â  log.error("********** SampleRule CALLING | identity *********::" + id);

Â Â  Identity manager = id.getManager();
Â Â Â  log.error("********** SampleRule CALLING | manager *********::" + manager);

Â  for (ApprovalItem item : approvalSet.getItems()) {
Â Â Â Â Â Â Â  log.error("**********approvalSet item object *********::" + item.toXml());
Â Â Â Â Â Â Â  String itemAppName = item.getApplicationName();
Â Â Â Â Â Â Â  log.error("********** itemAppName *********::" + itemAppName);

Â Â Â Â Â  String itemName = item.getName();Â 
 log.error("********** itemName *********::" + item.getName());
Â Â Â Â Â Â Â  String itemOwner = item.getOwner();
log.error("********** itemOwner *********::" + item.getOwner());

		String itemValueObj = item.getValue().toString();Â  //itemValueObj means cn name like cn=cad cn=cck
		log.error("********** itemValueObj *********::" + itemValueObj);
Â Â Â Â Â Â Â Â Â  String itemValueObj1=itemValueObj.substring(1, itemValueObj.length() - 1);

			log.error("********** itemValueObj1 *********::" + itemValueObj1);

		String attrReqName= item.getDisplayableValue();
		log.error("********** attrReqName *********::" + attrReqName);
Application app = context.getObjectByName(Application.class, itemAppName);


String appid= app.getId();
    log.error("********** appid *********::" + appid);
    
    Application app = context.getObjectByName(Application.class, "Enterprise Directory");
  String appId=app.getId();
   
ManagedAttribute ma= ManagedAttributer.get(context, appId, "groups", itemValueObj1);
   itemOwner= ma.getOwner().getName();
  /*  
 ArrayList maList=new ArrayList();
Â Filter f = Filter.eq("application.name","Enterprise Directory");
QueryOptions qo = new QueryOptions();
qo.add(f);

Â 

maList = context.getObjects(ManagedAttribute.class, qo);

Â 

String s="";
Â Â  int splace=0;
Â  int eplace=0;
String store="";

HashMap maAttrMap = new HashMap();

Â 

for (ManagedAttribute ma : maList) {

Â 

maAttrMap.put(ma.getValue(),ma.getOwner());

Â 

}
Â  HashMap maAttrMap1 = new HashMap();
Â Â  for(Map.Entry m : maAttrMap.entrySet())
Â Â  {Â Â Â Â 

Â Â Â Â  if(itemValueObj1.equals(m.getKey().toString()))
Â Â Â Â  {

Â Â Â Â Â Â Â Â  splace= m.getValue().toString().indexOf("name=");

Â Â Â Â Â Â Â  eplace=m.getValue().toString().indexOf("]");
Â Â Â Â Â Â  store=m.getValue().toString().substring(splace,eplace+1);

Â Â Â Â Â Â  splace=store.indexOf("=");
Â Â Â Â Â Â  eplace=store.indexOf("]");
Â Â Â Â Â Â  store=store.substring(splace+1,eplace);
Â Â Â Â Â Â itemOwner=(Identity)store;

Â Â Â Â  }

Â Â Â Â  if(itemValueObj1.equals(m.getKey().toString())){
Â Â Â Â Â Â Â  splace= m.getValue().toString().indexOf("name=");

Â Â Â Â Â Â Â  eplace=m.getValue().toString().indexOf("]");
Â Â Â Â Â Â  store=m.getValue().toString().substring(splace,eplace+1);

Â Â Â Â Â Â  splace=store.indexOf("=");
Â Â Â Â Â Â  eplace=store.indexOf("]");
Â Â Â Â Â Â  store=store.substring(splace+1,eplace);
Â Â Â Â Â Â  itemOwner=(Identity)store;
Â Â Â Â  }
Â Â Â Â Â Â Â Â  }
    
    
    
    
    
    */




log.error("********** itemOwner *********::" + itemOwner);



Â Â Â Â Â Â Â  log.error("********** SampleRule CALLING | itemName ==&gt; "+ itemName );

Â 

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  log.error("********** SampleRule CALLING | itemOwner ==&gt; "+ itemOwner );
Â Â Â 
Â Â Â Â Â Â Â  log.error("********** SampleRule CALLING | itemValueObj ==&gt; "+ itemValueObj1 );
Â Â Â Â  
Â Â Â Â Â Â Â  Identity identity = app.getOwner();
Â Â Â Â Â Â Â  String appOwner = identity.getName();
Â Â Â Â Â Â Â  log.error("********** identity Appowner ==&gt; "+ identity);
Â Â Â Â Â Â Â  log.error("********** identity appOwner New ==&gt; "+ appOwner);

Â 
Â Â Â Â Â Â Â  if (null != itemAppName &amp;&amp; !itemAppName.isEmpty()) {
Â Â Â Â Â Â Â Â Â Â Â  log.error("********** INSIDE PAM CALL | App Owner Approval *********::" );

Â Â Â Â Â Â Â Â  log.error("itemValueObj: "+itemValueObj);
Â Â Â Â Â Â Â Â Â Â  log.error("********** check owner approval true or false*********::"+entLists.contains(itemValueObj1));
Â Â Â Â Â Â Â Â Â  log.error("list entList: "+entLists);
Â Â Â Â Â Â Â Â Â Â Â  // Check if ent needs two level approval
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â  if (entLists.contains(itemValueObj1)) //or take itemvalueObj if not work
Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â  {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â  log.error("********** inside if condition entitlement list==&gt; "+ entLists.contains(itemValueObj1));Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //adding owner approval for exception list of ent
Â Â Â Â Â Â Â Â Â Â  Â Â Â Â Â Â Â  ApprovalSet ownerApprovalSet = new ApprovalSet();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ownerApprovalSet.add(item);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  Approval ownerApproval = new Approval();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ownerApproval.addArg("workItemTargetClass", "sailpoint.object.Identity");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ownerApproval.addArg("workItemTargetName", identityName);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ownerApproval.setMode("serial");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ownerApproval.setApprovalSet(ownerApprovalSet);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ownerApproval.setOwner(itemOwner);
Â Â Â Â Â Â Â  log.error("itemOwner:--&gt;"+itemOwner);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ownerApproval.setDescription("Owner Approval for - " + identityDisplayName);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  approvals.add(ownerApproval);Â Â 
Â Â Â Â Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â Â Â Â Â  //adding manager approval
Â Â Â Â Â Â Â Â Â Â Â  ApprovalSet mgrApprovalSet = new ApprovalSet();
Â Â Â Â Â Â Â Â Â Â Â  mgrApprovalSet.add(item);
Â Â Â Â Â Â Â Â Â Â Â  Approval mgrApproval = new Approval();
Â Â Â Â Â Â Â Â Â Â Â  mgrApproval.addArg("workItemTargetClass", "sailpoint.object.Identity");
Â Â Â Â Â Â Â Â Â Â Â  mgrApproval.addArg("workItemTargetName", identityName);
Â Â Â Â Â Â Â Â Â Â Â  mgrApproval.setMode("serial");
Â Â Â Â Â Â Â Â Â Â Â  mgrApproval.setApprovalSet(mgrApprovalSet);
Â Â Â Â Â Â Â Â Â Â Â  mgrApproval.setOwner(manager.getName());
Â Â Â Â Â Â Â Â Â Â  log.error("manager.getName():--&gt;"+manager.getName());
Â Â Â Â Â Â Â Â Â Â Â  mgrApproval.setDescription("Manger Approval for - " + identityDisplayName);
Â Â Â Â Â Â Â Â Â Â Â  approvals.add(mgrApproval);

Â 

Â Â Â Â Â Â Â Â Â Â Â  Approval setItemToChildrenEntitlementApproval = new Approval();
Â Â Â Â Â Â Â Â Â Â Â Â setItemToChildrenEntitlementApproval.setChildren(approvals);
Â Â Â Â Â Â Â Â Â Â Â Â setItemToChildrenEntitlementApproval.setMode("serial");
Â Â Â Â Â Â Â Â Â Â Â Â finalApproval.add(setItemToChildrenEntitlementApproval);
Â Â Â Â Â Â Â  }
Â Â Â  }
} catch (Exception e) {
Â Â Â  e.printStackTrace();
Â Â Â  log.error("exception in setting approval");
}


return finalApproval;
  </Source>
</Rule>
<Rule language="beanshell" name="Rule-Exclusion_Rule_Entitlement" type="CertificationExclusion">
  <Description>This rule is an example Certification Exclusion rule that removes all of the certifiable items from a certification if the identity being certified is marked as inactive.</Description>
  <Signature returnType="String">
    <Inputs>
      <Argument name="log" type="org.apache.commons.logging.Log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context" type="sailpoint.api.SailPointContext">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="entity" type="AbstractCertifiableEntity">
        <Description>
          The AbstractCertifiableEntity that is part of the certification.
          Currently, this is either an Identity, ManagedAttribute, or Bundle.
        </Description>
      </Argument>
      <Argument name="certification" type="Certification">
        <Description>
          The certification that this identity is part of.
        </Description>
      </Argument>
      <Argument name="certContext" type="CertificationContext">
        <Description>
          The CertificationContext that is being used to generate the
          certification.
        </Description>
      </Argument>
      <Argument name="items" type="List">
        <Description>
          List of Certifiable items that are currently part of the
          certification for this identity.  Any items that should be excluded
          from the certification should be deleted from this list and added
          to the itemsToExclude list.
        </Description>
      </Argument>
      <Argument name="itemsToExclude" type="List">
        <Description>
          A List of Certifiable items that should not be included in the
          certification.  This list will be empty when the rule is executed
          and any items that should not be part of the certification should
          be moved from the items list to the itemsToExclude list.
        </Description>
      </Argument>
      <Argument name="state">
        <Description>
          A Map containing state information.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="explanation" type="String">
        <Description>
          An optional explanation describing why the items were excluded.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
  
  import java.util.Arrays;
Â Â Â  import java.util.Iterator;
Â Â Â  import java.util.List;
Â Â Â  import sailpoint.object.Certifiable;
Â Â Â  import sailpoint.object.Bundle;
Â Â Â  import sailpoint.object.EntitlementGroup;
Â Â Â  import sailpoint.object.Filter;
Â Â Â  import sailpoint.object.QueryOptions;
Â Â Â  import sailpoint.tools.GeneralException;
Â Â Â Â Â Â Â Â  import sailpoint.object.*;



Â Â Â Â Â Â Â  Iterator iter=items.iterator();
Â Â Â Â Â Â Â  while(iter.hasNext()) {
Â Â Â Â Â Â Â Â Â Â Â  sailpoint.object.Certifiable item=(sailpoint.object.Certifiable)iter.next();
Â Â Â Â Â Â Â Â Â Â Â  if(item instanceof sailpoint.object.Bundle) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  Bundle bun=(Bundle)item;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  String rType=bun.getType();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if(rType.equalsIgnoreCase("rapidSetupBirthright")) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  iter.remove();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  itemsToExclude.add(item);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â  }

Â Â Â  String excludeGroup1 = "cn=cck-admin_app,ou=groups,dc=sailpoint,dc=sp";// cn=admin,mysql,dir
Â Â Â Â Â Â Â  String excludeGroup2 = "cn=dir-admin_net,ou=groups,dc=sailpoint,dc=sp";
Â Â Â Â Â Â Â  String excludeGroup3 = "cn=mysql-admin_dba,ou=groups,dc=sailpoint,dc=sp";



Â 

Â Â Â Â Â Â Â  HashMap groupMap = new HashMap();

Â 

Â Â Â Â Â Â Â  while (iter.hasNext()) {

Â 

Â Â Â Â Â Â Â  sailpoint.object.EntitlementGroup item = (sailpoint.object.EntitlementGroup) iter.next();
Â Â Â Â Â  Attributes attrs = item.getAttributes();

Â 

Â Â Â Â Â Â Â  groupMap = attrs.getMap();
Â Â Â  for(String key: groupMap.keySet()) {

Â 

Â Â Â Â Â Â Â  String groupName = groupMap.get(key);
Â Â Â Â Â Â Â  log.error("groupName===================&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;"+groupName);
Â Â Â  if(!groupName.endsWith(excludeGroup1) || !groupName.endsWith(excludeGroup2) ||!groupName.endsWith(excludeGroup3)) {
Â Â Â Â Â Â Â Â Â Â Â Â Â  itemsToExclude.add(item);
Â Â Â Â Â Â Â  Â  iter.remove();
Â Â Â Â Â Â Â  Â Â Â Â  }

Â 

Â Â Â Â Â Â Â  }

Â 

Â Â Â Â Â Â Â  }

Â 

Â Â Â Â Â Â Â  //item.removeAll(itemsToExclude);

Â Â Â Â Â Â Â  return "Removed Entitlements except all three(cck,dir,mysql)";

Â </Source>
</Rule>
<Rule language="beanshell" name="Rule-AfterProvision_TerminateOU" type="AfterProvisioning">
  <Description>An IdentityIQ server-side rule that is executed after the connector's provisioning method is called. This gives the customer the ability to customize or react to anything in the ProvisioningPlan AFTER it has been sent out to the specific applications. 

This rule will be called for any application found in a plan that also has a configured 'afterProvisioningRule' configured.</Description>
  <Signature>
    <Inputs>
      <Argument name="log" type="org.apache.commons.logging.Log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context" type="sailpoint.api.SailPointContext">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="plan">
        <Description>
          The ProvisioningPlan object on its way to the Connector.
        </Description>
      </Argument>
      <Argument name="application">
        <Description>
          The application object that references this before/after script.
        </Description>
      </Argument>
      <Argument name="result">
        <Description>
          The ProvisioningResult object returned by the connectors provision method. This can be null and in many cases the connector will  not return a result and instead will annotate the plan's ProvisioningResult either at the plan or account level.        
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>import sailpoint.api.Provisioner;
import sailpoint.object.Identity;
import sailpoint.object.ProvisioningPlan;
import sailpoint.object.ProvisioningPlan.AccountRequest.Operation;
import sailpoint.tools.GeneralException;
import sailpoint.object.ProvisioningPlan.AccountRequest;
import sailpoint.object.ProvisioingPlan.AttributeRequest;

Â 

Â 
log.error("-------&gt; After Provisioning Delete Rule is Running &lt;-------");

Â 

List accReqs= plan.getAccountRequests();

Â 

Â Â Â Â Â Â Â  log.error("accReqs List------------------&gt;&gt;Â  "+accReqs);
Â Â Â Â Â Â Â  for(AccountRequest accReq :accReqs)
Â Â Â Â Â Â Â  {

Â 

Â 

Â 

Â Â Â Â Â Â Â Â Â Â Â  if(ProvisioningPlan.AccountRequest.Operation.Delete.equals(accReq.getOperation()))
Â Â Â Â Â Â Â Â Â Â Â  {

Â 

Â 

Â 

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if(accReq.getResult() != nullÂ  &amp;&amp; accReq.getResult().isCommitted())
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  {

Â 

Â 

Â 

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  Object identity=plan.getIdentity();

Â 

Â 

Â 

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  log.error("+++++++++++++"+ identity +"+++++++++++++");

Â 

Â 

Â 

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  String nativeIdentity = accReq.getNativeIdentity();

Â 

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  AccountRequest newAccReq2=new AccountRequest();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  AccountRequest newAccReq=new AccountRequest();

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  newAccReq2.setNativeIdentity(nativeIdentity);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  newAccReq2.setApplication("Enterprise Directory");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  newAccReq2.setOperation(AccountRequest.Operation.Delete);

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  newAccReq.setApplication("Enterprise Directory");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  log.error("+++++++++++++"+ identity.getFirstname() +"+++++++++++++");

Â 

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if(null != nativeIdentity){
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  nativeIdentity = nativeIdentity.replace("ou=people","ou=Terminated");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }

Â 

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  newAccReq.setNativeIdentity(nativeIdentity);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  newAccReq.setOperation(AccountRequest.Operation.Create);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ProvisioningPlan plan1=new ProvisioningPlan();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  plan1.setIdentity(identity);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  plan1.add(newAccReq2);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  plan1.add(newAccReq);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  log.error("#############Printing Plan##############");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  log.error(plan1.toXml());
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  Provisioner p=new Provisioner(context);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  p.compile(plan1);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  p.execute();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }

Â 

Â 

Â 

Â Â Â Â Â Â Â Â Â Â Â  }

Â 

Â 

Â 

Â Â Â Â Â Â Â  }</Source>
</Rule>
<Rule language="beanshell" name="Rule-Terminate_NEW" type="AfterProvisioning">
  <Description>An IdentityIQ server-side rule that is executed after the connector's provisioning method is called. This gives the customer the ability to customize or react to anything in the ProvisioningPlan AFTER it has been sent out to the specific applications. 

This rule will be called for any application found in a plan that also has a configured 'afterProvisioningRule' configured.</Description>
  <Signature>
    <Inputs>
      <Argument name="log" type="org.apache.commons.logging.Log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context" type="sailpoint.api.SailPointContext">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="plan">
        <Description>
          The ProvisioningPlan object on its way to the Connector.
        </Description>
      </Argument>
      <Argument name="application">
        <Description>
          The application object that references this before/after script.
        </Description>
      </Argument>
      <Argument name="result">
        <Description>
          The ProvisioningResult object returned by the connectors provision method. This can be null and in many cases the connector will  not return a result and instead will annotate the plan's ProvisioningResult either at the plan or account level.        
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>import sailpoint.api.Provisioner;
import sailpoint.object.Identity;
import sailpoint.object.ProvisioningPlan;
import sailpoint.object.ProvisioningPlan.AccountRequest.Operation;
import sailpoint.tools.GeneralException;
import sailpoint.object.ProvisioningPlan.AccountRequest;
 import sailpoint.object.ProvisioingPlan.AttributeRequest;
  log.error("The After provisioming rule is starting Terminated OU");			
         log.error("-------starting plan-----"+plan.toXml()); 
		 log.error("result: "+plan.getResult());
Â Â Â Â Â Â  List accReqs= plan.getAccountRequests();
		if(plan.getResult() != null  &amp;&amp;  plan.getResult().isCommitted())
Â Â Â Â Â Â Â Â {
			log.error("---------------line number one-------");
Â Â Â Â Â Â  		for(AccountRequest accReq :accReqs)
Â Â Â Â Â Â   	{
				log.error("---------------line number two-------");
				if(AccountRequest.Operation.Delete.equals(accReq.getOperation()))
			Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â         log.error("operation is delete");Â Â Â 
Â Â Â Â Â Â Â Â Â Â   	Identity identity=plan.getIdentity();

Â Â Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â Â  log.error("-------------------&gt;"+ identity +"&amp;lt;------------------------");
Â Â Â Â Â Â Â Â Â Â Â Â  String nativeIdentity = accReq.getNativeIdentity();
			if(null != nativeIdentity){
Â Â Â Â Â Â Â Â Â Â Â Â Â  nativeIdentity = nativeIdentity.replace("ou=people","ou=Terminated");
Â Â Â Â Â Â Â Â Â Â Â Â  AccountRequest newAccReq=new AccountRequest();
	            AttributeRequest attdn = new AttributeRequest("dn",nativeIdentity);
				newAccReq.add(attdn);
				
				
Â Â Â Â Â Â Â Â Â Â Â Â  newAccReq.setApplication("Enterprise Directory");
Â Â Â Â Â Â Â Â Â Â Â Â  log.error("+++++++++++++"+ identity.getFirstname() +"+++++++++++++");
Â Â Â Â Â Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â Â Â Â Â Â  newAccReq.setNativeIdentity(nativeIdentity);
Â Â Â Â Â Â Â Â Â Â Â Â  newAccReq.setOperation(AccountRequest.Operation.Create);
Â Â Â Â Â Â Â Â Â Â Â Â  ProvisioningPlan plan1=new ProvisioningPlan();
Â Â Â Â Â Â Â Â Â Â Â Â  plan1.setIdentity(identity);
Â Â Â Â Â Â Â Â Â Â Â Â  plan1.add(newAccReq);
Â Â Â Â Â Â Â Â Â Â Â Â  log.error("#############Printing Plan##############");
Â Â Â Â Â Â Â Â Â Â Â Â  log.error(plan1.toXml());
Â Â Â Â Â Â Â Â Â Â Â Â  Provisioner p=new Provisioner(context);
Â Â Â Â Â Â Â Â Â Â Â Â  p.compile(plan1);
Â Â Â Â Â Â Â Â Â Â Â Â  p.execute();Â Â Â 
           }Â Â Â Â Â Â Â 
                }            
Â Â Â Â Â Â Â Â Â Â   }
        }</Source>
</Rule>
<Rule language="beanshell" name="Rule_check_All_Managedattribute">
  <Source>



import sailpoint.object.Workflow;

Â import sailpoint.object.Filter;

import sailpoint.object.Workflow.Approval;

Â 

import sailpoint.object.Identity;

Â 

import org.apache.commons.logging.Log;

Â 

import org.apache.commons.logging.LogFactory;

Â 

import sailpoint.object.Application;

Â 

import sailpoint.api.IdentityService;

import sailpoint.object.Link;

import sailpoint.api.ManagedAttributer;

import sailpoint.object.ApprovalItem;

import sailpoint.object.ManagedAttribute;

import sailpoint.tools.Util;

import sailpoint.object.ApprovalSet;

import sailpoint.tools.xml.XMLObjectFactory;

import sailpoint.object.Workflow.Arg;

import sailpoint.object.*;

import java.util.ArrayList;

import java.util.List;

import sailpoint.workflow.IdentityApprovalGenerator;

import java.util.*;
import sailpoint.object.ManagedAttribute;
import sailpoint.api.ManagedAttributer;
import sailpoint.object.ProvisioningPlan.ObjectRequest;

  
  
  

 ArrayList maList=new ArrayList();
Â Filter f = Filter.eq("application.name","Enterprise Directory");
QueryOptions qo = new QueryOptions();
qo.add(f);

maList = context.getObjects(ManagedAttribute.class, qo);

String s="";
   int splace=0;
  int eplace=0;
 String store="";
HashMap maAttrMap = new HashMap();

for (ManagedAttribute ma : maList) {

maAttrMap.put(ma.getValue(),ma.getOwner());

}
  HashMap maAttrMap1 = new HashMap();
   for(Map.Entry m : maAttrMap.entrySet())
   {    
 
     if("cn=cad-user_app,ou=groups,dc=sailpoint,dc=sp".equals(m.getKey().toString()))
     {
       
         splace= m.getValue().toString().indexOf("name=");
       
        eplace=m.getValue().toString().indexOf("]");
       store=m.getValue().toString().substring(splace,eplace+1);
    
       splace=store.indexOf("=");
       eplace=store.indexOf("]");
       store=store.substring(splace+1,eplace);
       
         
         
       
       s+=store+'\n';
       
     }
     
     if("cn=cck-user_app,ou=groups,dc=sailpoint,dc=sp".equals(m.getKey().toString())){
        splace= m.getValue().toString().indexOf("name=");
       
        eplace=m.getValue().toString().indexOf("]");
       store=m.getValue().toString().substring(splace,eplace+1);
    
       splace=store.indexOf("=");
       eplace=store.indexOf("]");
       store=store.substring(splace+1,eplace);
       s+=store;
     }
         }
        
return s;
  </Source>
</Rule>
<Rule language="beanshell" name="Rule_generate_Managedattribute">
  <Source>

  
import sailpoint.object.Workflow;

Â Â import sailpoint.object.Filter;

import sailpoint.object.Workflow.Approval;

Â 

import sailpoint.object.Identity;

Â 

import org.apache.commons.logging.Log;

Â 

import org.apache.commons.logging.LogFactory;

Â 

import sailpoint.object.Application;

Â 

import sailpoint.api.IdentityService;

import sailpoint.object.Link;

import sailpoint.api.ManagedAttributer;

import sailpoint.object.ApprovalItem;

import sailpoint.object.ManagedAttribute;

import sailpoint.tools.Util;

import sailpoint.object.ApprovalSet;

import sailpoint.tools.xml.XMLObjectFactory;

import sailpoint.object.Workflow.Arg;

import sailpoint.object.*;

import java.util.ArrayList;

import java.util.List;

import sailpoint.workflow.IdentityApprovalGenerator;

import java.util.*;
import sailpoint.object.ManagedAttribute;
import sailpoint.api.ManagedAttributer;
import sailpoint.object.ProvisioningPlan.ObjectRequest;
  
  
  
   Application app = context.getObjectByName(Application.class, "Enterprise Directory");
  String appId=app.getId();
   
ManagedAttribute ma= ManagedAttributer.get(context, appId, "groups", "cn=cad-user_app,ou=groups,dc=sailpoint,dc=sp");
  return ma.getOwner().getName()+"\n";

  </Source>
</Rule>
</sailpoint>
